Go不支持函数重载

闭包就是一个函数和与其相关的引用环境组合的一个整体。可以理解成：闭包是类，函数是操作。

defer延时机制。当执行到defer时，暂时 不执行，会将defer后的语句压入到独立的栈中。当函数执行完毕后，再从栈按照LIFO的方式出栈执行。（defer是为了在函数执行完毕后及时地释放资源）

time.Time的Format里，"2006/01/02 15:04:05" 这里年月日时分秒的数字是固定的，必须用这些数字。但可以自由组合，如"2006-01-02"

输出地址的标识符是%p

切片的容量是可变的，会动态增加。

切片如果使用数组初始化 var slice = arr[start:end]，不能越界，但是可以动态增长。（我理解是[append追加](https://blog.csdn.net/weixin_33249594/article/details/115362963)）

Golang 数组作为参数传入函数时进行的是值传递，而切片进行的是引用传递。（如果想要在函数中修改数组的值，应该传递指针。例如 func myfunc(arr *[5]int) ）

Golang 中没有专门针对 map 的 key 进行排序；map默认是无序的，且每次遍历的输出可能不一样。Golang 中的 map 排序，是先将 key 进行排序，然后根据 key 值遍历输出即可。

Golang 没有类(Class)，Go 语言的结构体(struct)和其他语言的类(class)有同等地位。Golang 是基于 struct 来实现 OOP 特性的。

结构体实例在内存中是值类型，而不是引用类型。（即内存中直接存放数据）

Go 的设计者为了程序员使用方便，会对结构体的指针取值运算进行处理。例如，var p \*Person = new (Person)，则 p.Name = "xxx" 就相当于 (\*p).Name = "xxx"；此外，在结构体绑定的方法里，如果绑定的是指针，则在调用的时候也进行了处理。例如，func (c *Circle) area(){...}，在调用的时候 c.area() 等价于 (&c).area()。不管调用形式如何，真正决定是值拷贝还是地址拷贝，看这个方法是和哪个类型绑定.

结构体 type 重新定义相当于取别名，Golang 会认为是新的数据类型，但是相互间可以强转。

如果一个 struct 嵌套了一个有名结构体，这种模式就是组合，如果是组合关系，那么在访问组合 的结构体的字段或方法时，必须带上结构体的名字

Golang中的接口不需要显式的实现。只要一个变量，含有接口类型中的所有方法，那么这个变量就实现这个接口

接口本身不能创建实例，但是可以指向一个实现了该接口的自定义类型的变量(实例)

测试用例文件名必须以 _test.go 结尾，测试用例函数必须以 Test 开头

使用内置函数 close 可以关闭 channel，当 channel 关闭后，就不能再向 channel 写数据了，但是仍然 可以从该 channel 读取数据

channel 支持 for--range 的方式进行遍历，请注意两个细节：在遍历时，如果 channel 没有关闭，则回出现 deadlock 的错误；在遍历时，如果 channel 已经关闭，则会正常遍历数据，遍历完后，就会退出遍历。

channel容量有限，写入速度如果很快，即使读的速度很慢也不会报错，因为内部会自动调节。但如果没有任何读的操作，就会超过容量发生死锁。

一旦负责写数据的协程，写数据写的太快，或者负责读数据的协程，读数据读的太慢，channel就会被填满，此时负责写数据的协程就会被阻塞住。反之，读数据的协程处理很快，写数据的协程写数据很慢，那么channel很快便会被取空，一旦channel变成空的之后，读数据的协程便会被阻塞掉。

可以使用 defer + recover 捕获抛出的异常

```go
defer func(){
	if err := recover(); err!= nil{
		// 异常处理语句
	}
}()
```

goroutine中一个协程出现了panic，如果没有捕获这个panic会导致整个程序崩溃。可以再goroutine中使用recover来捕获panic进行处理

