Golang 中没有专门的字符类型，如果要存储单个字符(字母)，一般使用 byte 来保存

反引号，以字符串的原生形式输出，包括换行和特殊字符

Go 在不同类型的变量之间赋值时需要显式转换

其他类型转string：1）fmt.Sprintf(format string, a ...interface{}) ；2）strconv 包的 FormatXxx。 string转其他类型：strconv.ParseXxx

如果需要遍历中文字符串，要么 str 转成 []rune 切片遍历，要么使用 for-range

每一个源文件都可以包含一个 init 函数，该函数会在 main 函数执行前，被 Go 运行框架调用

如果一个文件同时包含全局变量定义，**init** 函数和 **main** 函数，则执行的流程全局变量定义**->init**函数**->main** 函数

Go不支持函数重载

闭包就是一个函数和与其相关的引用环境组合的一个整体。可以理解成：闭包是类，函数是操作。当我们反复的调用 f 函数时，因为 一些变量只是初始化一次，因此每调用一次就进行累计。（见pdf 189-190页）

defer延时机制。当执行到defer时，暂时 不执行，会将defer后的语句压入到独立的栈中。当函数执行完毕后，再从栈按照LIFO的方式出栈执行。（defer是为了在函数执行完毕后及时地释放资源）

time.Time的Format里，"2006/01/02 15:04:05" 这里年月日时分秒的数字是固定的，必须用这些数字。但可以自由组合，如"2006-01-02"

输出地址的标识符是%p

切片的容量是可变的，会动态增加。

切片如果使用数组初始化 var slice = arr[start:end]，不能越界，但是可以动态增长。（我理解是[append追加](https://blog.csdn.net/weixin_33249594/article/details/115362963)）

Golang 数组作为参数传入函数时进行的是值传递，而切片进行的是引用传递。（如果想要在函数中修改数组的值，应该传递指针。例如 func myfunc(arr *[5]int) ）

声明二维数组时，等号右边第二维的大小一定要写。比如 var 数组名 = \[...\]\[大小\]类型{{初值..},{初值..}}

Golang 中没有专门针对 map 的 key 进行排序；map默认是无序的，且每次遍历的输出可能不一样。Golang 中的 map 排序，是先将 key 进行排序，然后根据 key 值遍历输出即可。

Golang 没有类(Class)，Go 语言的结构体(struct)和其他语言的类(class)有同等地位。Golang 是基于 struct 来实现 OOP 特性的。

struct 的每个字段上，可以写上一个 tag, 该 tag 可以通过反射机制获取，常见的使用场景就是序 列化和反序列化（）

结构体实例在内存中是值类型，而不是引用类型。（即结构体在内存中直接存放数据）。在方法调用中，遵守值类型的传递机制，是值拷贝传递方式，程序员希望在方法中，修改结构体变量的值，可以通过结构体指针的方式来处理。

Go 的设计者为了程序员使用方便，会对结构体的指针取值运算进行处理。例如，var p \*Person = new (Person)，则 p.Name = "xxx" 就相当于 (\*p).Name = "xxx"；此外，在结构体绑定的方法里，如果绑定的是指针，则在调用的时候也进行了处理。例如，func (c *Circle) area(){...}，在调用的时候 c.area() 等价于 (&c).area()。不管调用形式如何，真正决定是值拷贝还是地址拷贝，看这个方法是和哪个类型绑定.

结构体 type 重新定义相当于取别名，Golang 会认为是新的数据类型，但是相互间可以强转。

Golang 中，如果一个 struct 嵌套了另一个**匿名结构体**，那么这个结构体可以直接访问匿名结构体的字段和方法，从而实现了继承特性。当结构体和匿名结构体有相同的字段或者方法时，编译器采用就近访问原则访问。

如果一个 struct 嵌套了一个有名结构体，这种模式就是组合，如果是组合关系，那么在访问组合 的结构体的字段或方法时，必须带上结构体的名字

接口里的所有方法都没有方法体，即接口的方法都是没有实现的方法。接口体现了程序设计的多态和高内聚低偶合的思想。

Golang中的接口不需要显式的实现。只要一个变量，含有接口类型中的所有方法，那么这个变量就实现这个接口

接口本身不能创建实例，但是可以指向一个实现了该接口的自定义类型的变量(实例)

由于接口是一般类型，不知道具体类型，如果要转成具体类型，就需要使用类型断言。

测试用例文件名必须以 _test.go 结尾，测试用例函数必须以 Test 开头。

MPG模式【自行查阅】

channal 是线程安全的，多 goroutine 访问时，不需要加锁。

使用内置函数 close 可以关闭 channel，当 channel 关闭后，就不能再向 channel 写数据了，但是仍然 可以从该 channel 读取数据

channel 支持 for--range 的方式进行遍历，请注意两个细节：在遍历时，如果 channel 没有关闭，则回出现 deadlock 的错误；在遍历时，如果 channel 已经关闭，则会正常遍历数据，遍历完后，就会退出遍历。

channel容量有限，写入速度如果很快，即使读的速度很慢也不会报错，因为内部会自动调节。但如果没有任何读的操作，就会超过容量发生死锁。

一旦负责写数据的协程，写数据写的太快，或者负责读数据的协程，读数据读的太慢，channel就会被填满，此时负责写数据的协程就会被阻塞住。反之，读数据的协程处理很快，写数据的协程写数据很慢，那么channel很快便会被取空，一旦channel变成空的之后，读数据的协程便会被阻塞掉。

可以使用 defer + recover 捕获抛出的异常

```go
defer func(){
	if err := recover(); err!= nil{
		// 异常处理语句
	}
}()
```

goroutine中一个协程出现了panic，如果没有捕获这个panic会导致整个程序崩溃。可以再goroutine中使用recover来捕获panic进行处理

反射可以在运行时动态获取变量的各种信息, 比如变量的类型(type)，类别(kind)。如果是结构体变量，还可以获取到结构体本身的信息(包括结构体的字段、方法)。通过反射，可以修改变量的值，可以调用关联的方法。

变量、interface{} 和 reflect.Value 是可以相互转换的

<img src="https://tva1.sinaimg.cn/large/008vxvgGgy1h7e81j7tzpj30r20bmdh5.jpg" alt="截屏2022-10-22 18.03.02" style="zoom:50%;" />

通过反射的来修改变量，注意当使用 SetXxx 方法来设置需要通过对应的指针类型来完成，同时需要使用到 reflect.Value.Elem()方法。

P290 反射的最佳实践案例，这个有空再熟悉一下（结构体的反射 取字段、调用方法）。还有 P291，稍微难一些，讲义上没有。

反射方法的默认排序是按照方法名排序（ASCII码）
