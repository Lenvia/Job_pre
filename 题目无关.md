[TOC]

## 系统

### scanf函数的返回值是成功赋值的变量个数。

例如：

```
int h;
while(scanf("%d",&h)!= EOF){
		...
}
```

可用来判断是否有数据未被测试完



### scanf输入结束

如果题目没有明确给结束字符，可以使用~scanf或者 scnaf()!=EOF

https://blog.csdn.net/weixin_42105789/article/details/84582032

~是按位取反

scanf的返回值是输入值的个数

如果没有输入值就是返回-1

-1按位取反结果是0

while(~scanf("%d", &n))就是当没有输入的时候退出循环



HDU 1281我就是因为没加结束判断，TLE了N次





### scanf输入double

double a,b,c;
scanf("%lf%lf%lf",&a,&b,&c);



### printf输出百分号%

printf函数中,%用于格式控制,如果想输出文本%,需要使用两个百分号,即%%就可以了



### cin、cin.get()、cin.getline()、getline()的区别

https://blog.csdn.net/a3192048/article/details/80303547

（有一个读取带有空格的字符串的例子：https://www.nowcoder.com/questionTerminal/136de4a719954361a8e9e41c8c4ad855?toCommentId=5237096）



说一些常用的：

在平时一般输入的时候，是不用考虑cin各个用法的。

但当遇到字符和字符串混合输入的时候可能会出现问题。因为cin读取的时候，会把回车键留在缓冲区。如果字符串使用的是getline输入，则只会读取一个回车。

```
int main(){
    char a;
    char b;

    cin>>a;//输入一个字母'q'
    cout<<a<<endl;
    cin.get(b);//自动加载缓冲区内的换行符
    cout<<(int)b<<endl;
}
```

<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg0c1i1d5qj30es04swek.jpg" alt="截屏2020-06-21 23.34.29" style="zoom: 67%;" />



比如，这里把b缓存string类型，然后再用getline()读取：

```
int main(){
    char a;
    string b;

    cin>>a;//输入一个字母'q'
    cout<<a<<endl;
    getline(cin, b);//自动加载缓冲区内的换行符
    cout<<b<<endl;
}
```

<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg0c2mhrhnj30f004k0ss.jpg" alt="截屏2020-06-21 23.35.34" style="zoom:67%;" />

所以它根本不会给你输入getline()的机会，直接就读了缓存区中的回车键并输出。（补充：getline()是string头文件下的，而cin.getline()是iostream下的）



**<font color=red>因此，平时如果使用cin字母或数字后，想要使用getline(cin, str)输入字符串，需要在cin后 立即 使用getchar()或cin.get()读取字符末尾的回车。</font>**



**cin不影响读入两个用空格隔开的字符串！**

（比如《刷题笔记》中"复数集合"里，"Insert a+ib"可以直接输入到两个string变量里，而不需要用getline读取再分开。

```
int main(){
    string str1;
    string str2;
    cin>>str1>>str2;

    cout<<str1<<endl;
    cout<<str2<<endl;
}
```

<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg82gpql7uj30f404m74g.jpg" alt="截屏2020-06-28 16.07.37" style="zoom: 67%;" />



### printf常用输出格式

%2d表示输出场宽为2的整数，超过2位按照实际数据输出，不够2位右对齐输出。

%02d表示输出场宽为2的整数，超过2位按实际数据输出，不够2位前置补0。（比如输出年月日）

%5.2f表示输出场宽为5的浮点数，其中小数点后有2位，不够5位右对齐输出。



### C++自带的sort函数

头文件 #include \<algorithm>

sort(first,last,comp) 

sort的范围是 [first, last)

first和last为带排序序列的起始地址和结束地址；comp为排序方式，可以不填写，不填写时默认为升序方式。

如果是降序，可以自定义comp函数：

```
bool cmp(int x, int y){
    return x>y;
}

...

sort(a, a+n, cmp); //对数组a进行降序排列
```



sort也能对string[]数组排序，是按照字典序

sort对结构体进行排序时，需要自定义comp函数。例如《刷题笔记》中的“奥运排序”

<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg0xi0qfi8j30lo0nkmz8.jpg" alt="截屏2020-06-22 11.56.57" style="zoom:50%;" />



以及对pair类型排序。例如“开门人和关门人”

<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg0xk8ydl9j30um098q40.jpg" alt="截屏2020-06-22 11.59.07" style="zoom:50%;" />

<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg0xkk1m6xj30hm02q74i.jpg" alt="截屏2020-06-22 11.59.25" style="zoom:50%;" />

<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg0xko33rrj30ji02mt91.jpg" alt="截屏2020-06-22 11.59.31" style="zoom:50%;" />



### stable_sort()

顾名思义stable_sort()为**稳定排序**；

<font color=blue>稳定排序：在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的**相对次序保持不变**，则为稳定排序。</font>

或许你会问，既然相等，为什么还要管相对位置呢，也分不清楚谁是谁啊。这里需要弄清楚一个问题，这里的相等，指的是你提供的函数表示两个元素相等，并不一定是一模一样的元素。

例如：按照字符串长度给字符串排序，当字符串长度相同时，按照字典序对相同长度的字符串进行字典序排序。

注意：sort()比stable_sort()快，所以若没有稳定排序的需求时，用sort();

```
bool cmp(string a, string b){
    return a.length()<b.length();
}


int main(){
    vector<string>vec;
    vec.push_back("abc");
    vec.push_back("sss");
    vec.push_back("ww");
    vec.push_back("aba");
    vec.push_back("www");
    stable_sort(vec.begin(), vec.end(), cmp);
    
    for(int i=0; i<vec.size(); i++){
        cout<<vec[i]<<" ";
    }
    cout<<endl;
}

// ww abc sss aba www 
```

例题：成绩排序

https://www.nowcoder.com/practice/0383714a1bb749499050d2e0610418b1?tpId=40&tqId=21333&tPage=1&rp=1&ru=/ta/kaoyan&qru=/ta/kaoyan/question-ranking



### freopen("in.txt","r",stdin) 函数的用法

https://blog.csdn.net/sinat_34166518/article/details/88836142

https://blog.csdn.net/u013480600/article/details/18372341

**例子**

```
#include <cstdio>   
#include <iostream>
int main()
{
    int a,b;
    freopen("in.txt","r",stdin); //输入重定向，输入数据将从in.txt文件中读取
    freopen("out.txt","w",stdout); //输出重定向，输出数据将保存在out.txt文件中
    while(cin>> a >> b)
        cout<< a+b <<endl; // 注意使用endl
    fclose(stdin);//关闭文件
    fclose(stdout);//关闭文件
    
    return 0;
}
```



### fill初始化赋值

https://blog.csdn.net/qq_32095699/article/details/79303922

fill函数可以为数组或者vector中的每个元素赋以相同的值，通常用于初始化

例子：

```
#include <algorithm>
#include <stdio.h>
using namespace std;
int v[10];
int main(int argc, char const *argv[])
{
    fill(v,v+10,-1);
    for (int i = 0; i <10; ++i)
        printf("%d ",v[i]);

    return 0;
}
```

给多维数组赋值：

```
#include <algorithm>
#include <stdio.h>
using namespace std;
int v[10][10];
int main(int argc, char const *argv[])
{
    fill(v[0],v[0]+10*10,-1);
    for (int i = 0; i <10; ++i){
        for (int j = 0; j <10 ; ++j){
            printf("%d ",v[i][j] );
        }
        printf("\n");
    }   
    return 0;
}
```



## string

### string中的find()函数

https://www.cnblogs.com/wkfvawl/p/9429128.html

返回值是字母在母串中的位置（下标记录），如果找不到，返回的是string::npos

（最好别写成-1）

find_first_of()返回首次出现的位置，find_last_of()返回最后一次出现的位置



find(子串, start) 查找在start位置之后出现子串的位置



查找所有子串在母串中出现的位置

```
//查找s 中flag 出现的所有位置。
    flag="a";
    position=0;
    int i=1;
    while((position=s.find(flag,position))!=string::npos)
    {
        cout<<"position  "<<i<<" : "<<position<<endl;
        position++;//别忘了加一！！！！！
        i++;
    }
```



反向查找子串在母串中出现的位置，通常我们可以这样来使用，当正向查找与反向查找得到的位置不相同说明子串中的某字符（串）不唯一。

```
 position=s.rfind (flag);
```

如果能找到，返回的是正常下标。



### C++ count

头文件 #include \<algorithm>

```
int num = count(str.begin(),str.end(),ch) //str中字符ch出现的次数
```





###  strlen(str)和str.length()和str.size()的区别

strlen(str)和str.length()和str.size()都可以求字符串长度,返回字符串中字符的长度，不包括‘/0’。

其中str.length()和str.size()是同义词，返回同样的值。

**strlen(str)是用于求字符数组的长度，其参数是char*。**



### string迭代器遍历

例1

```
string str="hello world";
for(string::iterator it = str.begin(); it != str.end(); it++){
		printf("%c ", *it);
}
printf("\n");
```

<font color=blue>例2</font>

```
#include<iostream>
#include<string>
using namespace std;
int main()
{
    string str1,str2;
    cin >> str1;
    //定义一个正向迭代器
    string::iterator ptr1 = str1.begin();
    //正向输出字符串
    while (ptr1 != str1.end())
        cout << *(ptr1++) << " ";
    cout << endl;
 
    cin >> str2;
    //定义一个逆向迭代器  注意后面是rbegion()
    string::reverse_iterator ptr2 = str2.rbegin();
    //逆向输出字符串
    while (ptr2 != str2.rend())
    //注意逆向迭代器移动方向相反，所以从尾部仍然通过++来移动
        cout << *(ptr2++) << " ";
    cout << endl;
}
```



### string里的insert()

https://www.cnblogs.com/meihao1203/p/9670680.html

常用的操作：

| 函数原型                               | 举例                                                         |
| -------------------------------------- | ------------------------------------------------------------ |
| 在index位置插入count个字符ch           | string str = "meihao";**string sstr = str.insert(0,2,'a');**     //**aa**meihao |
| index位置插入一个常量字符串            | string str = "meihao";**string sstr = str.insert(1,"hello~");**    //m**hello~**eihao |
| index位置插入常量字符串中的count个字符 | string str = "meihao";**string sstr = str.insert(1,"hello~",3);**    //m**hel**eihao |
| index位置插入常量string                | string str = "meihao";**string sstr = str.insert(1,str);**    //m**meihao**eihao |



### string里的erase()

https://blog.csdn.net/hou09tian/article/details/87913451

https://blog.csdn.net/lynn_xl/article/details/89151535 (删除指定字符)

注意纯数字和迭代器的区别

当只有一个参数时，迭代器表示删除该位置的字符，纯数字表示删除该位置之后的字符。

当有两个参数时，迭代器表示删除两个位置（左闭右开）之间的字符，纯数字表示删除第一个数字位置之后的n个字符，n是第二个数字。

<font color=red>line.erase左边不能放等号</font>

```
std::string str1("This is an example sentence.");
cout<<str1<<endl<<endl;

std::string str2("This is an example sentence.");
str2.erase(10, 8);//删除位置10后面的8个字符（包括位置10）
cout<<str2<<endl<<endl;

std::string str3("This is an example sentence.");
str3.erase(str3.begin() + 9);//删除第9个位置的字符
cout<<str3<<endl<<endl;

std::string str4("This is an example sentence.");
str4.erase(10);//删除第10个位置之后的字符
cout<<str4<<endl<<endl;

std::string str5("This#is an example$sentence.");
str5.erase(str5.begin() + 5, str5.end() - 9);//删除第5个位置之后到倒数第9个位置之间的字符（左闭右开）
cout<<str5<<endl<<endl;
```

输出结果

```
This is an example sentence.

This is an sentence.

This is a example sentence.

This is an

This#sentence.
```



### string里的replace()

https://blog.csdn.net/yinhe888675/article/details/50920836

```
//同样 如果是迭代器 则表示两个位置之间，如果是纯数字，一个表示开始位置，一个表示数量

line = line.replace(line.begin(), line.begin()+6, "");  //用str替换从begin位置开始的6个字符  

line = line.replace(0, 5, str); //用str替换从指定位置0开始长度为5的字符串
```

（小例子：https://www.nowcoder.com/practice/5b58a04679d5419caf62c2b238e5c9c7?tpId=61&tqId=29518&tPage=1&ru=%2Fkaoyan%2Fretest%2F1002&qru=%2Fta%2Fpku-kaoyan%2Fquestion-ranking）

**注：replace用来替换的必须是string类型而不是char类型**

char到string的转换例子：

```
char ch= 'a';
string temp=" ";  //必须要初始化成长度为1的字符串
temp[0]=ch;
```

<font color=red>如果要替换的不是搜索的字符（比如替换所有空格后面的一个字符为XXX，每次搜索的都是空格，但替换的不是空格），最好不要用replace！</font>乖乖遍历。



### 取子串substr()

https://blog.csdn.net/yyhaohaoxuexi/article/details/51416874

例子：

```
//截取x[5]到结尾，即npos.重载原型为string substr(_off,_count=npos)
cout<<x.substr(5)<<endl;

//以x[0]为始，向后截取5位（包含x[0]），重载原型string substr(_off,_count)
cout<<x.substr(0,5)<<endl; 
```



### 字符串取反

https://www.cnblogs.com/suppercobweb/p/6808462.html

```
#include <algorithm>

...

string s="123456";
reverse(s.begin(),s.end());
```

**其实向量也很好玩**





### string里的数字到int

ch-'0';//ch为'0'~'9'，适合按位运算的情况

另外，有时可能会用到 ch-'a'//ch为'a'~'z'时



### 在string末尾添加一个字符char

方法1:直接push_back

```
string origin = "12345";
char ch= '0';
origin.push_back(ch);

//origin = "123450"
```

方法2:拼接

```
string origin = "12345";
char ch= '0';
string s(1, ch);
origin += s;

//origin = "123450"
```



### string初始化

string s = (长度, 字符);

例子：

```
string s(5,' ');//初始化5个空格组成的字符串
```



### string和int相互转换

https://blog.csdn.net/m0_37316917/article/details/82712017

**string转int**

```
#include <iostream>
#include <string>
using namespace std;

int main(){
    string str1;
    while(cin>>str1){
        int int1 = std::stoi(str1);
        cout<<int1<<endl;
    }
    
    return 0;
}

```

类似的， stol转long， stoll转long long



**int转string**

C++11里自带std::to_string()

<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggjj54u2loj30ue0bwte2.jpg" alt="截屏2020-07-08 14.05.52" style="zoom:50%;" />

若不支持C++11，则手动实现to_string()

```
#include <string>
#include <sstream>  //记得写头文件
 
//这个函数直接复制即可

template <typename T>
std::string to_string(T value){
	std::ostringstream os ;
	os << value ;
	return os.str() ;
}
 
int main(){
	std::string perfect = to_string(5) ;
}
```





### 未知string数字长度转换数字

```
double getNumber(string s, int& index){//返回字符串当前下标到下一个空格间的数字 
	double ans=0;
	while(isdigit(s[index])){ 
		ans*=10;
		ans+=s[index]-'0';
		index++; 
	}
	return ans; 
}

```



### string与char[]互相转换

https://blog.csdn.net/OpenStack_/article/details/88692564?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.compare&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.compare

char[]转string的话一般直接赋值就行了

```
#include<iostream>
using namespace std;
 
int main()
{
	char a[]=" abc  d\0efg "; 	
	
	string s=a;  //直接赋值
	
	cout<<s;	
	return 0;
	
}

//输出 abc  d
```



### 数组初始化

https://blog.csdn.net/zhanshen112/article/details/84956950

（注，C++里也可以使用 int arr[长度]={0}; 进行便捷的初始化）

**只建议使用memset()的时候初始化为0或者-1**。menset()函数的功能性不如fill()函数，其优点在于执行速度更快。

fill()可以把数组和容器中的某一段区间赋值为某个相同的值。和memset()不同的是这里的赋值可以是数组类型对应范围中的任意值。





### 几个字符符号

空格 ' '

换行 '\n'

空字符 '\0'

回车符 '\r'

制表符 '\t'



### C++回车符和换行符

https://www.cnblogs.com/CPlusPlusZhangChi/p/3153260.html

换行符是在下一行输入输出，而回车符是擦除本行前面的所有内容，光标回到本行第一字符开始输出。

```
#include <iostream>
using std::cout;
using std::endl;
int main()
{
    cout<<"Hello"<<'\n'<<"World"<<endl;
    cout<<"Hello"<<'\r'<<"World"<<endl;
    system("pause");
    return 0;
}

//输出结果
//Hello
//World
//World
```



### <font color=red>KMP算法</font>

https://www.cnblogs.com/yjiyjige/p/3263858.html

关键是next[]的求法

<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg3575ybhuj315w0u0han.jpg" alt="next数组" style="zoom: 25%;" />	

举个例子：

| 下标j   | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    |
| ------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| j       | a    | b    | a    | a    | b    | c    | a    | b    | a    |
| next[j] | -1   | 0    | 0    | 1    | 1    | 2    | 0    | 1    | 2    |

next[j] = k表示，当第j位与主串失配（假设为i）时，换用第k位的字符与主串i进行尝试匹配。

再找一下规律，next[j] = k还表示，从当前j位往前数k个字符，与当前串的开头数k个字符是相同的，而k+1个就不同了。**即 保证 s[0 .. i-1] 中 s[i - next[i]  .. i-1] 与 s[0 .. next[i]-1] 是相同的**

**在计算本位j的next等于几时，和第j位的值没有关系！next[j]等于几取决于第j-1位的值是否匹配！ 所以例如pattern[4]==pattern[1]，决定的是next[5]=1+1=2**

C++代码：

```
#include <iostream>
#include <cstdio>
#include <string>
#define MAXN 10000
using namespace std;

int nextTable[MAXN];  //nextTable[j] = k 表示如果模版串第j位（与原串）不匹配时，拿模版串第k位和原串当前位置再比较

void getnextTable (string pattern){
    nextTable[0]=-1;//初始化
    int j=0;
    int k=-1;
    int len = pattern.length();
    while(j<len-1){//k在j的左边
        if(k==-1 || pattern[j]==pattern[k]){//如果当前位相等，则如果下一位不对时，新的j应该指向k==nextTable[j]
            k++;
            j++;
            nextTable[j]=k; 
        }
        else{//如果当前位不相等，再往前找是否有和当前位相等的，相当于缩小公共串的长度看看有没有可能
            k=nextTable[k];
        }
    }
    
    return;
}

int KMP(string text, string pattern){
    int i=0;//主串的位置
    int j=0;//模式串的位置
    //这里先赋值！！！！！否则 j==-1时与length()比较会出错
    int len1 = text.length();
    int len2 = pattern.length();
    
    while(i<len1 && j<len2){
        if(j==-1 || text[i]==pattern[j]){
            i++;
            j++;
        }
        else{
            j=nextTable[j];
        }
    }
    
    //返回的是主串第一个匹配的下标
    if(j==len2)
        return i-j;
    else return -1;
    
}

int main(){
    int num;
    string text;
    string pattern;
    while(getline(cin,text,'\n')){
        getline(cin,pattern,'\n');
        num=0;
        getnextTable(pattern);
        num=KMP(text,pattern);
        cout<<num<<endl;
    }
    return 0;
}

```



### 字符串去掉前面的0

需要\<algorithm>头文件

```
reverse(s.begin(),s.end());
while(s[0]=='0'){
s=s.substr(1);//截取s[1]到结尾
}
```

或者（我觉得下面的时间少）

```
int pos=0;
while(s[pos]=='0')
		pos++;
s=s.substr(pos);
```



### BKDRHash算法（字符串hash）

https://blog.csdn.net/wanglx_/article/details/40400693

```
#include <iostream>
 
unsigned int bkdr_hash(const char* key)
{
	char* str = const_cast<char*>(key);
			
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc.. 37
	unsigned int hash = 0;
	while (*str)
	{
		hash = hash * seed + (*str++);
	}
	return hash;
}
 
int main(int argc, char* argv[])
{
	std::cout << bkdr_hash("hijklmn")<<std::endl;
	std::cout << bkdr_hash("bhijklmn")<<std::endl;
	getchar();
	return 0;
}
```

这是我常用的写法（记得res的类型为long long比较保险）：

```
int BKDRHash(string s){
    long long res = 0;
    
    for(int i=0;i<s.length(); i++){
        res = res*seed + (s[i]-'0');
    }
    return (res & 0x7fffffff);
    
}
```



## 数据结构

### vector

**定义一个vector**

头文件#include \<vector>

vector\<typename> name;

**vector的状态**

empty() 返回是否为空；size()返回元素个数

**初始化二维vector**

例如

```
vector<vector<int>> vec(row, vector<int> (col,1));
```

**尾部添加或删除**

push_back()

pop_back()

**元素访问**

下标访问、迭代器访问。（和数组类似）

```
//迭代器访问例子：

vector::iterator it;
for(it = vec.begin(); it!=vec.end(); it++)
cout<<*it<<endl;
```

传回第一个数据

vec.front()  



**操作**

insert(), erase(), clear() 均和string中相应操作类似

------

翻转，需要头文件 #include\<algorithm>

**reverse(vec.begin(), vec.end())**

------

排序，需要头文件 #include\<algorithm>

sort(vec.begin(), vec.end());   默认是按升序排列，即从小到大

------

删除重复元素（或者直接用set存储）

    vector<int> a={1, 4, 4, 3, 2, 4, 2};
    sort(a.begin(), a.end());
    vector<int>::iterator it = unique(a.begin(), a.end());
    a.erase(it, a.end());
    
    //或者直接放一起
    sort(v.begin(),v.end());
    v.erase(unique(v.begin(), v.end()), v.end());


**其他**

vector可以插入pair类型的元素，例子见《刷题笔记》开门人和关门人



**<font color=red>vector的耗时比普通一位数组多！</font>**

如：https://www.nowcoder.com/practice/1f1db273eeb745c6ac83e91ff14d2ec9?tpId=61&tqId=29507&tPage=1&ru=%2Fkaoyan%2Fretest%2F1002&qru=%2Fta%2Fpku-kaoyan%2Fquestion-ranking

这个用向量会超时



vector比较时，如果需要对整个式子取非需要加括号

例如：

```
while(!(agency[i]==server[j]) && j<m)
```



### list





### queue

**定义queue**

头文件#include \<queue>

queue\<typename> name

**queue的状态**

empty() 返回是否为空；size()返回元素个数

**queue元素的添加或删除**

push(), pop()

**元素访问**

只能对队列的头尾两端进行操作，获得头尾两端元素的函数分别是 front()和back()



### 优先队列

能够将数据按照事先规定的优先级次序进行动态组织的数据结构称为 **优先队列**

**优先队列的定义**

头文件 #include \<quque>

priority_queue\<typename> name

**优先队列的状态**

返回当前优先队列是否为空 empty()

返回当前优先队列的元素个数 size()

**优先队列元素的添加或删除**

push(), pop()

**优先队列的元素访问**

只能通过top()访问当前队列中优先级最高的元素。



**优先队列默认是大顶堆，如果要改成小顶堆，需要这么声明：**

<font color=blue>**priority_queue<int, vector\<int>, greater\<int> > MyQueue;**</font>

<font color=red>上面的greater\<int>是一个系统的比较函数，也可以自己构造cmp函数</font>



**优先队列元素类型如果是结构体的话，需要自行重载运算符。**（比如刷题笔记里的“复数集合”）

例如，NC94 里定义 小顶堆 ((count, timestamp), key)。相当于把上面蓝字中的 int 都替换成 pair<pair<int, int>, int>

```
priority_queue<pair<pair<int, int>, int>, vector<pair<pair<int, int>, int>>, greater<pair<pair<int, int>, int>>> inq, deq;
```





### deque

https://blog.csdn.net/hnust_xiehonghao/article/details/8800007

deque双向队列是一种双向开口的连续线性空间，可以高效的在头尾两端插入和删除元素，deque在接口上和vector非常相似

**deque定义**

头文件 #include \<deque>

**返回数据**

c.at(idx)	传回索引idx所指的数据，如果idx越界，抛出out_of_range。

c.front()	传回地一个数据。

c.back()	传回最后一个数据，不检查这个数据是否存在。



**元素的添加删除**

c.pop_back()	删除最后一个数据。

c.pop_front()	删除头部数据。

c.push_back(elem)	在尾部加入一个数据。

c.push_front(elem)	在头部插入一个数据。

c.erase(pos)	删除pos位置的数据，传回下一个数据的位置。

c.erase(beg,end)	删除[beg,end)区间的数据，传回下一个数据的位置。





### stack

**定义stack**

头文件#include \<stack>

stack\<typename> name

**stack的状态**

empty() 返回是否为空；size()返回元素个数

**stack元素的添加或删除**

push(), pop()

**元素访问**

只能对栈的栈顶一端进行操作，所以只能用top()来访问栈顶元素



基本案例：逆序输出

```
#include <iostream>
#include <stack>
#include <cstdio>
using namespace std;

int main(){
    int n;
    while(cin>>n){
        stack<long long>num;//因为范围超过了int所能表示的
        long long x;
        for(int i=0; i<n; i++){
            cin>>x;
            num.push(x);
        }
        for(int i=0; i<n; i++){//这里的n不能写成num.size()，因为num.size()是会变化的
            if(i==0){
                cout<<num.top();
                num.pop();
            }
            else{
                cout<<" "<<num.top();
                num.pop();
            }
        }
        cout<<endl;
    }
    return 0;
}
```



### set

set是一个内部自动有序且不含重复元素的容器。

**插入元素**

insert()

**遍历**

```
for(auto it=s.begin();it!=s.end();it++)
    cout<<*it<<endl; //注意指针运算符
```

**访问元素**

find() 会返回一个和参数匹配的元素的迭代器。如果对象不在 set 中，会返回一个结束迭代器。

```
std::set<string> words {"one", "two","three", "four","five"};
auto iter = words.find ("one") ; // iter points to "one"
iter = words.find(string{"two"});   // iter points to "two"
iter = words.find ("six");   // iter is std:: end (words)
```







### map

map是一个将关键字（key）和映射值（value）形成一对映射后进行绑定存储的容器。map底层是用红黑树实现的，内部依然是有序的，其查找效率依然为O(nlogn)。标准库中还有一个无序映射unordered_map，其底层是用散列表实现的，其期望的查找效率为O(1)。

对于性能要求特别高时，只需将map改成unorder_map即可。

**map的定义**

头文件#include \<map>

一个映射map的写法是 map<typename T1, typename T2> name。 其中，typename T1时映射关键字的类型，typename T2是映射值的类型，name是映射的名字



**<font color=red>map的key别用结构体！！！！！！！！！！！！！因为你无法保证两个key是相同的！！！！！！！！！！！！！！！！！！！！！</font>**



**map的状态**

是否为空 empty()

当前映射元素个数 size()

**map元素的添加和删除**

insert(), erase()

例子：

```C++
myMap.insert(pair<string, int>("test", 1));
myMap.erase("test");
```

**map元素的访问**

- map内部重载了[]，可以通过[key]的方式访问

- 可以使用at()访问

  ```c
  print("the value of test: %d\n", myMap.at("test"));
  ```

- **可以通过迭代器进行访问**

  ```c++
  map<string, int>::iterator it;
  for(it = myMap.begin(); it!=myMap.end(); it++){
  		cout<<"the value of "<<it->first;
  		cout<<": "<< it->second<<endl;
  }
  ```

- 想要访问第k个元素（set也可以吧）

  ```
  auto it=mmap.begin();
  for(;it!=mmap.end()&&k!=1;++it,--k){} 
  cout << it->first << endl;
  ```

  



**map元素操作**

查找 find()：若找到则返回该元素的迭代器，若未找到则返回迭代器end()

清空 clear()

**map迭代器操作**

正向迭代：

​	首元素迭代器begin()

​	尾元素<font color=red>之后一个位置</font>的迭代器end()

反向迭代：

​	反向迭代的迭代器是**<font color=red>map<key, value>::reverse_iterator it;</font>**

​	 rbegin(), rend()

​	迭代器仍然是使用++

​	比如

```c++
for(it = map.rbegin(); it!= map.rend(); it++){//反向迭代
		somecode...
}
```

**map内部自动按key的字典序排序**

------

例子：参考笔记上的“玛雅人的秘密”

**元素查找、计数**

find(), count()

https://blog.csdn.net/woai233/article/details/79401117

```
#include<string>
#include<cstring>
#include<iostream>
#include<queue>
#include<map>
#include<algorithm>
using namespace std;
int main(){
    map<string,int> test;
    test.insert(make_pair("test1",1));//test["test1"]=1
    test.insert(make_pair("test2",2));//test["test2"]=2
    
    map<string,int>::iterator it;
    
    //寻找test0
    it=test.find("test0");
    cout<<"test0 find:";
    if(it==test.end()){
        cout<<"test0 not found"<<endl;
    }
    else{
        cout<<it->second<<endl;
    }
    //计数test0
    cout<<"test0 count:";
    cout<<test.count("test0")<<endl;
    cout<<endl;
    
    
    //寻找test1
    cout<<"test1 find:";
    it=test.find("test1");
    if(it==test.end()){
        cout<<"test1 not found"<<endl;
    }
    else{
        cout<<it->second<<endl;
    }
    //计数test1
    cout<<"test1 count:";
    cout<<test.count("test1")<<endl;
    cout<<endl;
    
    //寻找test2
    cout<<"test2 find:";
    it=test.find("test2");
    cout<<it->second<<endl;
    return 0;
}

```



### 二叉树

**二叉树的建立和遍历都要通过递归！！！不要使用栈！！**

节点定义：

```
struct TreeNode{
    ElementType data;
    TreeNode* leftChild;
    TreeNode* rightChild;
    //TreeNode(ElementType e): data(e), leftChild(NULL), rightChild(NULL){}
};
```

在下面的操作中用的都是指针！！！  即 TreeNode*

创建根结点：

（或者直接 TreeNode* root = NULL; 我觉得也挺好）

```
TreeNode* root = new TreeNode;
//如果是带有构造函数的则为 TreeNode* root = new TreeNode(指定数据);
```

**构建树：（这里只写根据 前序遍历 构建，其他的类似）**

```
TreeNode* CreateTree(){
    TreeNode *root = new TreeNode;
    if(插入空节点的条件){
        return NULL;
    }

    root->data = 插入值;
    root->leftChild=CreateTree();//构建左子树
    root->rightChild=CreateTree();//构建右子树
    return root;
}
```

**遍历树：（这里只写 中序遍历，其他的类似）**

二叉树的查找和遍历基本一样。

```
void InOrder(TreeNode* root){
    if(root==NULL)
        return;
    InOrder(root->leftChild);
    Visit(root->data);
    InOrder(root->rightChild);

    return;
}
```

**层次遍历：**

```
void LevelOrder(TreeNode* root){
    queue<TreeNode*>que;//使用队列
    if(root!=NULL)
        que.push(root);
    while(!que.empty()){
        TreeNode* current = que.front();
        que.pop();
        Visit(current->data);
        if(current->leftChild!=NULL)
            que.push(root->leftChild);
        if(current->rightChild!=NULL)
            que.push(root->rightChild);
    }
    return ;
}
```

**删除树：**（释放空间）

```
void deleteTree(TreeNode* root){//为了释放空间
    if(root==NULL)
        return;
    deleteTree(root->leftChild);
    root->leftChild=NULL;
    deleteTree(root->rightChild);
    root->rightChild=NULL;
    free(root);
}
```

对二叉排序树进行中序遍历，结果是一个升序序列





## 自实现数据结构

### 自定义cmp函数

对cmp函数进一步理解：**bool cmp(a, b)。若返回true，则a在b之前；若返回false，则b在a之前。**

所以函数内部你随便写，怎么运算都可以，只要满足上面的规则就行。

（例如 NC111，将多个字符串进行排列并拼接，每个数不可拆分，使得最后的结果最大。直接return s1+s2 > s2+s1即可）





### 手写Hash表

https://blog.csdn.net/qpswwww/article/details/40157839



### BKDRHash （字符串哈希、二维数组哈希也可）

https://www.cnblogs.com/zl1991/p/11820922.html

https://blog.csdn.net/wanglx_/article/details/40400693



### 临接表

https://blog.csdn.net/qq_33890670/article/details/82860562

好像有点错误，我在网页里画线了。

```
//建边
void addEdge(int u, int v){
    tot++;
    e[tot].v = v;
    e[tot].next = head[u];
    head[u] = tot;
}


//遍历
for(int i=head[u]; i!=0; i=e[i].next){
	cout<<i<<" "<<e[i].v<<endl;
}
```







## 数学问题

### 大数除法

#### 大数除以小型数（string, int）

（设除数为b）

首先设余数为0，

从字符串的**最左边开始**，当前字符-'0'得到该位代表的数字，将（该位数字+余数）/ 除数d，商作为该位的结果（可能为0），将模作为新的余数，然后转下一位。 最后把前面的0去掉就行。

<font color=red>大数除法并不改变结果的进制！</font>

```
//大数除以小型数（10以内）
string Divide(string str, int x){
    int remainder=0;
    for(int i=0; i<str.length(); i++){
        int current= str[i]-'0'+remainder*10;
        str[i]=current/x + '0';
        remainder = current %x;
    }
    //结果放在str中，可能首部会出现0
    int pos=0;
    while(str[pos]=='0')
        pos++;
    str=str.substr(pos);
    return str;  //如果最终结果是0，将会返回空串
    
    //其实最终的reminder也就是大数模小型数的结果
}
```



#### 大数除以小型数（vector, int）

注：输入vec为万进制**倒序**，输出ans为万进制**正序**！！！！

```
vector<int>divVec(vector<int>vec, int k){ //大数除法
    vector<int>ans;
    int temp = 0;
    int remainder = 0;
    for(int i = vec.size()-1; i>=0; i--){
        temp = remainder*RULE + vec[i];
        ans.push_back(temp/k);
        remainder = temp%k;
    }
    //这时候ans是正常顺序
    //去除前导0
    vector<int>::iterator it;
    for(it = ans.begin(); it != ans.end();){
        if(*it == 0)
            it = ans.erase(it);
        else break; //不为0了直接braek，开头的0已经全部删除了
    }
    if(ans.size()==0) //如果全删完了，补个0
        ans.push_back(0);

    return ans;
}
```



### 大数乘法

#### 万进制倒序存储

如 m = 123456789

——> 6789 2345 1

即vec[0] = 6789, vec[1] = 2345, vec[2] = 0



#### 字符串转万进制vector

```
int temp;
int start = 0;
if(str.length()-4>0)
    start = str.length()-4;

for(int i= start ; i>=0; i-=4){
    temp = std::stoi(str.substr(i, 4));
    s.push_back(temp);
    if(i-4<0){
    	if(i==0) break;  //前面已经没有数了
        temp = std::stoi(str.substr(0, i)); //不足4位直接取完剩下的
        s.push_back(temp);
    }
}
```



#### 大数乘小型数（vector, int）（使用vector输出）（常用）

https://blog.csdn.net/moonspiritacm/article/details/53884531

设初始输入为m

m不要太大，尽量不要超过RULE。

超过一点也没事，但保险起见，如果m太大，就从低到高按4位一组划分，依次放在vec[0], vec[1], ...中。

此外，int类型下，RULE最大设置为10^5。假设你使用int定义一个块，那么必须保证两个块的最大值相乘能够被一个int装起来，不会出现溢出。所以int可以装5位，如果6位和6位会超，可以选用64位整形存储。位数可达9位。

```
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <string>
#include <map>
#include <vector>
#include <cmath>
#include <stack>
#include <queue>
using namespace std;
const int MAXN = 10002;
const int RULE = 10000; //10000进制

vector<int> vecmul(vector<int>s, int k){ //大数乘法
    vector<int>ans;
    int extra = 0;
    int temp = 0;
    for(int i=0; i<s.size(); i++){
        temp = s[i]*k+extra;
        ans.push_back(temp%RULE);
        extra = temp/=RULE;
    }
    while(extra){//溢出进位
        ans.push_back(extra%RULE);
        extra/=RULE;
    }
    return ans;
}
// 注意输出的时候，如果不够3位需要在前面补0

```



#### 大数乘小型数（string, int）（适合一次性）（非万进制）

这里的s是正序！而不是倒序存储！

```
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <string>
#include <map>
#include <vector>
#include <cmath>
#include <stack>
#include <queue>
using namespace std;
const int MAXN = 10002;

vector<int> strmul(string s, int k){ //大数乘法
    vector<int>ans;
    int extra = 0;
    int temp = 0;
    for(int i=s.length()-1; i>=0; i--){
        temp = (s[i]-'0')*k+extra;
        ans.push_back(temp%10);
        extra = temp/=10;
        cout<<extra<<endl;
    }
    while(extra){//溢出进位
        ans.push_back(extra%10);
        extra/=10;
    }
    return ans;
}

int main(){
    vector<int>ans;
    string str = "1234567890123";
    ans = strmul(str, 12312152);
    for(int i=ans.size()-1; i>=0; i--){
        cout<<ans[i];
    }
    cout<<endl;
}

```



#### 大数乘小型数（vector\<int>, int）（十进制，内存消耗严重）

这里的s是正序！

```
vector<int> vecmul(vector<int>s, int k){ //大数乘法
    vector<int>ans;
    int extra = 0;
    int temp = 0;
    for(int i=s.size()-1; i>=0; i--){
        temp = s[i]*k+extra;
        ans.push_back(temp%10);
        extra = temp/=10;
    }
    while(extra){//溢出进位
        ans.push_back(extra%10);
        extra/=10;
    }
    reverse(ans.begin(), ans.end());
    return ans;
}
```



#### 大型数乘大型数（vector\<int>, vector\<int>）

与大型数乘单个数不一样，因为中间结果有值！需要考虑当前位。

ans需要先分配空间，再加当前位。

注意最后输出时要补0

> ```
> string temp;
> for(int i=ans.size()-1; i>=0; i--){
> 		temp = to_string(ans[i]);
> 		while(i!=ans.size()-1 && temp.size()<4)  // 除了最开头，其他的不够都要补0
> 				temp.insert(0, "0");
> 		res += temp;
> }
> ```



```
const int RULE = 10000;  // 万进制
vector<int> vecmul(vector<int>& vec1, vector<int>& vec2){
    vector<int>ans;
    int extra = 0;
    int temp = 0;
    int k;
    for(int i=0; i<vec2.size(); i++){  // vec2的每一位
        extra = 0;
        for(int j=0; j<vec1.size(); j++){
            while(ans.size()<i+j+1)  //防止越界
                ans.push_back(0);
            temp = vec2[i]*vec1[j] + extra + ans[i+j];  // 需要加当前位！
            ans[i+j] = temp%RULE;
            extra = temp/RULE;
        }
        k = vec1.size();  // k表示每轮至少需要的空间
        while(extra){
            while(ans.size()<i+k+1)
                ans.push_back(0);
            temp = extra + ans[i+k];
            ans[i+k] = temp%RULE;
            extra = temp/RULE;
            k++;
        }
    }
    return ans;
}
```





### 大数加法

#### 字符串版本

#### 向量版本

```
vector<int>addVec(vector<int>v1, vector<int>v2){
    vector<int>temp1(v1);
    vector<int>temp2(v2);
    vector<int>ans;
    //不要轻易用swap交换数组！！！老老实实自己补
    //vector在填充0的过程中size是不断增加的！！！！！！！！！！所以不要用temp2.size()-temp1.size()当作循环结束条件
    if(v1.size()<v2.size())
        while(temp1.size()<temp2.size())
            temp1.push_back(0);
    else if(v2.size()<v1.size())
        while(temp2.size()<temp1.size())
            temp2.push_back(0);
            
    int temp = 0;
    int extra = 0;
    for(int i=0; i<temp1.size(); i++){
        temp = temp1[i]+temp2[i]+extra;
        ans.push_back(temp%RULE);
        extra = temp/RULE;
    }
    while(extra){
        ans.push_back(extra%RULE);
        extra/=RULE;
    }
    return ans;
}
```



### 进制转换

#### 十进制转二进制（小型数）

**x%2是最低位的，x/2可让高数位向低数位移动。**
$$
x\%2=(b_0*2^0+b_1*2^1+b_2*2^2+...+b_n*2^n)\%2\\
x\%2=b_0
$$

$$
x/2=(b_0*2^0+b_1*2^1+b_2*2^2+...+b_n*2^n)/2\\
x/2=b_1*2^0+b_2*2^1+b_3*2^2+...+b_n*2^{n-1}
$$

不断进行求模和整除运算，便可依次求得被移动到最低数位的值；以此类推，便可得到所有数位上的值。

**<font color=red>反复模和除最后再倒序输出 是大转小的基本</font>**



向量版本：

```
#include <iostream>
#include <cstdio>
#include <vector>
using namespace std;

int main(){
    unsigned int n;
    while(cin>>n && n){
        vector<int> binary;
        while(n){
            binary.push_back(n%2);
            n/=2;
        }
        for(int i=binary.size()-1; i>=0; i--)  //倒着输出
            cout<<binary[i];
        cout<<endl;
    }
    return 0;
}
```



#### 十进制转二进制（大数）

vector是真的好用

```
#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
using namespace std;

//大数除小型数（10以内）
string Divide(string str, int x){
    int remainder=0;
    for(int i=0; i<str.length(); i++){
        int current= str[i]-'0'+remainder*10;
        str[i]=current/x + '0';
        remainder = current %x;
    }
    //结果放在str中，可能首部会出现0
    int pos=0;
    while(str[pos]=='0')
        pos++;
    str=str.substr(pos);
    return str;
    
    //其实最终的reminder也就是大数模小型数的结果，但是由于10进制直接可以用个位进行模，所以这里就只返回除数
}


int main(){
    string str;
    while(cin>>str){
        vector<int>binary;
        //本方法的原理还是基于反复模和除最后再倒序输出
        while(str.size()!=0){//str是十进制的！！！
            int last = str[str.size()-1]-'0';  //只要用最后一位模就行了
            binary.push_back(last%2);
            str = Divide(str,2);  //这里引入大数除法不是新方法！！！就仅仅是因为字符串没法直接除以2
        }
        for(int i=binary.size()-1; i>=0; i--)
            cout<<binary[i];
        cout<<endl;
    }
    return 0;
}

```



#### <font color=red>大数M进制转N进制</font>

 码住



#### 进制转换（以十六进制转十进制为例）

评论区大神的各种方法

https://www.nowcoder.com/questionTerminal/deb19498bc644f53a6a99905ef5ee01d

**法1:利用scanf**

https://blog.csdn.net/i_fuqiang/article/details/8262844

https://blog.csdn.net/u014647208/article/details/53337315

```
#include <stdio.h>
 
int main(void) {
    int num = 0;
    while (~scanf ("%x", &num))
        printf("%d\n",  num);
    return 0;
}

/* 错误输入指的就是没有输入的时候，scanf返回的是EOF（End Of File），EOF=-1，对EOF取非，就是对-1取非
 * [~是位运算，它是将数据在内存中的每一位（当然是二进制）取反。-1在内存中所有位全部为1，~(-1)=0,即对-1取非就是0]
 * 就会跳出循环。
 */
```

**法2:利用cin**

dec-十进制（默认）

oct-八进制

hex-十六进制

bin-二进制

```
#include <iostream>
using namespace std;
 
int main(){
     
    int n;
    while(cin>>hex>>n){
        cout<<dec<<n<<endl;
    }
     
    return 0;
}
```



#### （大数）进制转换（以十六进制转十进制为例）

如果不是大数的话很简单，只要int sum（再大可以用long long），然后不断加就行了

稍微修改一下可以实现任意进制转换

```
#include <iostream>
#include <cstdio>
#include <string>
#include <cstring>
#include <vector>
#include <algorithm>
using namespace std;

int char2int(char ch){
    if(ch>='0' && ch <='9')
        return ch-'0';
    else
        return ch-'A'+10;
}
char int2char(int x){
    if(x>=0 && x<=9)
        return x+'0';
    else
        return x-10+'A';
}

int main(){
    string str;
    while(cin>>str){
        vector<int>ans;
        int n=16;//当前进制
        int m=10;//目标进制
        str=str.substr(2);//去掉前面的0x两个字符
        while(str.size()!=0){       
        	//——————————求余数并作大数除法————————————————
        	//大数除法不改变字符串的进制！！！
        	//不放在外部函数是因为，这里需要用到商和余数，而外部函数无法同时返回两个变量
            int remain=0;
            for(int i=0; i<str.length(); i++){
                int current = char2int(str[i])+ remain*n;
                str[i] = int2char(current/ m);
                remain = current %m;
            }
            int pos=0;
            while(str[pos]=='0')
                pos++;
            str=str.substr(pos);
            ans.push_back(remain);
        	//——————————————————————————————————
        }
        for(int i=ans.size()-1; i>=0; i--){
            cout<<ans[i];
        }
        cout<<endl;
    }
    return 0;
}
```



#### **<font color=red>十六以内任意进制转换</font>**

http://t.cn/AiCu6ne4

原理仍然是模除循环，然后再倒序输出

```
#include <iostream>
#include <cstdio>
#include <string>
#include <cstring>
#include <vector>
#include <algorithm>
using namespace std;

int char2int(char ch){
    if(ch>='0' && ch <='9')
        return ch-'0';
    else if(ch>='A' && ch <='Z')
        return ch-'A'+10;
    else
        return ch-'a'+10;
}
char int2char(int x){
    if(x>=0 && x<=9)
        return x+'0';
    else
        return x-10+'A';
}

int main(){
    string str;
    int a,b;//原始进制，目标进制
    while(cin>>a>>str>>b){
        vector<char>ans;
        while(str.size()!=0){
        	//——————————求余数并作大数除法————————————————
        	//不放在外部函数是因为，这里需要用到商和余数，而外部函数无法同时返回两个变量
            int remain=0;
            for(int i=0; i<str.length(); i++){
                int current = char2int(str[i])+ remain*a;
                str[i] = int2char(current/ b);
                remain = current %b;
            }
            int pos=0;
            while(str[pos]=='0')
                pos++;
            str=str.substr(pos);
            ans.push_back(int2char(remain));
            //——————————————————————————————————
        }
        for(int i=ans.size()-1; i>=0; i--){
            cout<<ans[i];
        }
        cout<<endl;
    }
    return 0;
}
```



#### （大数）二进制string转十进制int并取模

有点快速幂的味道哦

front = (2*front)%k 是关键

```
int bin2del(string s, int k){//二进制字符串转十进制数 并取模
    int ans = 0;
    int front =1;
    for(int i=s.length()-1; i>=0; i--){
        if(s[i]=='1'){
            ans+=front;
            ans %=k;
        }
        front = (2*front)%k;
    }
    return ans;
}
```





### <font color=red>阶乘的质因数分解</font>

<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg3576n4nvj31040l077f.jpg" alt="10的质因数分解" style="zoom: 33%;" />	

**分析：**

10! = 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10

**以质因数2为例**

10/2=5 表示，10!的所有乘数中，有5个是2的倍数(2,4,5,8,10)，它们都拿出一个因数2出来，现在2的指数有5个。 

10/4=2表示，10!的所有乘数中，有能力再拿出一个因数2出来的有两个(4,8)，因为它们是4的倍数。现在2的指数为7个

10/8=1表示，10!的所有乘数中，有能力再拿出一个因数2出来的只有一个8，因为它是8的倍数，前两轮它已经拿出2*2了。 现在2的指数为8个。

**注：**

10/2=5, 10/4=2, 10/8=1

又可以写成

10/2=5, 5/2=2, 2/2=1

代码表示为：

```
while(n!=0){//例如prime[i]为2时
	pow+=n/prime[i];// pow=5,7,8,8
	n/=prime[i];//n=5,2,1,0
}
```

或许有更科学的解释，但是我这里就当成分子分母的约分

**算法如下：**

首先进行打表

```
bool isPrime[MAXN];
int num[MAXC];//用来存储素数，如果用vector会耗时一点
//如果不要求素数的个数，可以把和MAXC相关的去掉
 
void initial(int& cnt){
    //经评论区提醒这里bound应为double
    //如果是int，MAXN开根号可能会损失精度，在if(i>=bound)处直接跳过而少清理一个合数
    double bound = sqrt(MAXN);
    cnt=0;
    for(int i=0; i<MAXN; i++)
        isPrime[i]=true;
    isPrime[0]=false;
    isPrime[1]=true;
     
    for(int i=2; i<MAXN && cnt<MAXC; i++){//添加了cnt的条件
        if(!isPrime[i])
            continue;
        num[cnt]=i;
        cnt++;
        //***********防止越界**************
        if(i>=bound)
            continue; //我感觉break就行吧
        //********************************
        for(int j=i*i; j<MAXN; j+=i)
            isPrime[j]=false;
    }
        return ;
}

```

然后根据素数表计算

```
void getnFac(int n){
    for(int i=0;prime[i]<=n;i++){//对每一个质因数的指数进行计算
        int pow=0;
        int tempn=n;//例如n=10, i=0, prime[i]=2时
        while(n!=0){
            pow+=n/prime[i];// pow=5,7,8,8
            n/=prime[i];//n=5,2,1,0
        }
        nFac[prime[i]]=pow;//nFac[2]=8
        n=tempn;//还原n
    }
}
```



### 快速幂

#### 小型快速幂（非String）

任何一个数字n都可以分解为若干$2^k$之和，因此，可以先将指数b分解为若干 $2^k$的和。

如要求$3^{29}$，其指数b为29，而29 = 1+4+8+16。于是，分解的数字便是需要的3的次幂，即$3^1,3^4,3^8,3^{16}$。再将它们累乘便可得到结果。



而要将b分解为若干$2^k$。便是在求b的二进制数，**其二进制位为1的数位代表的权重便是分解的结果。**

所以在a不断增长的过程中，b为1时，乘到结果上；b为0时，不乘到结果上。然后再把b的二进制向右移动一个单位，即b/=2。

例如，29的二进制数 $11101 = 2^0+2^2+2^3+2^4$。

即$3^{29} = 3^1 * 3^4 * 3^8 * 3^{16}$，29的二进制为11101，从后向前第i位的乘数位$3^i$，如果该位为1，则乘上该乘数。

```
int FastE(int a, int b){
    int ans=1;
    while(b!=0){
        if(b%2==1)
            ans *=a;
        b/=2;//可以改成b>>=1
        a*=a;
    }
    return ans;
}
```



#### 小型快速幂（带模运算）（非string）

$a^b\% c$

```
int FastE(int a, int b, int c){
    int ans=1;
    while(b!=0){
        if(b%2==1){
            ans *=a;
            ans %=c;
        }
        b/=2;//可以改成b>>=1
        a*=a;
        a%=c; //乘数也应该取模
    }
    return ans;
}
```

例子：

http://t.cn/AipAw4B1



#### 中型快速幂（带模运算）（非string）

在小型快速幂中，随着a不断增大，<font color=fuchsia>**a在取模运算前可能超过int能表示的范围**</font>。这时a也必须用更大的存储。

到了$2^{64}$，long long也会溢出，但是double竟然不会，会显示科学计数法的结果。

```
long long fastE(long long a, int b, int c){
    long long ans =1;
    while(b!=0){
        if(b%2==1){
            ans *=a;
            ans%=c;
        }
        b/=2;
        a*=a;
        a%=c;
    }
//    cout<<ans<<endl;
    return ans;
}
```



#### 矩阵快速幂

和快速幂差不多，使用结构体

```
struct Matrix{
    int matrix[10][10];
    int row,col;
    Matrix(int r, int c): row(r),col(c){}
};
```

在快速幂时，一维情况下是ans=1，在矩阵中，ans应该初始化为单位矩阵。然后**乘法自己写个矩阵乘法的函数**。其他的都类似。

板子：

```
#include <iostream>
#include <cstdio>
using namespace std;
 
struct Matrix{
    int matrix[10][10];
    int row,col;
    Matrix(int r, int c): row(r),col(c){}
};
 
void printMatrix(Matrix x){
    for(int i=0; i<x.row; i++){
        for(int j=0; j<x.col; j++){
            if(j!=0)
                cout<<" ";
            cout<<x.matrix[i][j];
        }
        cout<<endl;
    }
    return ;
}
 
Matrix Multiply(Matrix x, Matrix y){
    Matrix ans(x.row, y.col);
    //矩阵一开始需要初始化！！！！！！！！！！！
    for(int i=0; i<ans.row; i++)
        for(int j=0; j<ans.col; j++){
            ans.matrix[i][j]=0;
            for(int k=0; k<x.col; k++)
                ans.matrix[i][j]+=x.matrix[i][k] * y.matrix[k][j];
        }
     
    return ans;
}
 
 
 
Matrix FastE(Matrix x, int k){
    Matrix ans(x.row, x.col);
    //初始化单位矩阵
    for(int i=0; i<ans.row; i++){
        for(int j=0; j<ans.col; j++){
            if(i==j)
                ans.matrix[i][j]=1;
            else
                ans.matrix[i][j]=0;
        }
    }
    while(k!=0){
        if(k%2==1){
            ans = Multiply(ans, x);
        }
        k/=2;
        x = Multiply(x,x);
    }
    return ans;
}
 
 
int main(){
    int n,k;
    while(cin>>n>>k){
        Matrix x(n,n);
        for(int i=0 ; i<n; i++)
            for(int j=0; j<n; j++)
                cin>>x.matrix[i][j];
//        printMatrix(x);
        Matrix ans = FastE(x,k);
        printMatrix(ans);
    }
    return 0;
}
```





### 模运算

https://blog.csdn.net/deaidai/article/details/76474018

- 编程竞赛有相当一部分题目的结果过于庞大，整数类型无法存储，往往只要求输出取模的结果。

- 例如(a+b)%p,若a+b的结果我们存储不了，再去取模，结果显然不对，我们为了防止溢出，可以先分别对a取模,b取模，再求和，输出的结果相同。

- a mod b表示a除以b的余数。有下面的公式：
  (a + b) % p = (a%p + b%p) %p
  (a - b) % p = ((a%p - b%p) + p) %p
  (a * b) % p = (a%p)*(b%p) %p
  注意对于除法取模，详见逆元。

  

### 数论

#### 扩展gcd

<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi1zllpcdpj30xe0u0aev.jpg" alt="image-20200824163546648" style="zoom:50%;" />

返回的是gcd(a, b)，设为d

注意x和y是带地址变换的。

结束后，满足ax+by = gcd(a, b)

若ax + by = c，且c是d的倍数，则通解为：

**x = (c/d)\*x0 + (b/d)\*t**

```
//扩展gcd
long long ex_gcd(long long a, long long b, long long &x, long long &y){
    long long d;
    if(!b){
        d = a;
        x = 1;
        y = 0;
        return d;
    }
    else{
        long long temp;
        d = ex_gcd(b, a%b, x, y);
        temp = x;
        x = y;
        y = temp - (a/b)*y;
        return d;
    }
}
```





<font color=red>**注意：模数p是必须有的，而且一定要是质数。推荐100...007。此外，如果p过小使得n,m的上限高于p，是不能用lucas定理的。（可能会在comb判断if(a<b)时return）**</font>

**如果p过小的话，数据也不大。可以直接杨辉三角。**

#### 小型C(a,b)%p

```
//快速乘（取模），有点东西
long long fastM(long long a,long long b,long long k){
    long long ans=0;
    while(b){
        if(b&1)
            ans=(ans+a)%k;
        a=(a<<1)%k; //这里相比于快速幂，a的更新换成了a = 2*a
        b>>=1;
    }
    return ans;
}

//快速幂
long long fastE(long long a,long long b,long long k){
    long long ans=1;
    while(b){
        if(b&1){
            ans=fastM(ans,a,k);
        }
        a=fastM(a,a,k);
        b>>=1;
    }
    return ans;
}

long long comb(long long a,long long b,long long p){ //小型C(a,b)
    if(a<b)
        return 0;
    if(a==b)
        return 1;
    if(b>a-b)
        b=a-b;
    
    long long ans=1,ca=1,cb=1;
    
    for(int i=0;i<b;i++){
        ca=ca*(a-i)%p;
        cb=cb*(b-i)%p;
    }
    /*
     ca = (a-b+1)* ... * a 即ca相当于a!与(a-b)!约分后的结果
     cb = b!
     求（ca/cb）mod p的值，且cb很大，无法直接求得ca/cb的值时，
     由费马小定理
     我们可以转而使用cb的乘法逆元k，将ca乘上k再模p，即(ca*k) mod p。
     其结果与(ca/cb) mod p等价
     而k = (cb)^(p-2) % p
     */
    ans=ca*fastE(cb,p-2,p)%p;
    return ans;
}
```



#### 卢卡斯定理求大型C(a,b)%p

```
//快速乘（取模），有点东西
long long fastM(long long a,long long b,long long k){
    long long ans=0;
    while(b){
        if(b&1)
            ans=(ans+a)%k;
        a=(a<<1)%k; //这里相比于快速幂，a的更新换成了a = 2*a
        b>>=1;
    }
    return ans;
}

//快速幂
long long fastE(long long a,long long b,long long k){
    long long ans=1;
    while(b){
        if(b&1){
            ans=fastM(ans,a,k);
        }
        a=fastM(a,a,k);
        b>>=1;
    }
    return ans;
}

long long comb(long long a,long long b,long long p){ //小型C(a,b)
    if(a<b)
        return 0;
    if(a==b)
        return 1;
    if(b>a-b)
        b=a-b;
    
    long long ans=1,ca=1,cb=1;
    
    for(int i=0;i<b;i++){
        ca=ca*(a-i)%p;
        cb=cb*(b-i)%p;
    }
    /*
     ca = (a-b+1)* ... * a 即ca相当于a!与(a-b)!约分后的结果
     cb = b!
     求（ca/cb）mod p的值，且cb很大，无法直接求得ca/cb的值时，
     我们可以转而使用cb的乘法逆元k，将ca乘上k再模p，即(ca*k) mod p。
     其结果与(ca/cb) mod p等价
     而k = (cb)^(p-2) % p
     */
    ans=ca*fastE(cb,p-2,p)%p;
    return ans;
}

long long lucas(long long a,long long b,long long p){
    long long ans=1;
    while(a&&b){
        ans=(ans*comb(a%p,b%p,p))%p;
        a/=p;
        b/=p;
    }
    return ans;
}
```



## 优化方法

### 滚动数组

动态规划压缩空间

https://blog.csdn.net/mrcrack/article/details/103693242?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-5.compare&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-5.compare



例子：参考HDU笔记中的 HDU 1024

相比于笔记中被注释掉的代码，这里将空间m\*n优化为2\*n，但是并没有解决超时，所以没有AC

http://acm.hdu.edu.cn/viewcode.php?rid=33545638





## 离散化

https://blog.csdn.net/qq_40774175/article/details/80343164



### lower_bound( )和upper_bound( )

lower_bound( begin,end,num)：从数组的**begin位置到end-1**位置二分查找<font color=red>**第一个**</font><font color=blue>**大于或等于**</font>num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。

upper_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个<font color=fuchsia>**大于**</font>num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。

https://blog.csdn.net/sinat_36215255/article/details/68946399

例如，在HDU 3333中，数组a为1 1 2 1 3，复制到tmp中（从下标1开始），并且进行排序。

此时tmp[1~5]为 1 1 1 2 3 

```
int index = lower_bound(tmp+1, tmp+1+n, a[i]) - (tmp);
```

要注意减去的是数组的起始地址！无论你从哪开始放入元素。

对于数组a[i]，得到的index分别为 1 1 4 1 5





## 写法

### 结构体构造函数

例子：

```
struct node{
    int data;
    string str;
    char x;
    //注意构造函数最后这里没有分号哦！
  node() :x(), str(), data(){} //无参数的构造函数数组初始化时调用
  node(int a, string b, char c) :data(a), str(b), x(c){}//有参构造
}N[10];
```



### 字典序全排列 next_permutation(a,a+n)

```
函数声明：#include  <algorithm>

bool next_permutation( iterator start, iterator end);


next_permutation()函数功能是输出全部比当前排列大的排列。顺序是从小到大。
prev_permutation()函数功能是输出全部比当前排列小的排列，顺序是从大到小。
```

以HDU 1027为例，输出字典序第m小的数

```
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;

const int MAXI = 9;
const int MAXN = 1005;
const int MAXM = 10001;
int a[MAXN];

int main(){
    int n,m;
    while(cin>>n>>m){
        for(int i=0; i<n; i++)
            a[i] = i+1;
        m--;  //因为切换到第m小，需要m-1次
        while(m--){
            next_permutation(a,a+n);
        }
        for(int i=0;i<n;i++){
            if(i==0)
                printf("%d",a[i]);
            else printf(" %d",a[i]);
        }
        printf("\n");
        
    }
    return 0;
}

```



## 其他

INF建议用0x03fffffff而不是0x7fffffff



（根据经验）判断两个区间[l1, r1] [l2, r2]相交是：r1>l2 && l1<r2



关键路径等于最长路径。



<font color=red>**下降子序列的个数等于最长 上升 子序列的长度。**</font>

**不上升子序列的个数等于最长上升（严格）子序列的长度**。反过来也一样。

无论是求最长上升（严格）子序列的长度，还是最长不下降子序列的长度，都可以用lower_bound(begin, end, x)进行二分查找，第一个不小于x的值进行替换。



二分图 最小覆盖点数==最大匹配数

