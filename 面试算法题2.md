[TOC]

注：⚠️表示有更好的方法没有补充。 ⚡️表示需要加强记忆

<font color=fuchisa>粉色</font>：起码我一开始想不到/做不出来

<font color=red>红色</font>：较难

<font color=orange>橙色</font>：稍微难

<font color=purple>紫色</font>：技巧





## 二叉树

### NC45 实现二叉树先序，中序和后序遍历

https://www.nowcoder.com/practice/a9fec6c46a684ad5a3abd4e365a9d362?tpId=117&&tqId=37819&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking

```
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 * };
 */
#include <vector>
class Solution {
public:
    /**
     * 
     * @param root TreeNode类 the root of binary tree
     * @return int整型vector<vector<>>
     */
    vector<vector<int>>res;
    vector<int>temp;
    
    void preOrder(TreeNode* root){
        if(root==nullptr)
            return;
        temp.push_back(root->val);
        preOrder(root->left);
        preOrder(root->right);
        return ;
    }
    void inOrder(TreeNode* root){
        if(root==nullptr)
            return;
        
        inOrder(root->left);
        temp.push_back(root->val);
        inOrder(root->right);
        return ;
    }
    void postOrder(TreeNode* root){
        if(root==nullptr)
            return;
        
        postOrder(root->left);
        postOrder(root->right);
        temp.push_back(root->val);
        return ;
    }
    
    
    vector<vector<int> > threeOrders(TreeNode* root) {
        res.clear();
        temp.clear();
        preOrder(root);
        res.push_back(temp);
        
        temp.clear();
        inOrder(root);
        res.push_back(temp);
        
        temp.clear();
        postOrder(root);
        res.push_back(temp);

        return res;
    }
};
```



### <font color=dodgerblue>NC13 二叉树的最大深度</font>

BFS。

注意自定义的结构体，关于节点存的是指针。

```
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param root TreeNode类 
     * @return int整型
     */
    struct node{
        int level;
        TreeNode* ptr;
        node(){}
        node(int l, TreeNode* ptr): level(l), ptr(ptr){}
    };
    
    int maxDepth(TreeNode* root) {
        if(root==nullptr) return 0;
        int maxD = 0;
        queue<node>q;
        q.push(node(1, root));
        
        node temp;
        while(!q.empty()){
            temp = q.front();
            q.pop();
            
            if(temp.ptr->left)
                q.push(node(temp.level+1, temp.ptr->left));
            if(temp.ptr->right)
                q.push(node(temp.level+1, temp.ptr->right));
        }
        return temp.level;  // 只要取最后一个节点的level就行
        
    }
};
```



优化：

```
class Solution {
public:
    int maxDepth(TreeNode* root) {
        queue<TreeNode*> q;
        if(!root) return 0;
        q.push(root);

        int depth = 0;
        int levelSize = 0;
        while(!q.empty()){
            depth++;
            levelSize = q.size();
            for(int i=0; i<levelSize; i++){
                auto node = q.front(); q.pop();
                if(node->left) q.push(node->left);
                if(node->right) q.push(node->right);
            }
        }
        return depth;
    }
};
```



### NC15 求二叉树的层序遍历

BFS队列

结构体 存储节点指针以及层数。

每次超过当前最大层，push该层结果，然后清空。

注意！队列为空时退出了while，但还有一层结果记得push

```
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param root TreeNode类 
     * @return int整型vector<vector<>>
     */
    struct node{
        TreeNode* ptr;
        int level;
        node(TreeNode* p, int l): ptr(p), level(l){}
    };
    
    vector<vector<int> > levelOrder(TreeNode* root) {
        vector<vector<int>>res;
        if(root==nullptr){
            return res;
        }
        vector<int>temp;  // 用来存储一层
        queue<node>q;
        q.push(node(root, 0));
        int maxLevel = 0;  // 当前最大层
        int val;
        int level;
        while(!q.empty()){
            node point = q.front();
            q.pop();
            
            val = point.ptr->val;
            level = point.level;
            
//             printf("%d %d\n", val, level);
            
            if(level>maxLevel){  // 保存上一层结果，清空
                maxLevel = level;
                res.push_back(temp);
                temp.clear();
            }
            temp.push_back(val);
            
            if(point.ptr->left!=nullptr){
                q.push(node(point.ptr->left, level+1));
            }
            if(point.ptr->right!=nullptr){
                q.push(node(point.ptr->right, level+1));
            }
        }
        res.push_back(temp);  // 由于最后队列空了，最后一个temp没存
        return res;
    
    }
};
```



【推荐】优化！

https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/solutions/1398801/cong-shang-dao-xia-da-yin-er-cha-shu-ii-fzejw/

普通广度优先搜索每次只取一个元素拓展，而下面过程中的第 i 次迭代就得到了二叉树的第 i 层的所有元素。

```
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        if(root == NULL) return res;

        queue<TreeNode*>q;
        q.push(root);
        while(!q.empty()){
            int levelSize = q.size();
            res.push_back(vector<int>{});
            // 把当前层的放入结果，并把下一层的一次性push进去
            for(int i=0; i<levelSize; i++){
                auto node = q.front(); q.pop();
                res.back().push_back(node->val);
                if (node->left) q.push(node->left);
                if (node->right) q.push(node->right);
            }
        }
        return res;
    }
};
```





### NC14 按之字形顺序打印二叉树

<font color=red>**推荐解法二**</font>

NC 15 的进阶。

注意在循环中每次 level > maxLevel 时，temp就变成了上一层的结果。

跳出循环后，temp表示最后一层的结果，即level层。

```
/*
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }
    
};
*/
class Solution {
public:
    struct node{
        TreeNode* ptr;
        int level;
        node(TreeNode* p, int l): ptr(p), level(l){}
    };
    vector<vector<int> > Print(TreeNode* pRoot) {
        vector<vector<int>>res;
        if(pRoot==nullptr)
            return res;
        
        vector<int>temp;  // 用来存储一层
        queue<node>q;
        q.push(node(pRoot, 0));
        int maxLevel = 0;  // 当前最大层
        int val;
        int level;
        while(!q.empty()){
            node point = q.front();
            q.pop();
            
            val = point.ptr->val;
            level = point.level;
            
            if(level>maxLevel){  // 保存上一层结果，清空
                maxLevel = level;
                if(level & 1)  // temp 是上一层结果！所以如果当前level是奇，则上一层不用翻转
                    res.push_back(temp);
                else{
                    reverse(temp.begin(), temp.end());
                    res.push_back(temp);
                }
                temp.clear();
            }
            temp.push_back(val);
            
            if(point.ptr->left!=nullptr){
                q.push(node(point.ptr->left, level+1));
            }
            if(point.ptr->right!=nullptr){
                q.push(node(point.ptr->right, level+1));
            }
        }
        // 最后一层还没有输出
        if((level+1) & 1)  // 这里temp就是当前层结果了。
            res.push_back(temp);
        else{
            reverse(temp.begin(), temp.end());
            res.push_back(temp);
        }
        return res;
    }
    
};
```



解法二：

```
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        if(root == NULL) return res;

        queue<TreeNode*>q;
        q.push(root);
        bool odd = true;
        while(!q.empty()){
            int levelSize = q.size();
            res.push_back(vector<int>{});
            // 把当前层的放入结果，并把下一层的一次性push进去
            for(int i=0; i<levelSize; i++){
                auto node = q.front(); q.pop();
                res.back().push_back(node->val);
                if (node->left) q.push(node->left);
                if (node->right) q.push(node->right);
            }
            if(!odd)
                reverse(res.back().begin(), res.back().end());
            odd = !odd;
        }
        return res;
    }
};
```



### 剑指 Offer 27. 二叉树的镜像

```
class Solution {
public:
    TreeNode* mirrorTree(TreeNode* root) {
        if(root == NULL) return root;

        mirrorTree(root->left);
        mirrorTree(root->right);
        TreeNode *node  = root->left;
        root->left = root->right;
        root->right = node;
        return root;
    }
};
```



### <font color=purple>剑指 Offer 28. 对称的二叉树</font>

如果一个树的左子树与右子树镜像对称，那么这个树是对称的。

因此，该问题可以转化为：两个树在什么情况下互为镜像？

如果同时满足下面的条件，两个树互为镜像：

- 它们的两个根结点具有相同的值
- **每个树的右子树都与另一个树的左子树镜像对称。**

我们可以实现这样一个递归函数，通过「同步移动」两个指针的方法来遍历这棵树，p 指针和 q 指针一开始都指向这棵树的根，随后 p 右移时，q 左移，p 左移时，q 右移。每次检查当前 p 和 q 节点的值是否相等，如果相等再判断左右子树是否对称。



```
class Solution {
public:

    bool check(TreeNode* a, TreeNode* b){
        if(!a && !b) return true;
        if(!a || !b) return false;

        return (a->val == b->val) && check(a->left, b->right) && check(a->right, b->left);
    }

    bool isSymmetric(TreeNode* root) {
        return check(root, root);
    }
};
```





### ⚡️<font color=orange>NC6 二叉树最大路径和</font>

https://www.nowcoder.com/practice/da785ea0f64b442488c125b441a4ba4a?tpId=196&tqId=37050&rp=1&ru=/exam/oj&qru=/exam/oj&sourceUrl=%2Fexam%2Foj%3Ftab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D196%26page%3D1&difficulty=undefined&judgeStatus=undefined&tags=&title=

https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/

maxGain 返回的是 单子树的最大和，最大路径和是这个过程中用全局变量更新的！

```
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param root TreeNode类 
     * @return int整型
     */
    int MAX_SUM = -1001;  // 即使全是负数，最小也不会小于-1001
    
    int maxGain(TreeNode* node){
        if(node==nullptr){
            return 0;
        }
        // 左右子树能给该节点的贡献值
        // 与0比较是因为，如果子树反而提供负贡献，就直接抛弃
        int left_gain = max(maxGain(node->left), 0);
        int right_gain = max(maxGain(node->right), 0);
        
        int cur_sum = node->val + left_gain + right_gain;  // 当前路径和
        MAX_SUM = max(MAX_SUM, cur_sum);
        return node->val + max(left_gain, right_gain);  // 每次只能选择一颗子树
    }
    int maxPathSum(TreeNode* root) {
        maxGain(root);
        return MAX_SUM;
    }
};
```



### ⚡️<font color=red>NC102 在二叉树中找到两个节点的最近公共祖先</font>

> ⚠️如果有一个节点不存在，甚至两个节点都不存在的情况下，怎么处理？
>
> 个人思路：if(node->val == o1 || node->val == o2) 时，做个标记，例如count++，或者直接记录当前val。最后判断 count 是否为2



方法一：递归

设问题为`LCA(root, o1, o2)`, 该问题有以下递归性质：

- 如果o1和o2都在root的左子树中，那么`LCA(root, o1, o2) = LCA(root->left, o1, o2)`.
- 如果o1和o2都在root的右子树中，那么`LCA(root, o1, o2) = LCA(root->right, o1, o2)`.
- 如果一个在左子树，一个在右子树，显然root就是答案



```
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param root TreeNode类 
     * @param o1 int整型 
     * @param o2 int整型 
     * @return int整型
     */
    TreeNode* LCA(TreeNode* node, int o1, int o2){
        if(node==nullptr)
            return nullptr;
        // 如果至少包含一个节点，那么直接返回自己
        if(node->val == o1 || node->val == o2)
            return node;
        // 查找左右子树。注意lnode, rnode不代表左右节点。而是左右子树里的公共祖先（最近的）
        TreeNode *lnode, *rnode;
        lnode = LCA(node->left, o1, o2);
        rnode = LCA(node->right, o1, o2);
        
        if(lnode==nullptr)  // 如果左子树里没找到，那两个节点肯定都在右子树里
            return rnode;
        if(rnode==nullptr)
            return lnode;
        // 如果左子树右子树都包含目标节点，那公共祖先就是自己
        return node;
        
    }
    
    int lowestCommonAncestor(TreeNode* root, int o1, int o2) {
        TreeNode* node = LCA(root, o1, o2);
        return node->val;
    }
};
```



方法二：dfs

把从根节点到o1, o2的路径打印出来。

逐个比较，如果出现不一样的，就是这个不一样的父节点

如果都一样，返回短的最后一个节点。

```
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param root TreeNode类 
     * @param o1 int整型 
     * @param o2 int整型 
     * @return int整型
     */
    vector<int>vec1;
    vector<int>vec2;
    
    bool dfs(TreeNode* node, vector<int>& vec, int target){
        if(node->val == target)
            return true;
        
        if(node->left!=nullptr){
            vec.push_back(node->left->val);
            if(dfs(node->left, vec, target))
                return true;
            vec.pop_back();
        }
        if(node->right!=nullptr){
            vec.push_back(node->right->val);
            if(dfs(node->right, vec, target))
                return true;
            vec.pop_back();
        }
        return false;
    }
    
    int lowestCommonAncestor(TreeNode* root, int o1, int o2) {
        vec1.clear();
        vec2.clear();
        vec1.push_back(root->val);
        vec2.push_back(root->val);
        dfs(root, vec1, o1);
        dfs(root, vec2, o2);
        
        int len = min(vec1.size(), vec2.size());
        for(int i=0; i<len; i++){
            if(vec1[i]==vec2[i])
                continue;
            else return vec1[i-1];  // 如果不相等，则是父节点
        }
        // 能执行到这里说明短的vec包含在长的里
        return vec1[len-1];
    }
};
```



### NC12 重建二叉树

平平无奇重建二叉树

```
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    
    TreeNode* createTree(vector<int>& pre, vector<int>& vin, int prel, int prer, int vinl, int vinr){
        if(prel>prer)
            return nullptr;
        if(prel==prer)  // 只有一个节点
            return new TreeNode(pre[prel]);
        
        TreeNode* root = new TreeNode(pre[prel]);
        // 在vin的 [vinl, vinr]中找到root所在的位置
        int index;
        for(int i=vinl; i<=vinr; i++){
            if(vin[i]==root->val){
                index = i;
                break;
            }
        }
        int left_num = index-vinl;
        int right_num = vinr-index;
        
        root->left = createTree(pre, vin, prel+1, prel+left_num, vinl, index-1);
        root->right = createTree(pre, vin, prer-right_num+1, prer, index+1, vinr);
        
        return root;
    }
    
    
    TreeNode* reConstructBinaryTree(vector<int> pre,vector<int> vin) {
        return createTree(pre, vin, 0, pre.size()-1, 0, vin.size()-1);
    }
};
```



### NC136 输出二叉树的右视图

根据前序+中序重建二叉树，层序遍历。

```
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 求二叉树的右视图
     * @param preOrder int整型vector 先序遍历
     * @param inOrder int整型vector 中序遍历
     * @return int整型vector
     */

    TreeNode* create(vector<int>& preOrder, vector<int>& inOrder, int preL, int preR, int inL, int inR){
        if(preL > preR) return nullptr;
        if(preL == preR) return new TreeNode(preOrder[preL]);

        int index;
        auto root = new TreeNode(preOrder[preL]);
        for(int i=inL; i<=inR; i++){
            if(inOrder[i] == root->val){
                index = i;
                break;
            }
        }
        int leftNum = index - inL;
        int rightNum = inR - index;

        root->left = create(preOrder, inOrder, preL+1, preL+leftNum, inL, index-1);
        root->right = create(preOrder, inOrder, preR-rightNum+1, preR, index+1, inR);

        return root;
    }     
    vector<int> solve(vector<int>& preOrder, vector<int>& inOrder) {
        int len = preOrder.size();
        auto root = create(preOrder, inOrder, 0, len-1, 0, len-1);

        vector<int>res;

        queue<TreeNode*> q;
        q.push(root);
        while(!q.empty()){
            int levelSize = q.size();
            for(int i=0; i<levelSize; i++){
                auto node = q.front(); q.pop();
                if(i==levelSize-1){  // 该层最后一个
                    res.push_back(node->val);
                }
                if(node->left) q.push(node->left);
                if(node->right) q.push(node->right);
            }
        }
        return res;
    }
};
```







### ⚡️<font color=purple>NC62 判断是不是平衡二叉树</font>

递归！！注意看题。

平衡二叉树（Balanced Binary Tree），具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，**并且左右两个子树都是一棵平衡二叉树**。

```
class Solution {
public:
    
    int dfs(TreeNode* node, int curL){
        if(node==nullptr)
            return curL;
        
        int ll = dfs(node->left, curL+1);
        int rl = dfs(node->right, curL+1);
        
        return max(ll, rl);
    }
    
    bool IsBalanced_Solution(TreeNode* pRoot) {
        if(pRoot==nullptr)
            return true;
        int leftL = dfs(pRoot->left, 0);
        int rightL = dfs(pRoot->right, 0);
        
//         printf("%d %d", leftL, rightL);
        
        if(abs(leftL - rightL)<=1 && IsBalanced_Solution(pRoot->left) && IsBalanced_Solution(pRoot->right))
            return true;
        else return false;
    }
};
```

官方题解：

```
class Solution {
public:
    int height(TreeNode* root) {
        if (root == NULL) {
            return 0;
        } else {
            return max(height(root->left), height(root->right)) + 1;
        }
    }

    bool isBalanced(TreeNode* root) {
        if (root == NULL) {
            return true;
        } else {
            return abs(height(root->left) - height(root->right)) <= 1 && isBalanced(root->left) && isBalanced(root->right);
        }
    }
};

```





### ⚡️[lc]<font color=orange>二叉树求和路径</font>

给定一棵二叉树，其中每个节点都含有一个整数数值(该值或正或负)。设计一个算法，打印节点数值总和等于某个给定值的所有路径的数量。注意，**路径不一定非得从二叉树的根节点或叶节点开始或结束**，但是其方向必须向下(只能从父节点指向子节点方向)。

https://leetcode-cn.com/problems/paths-with-sum-lcci/

思路就是把所有节点都当作根节点，即每个节点都使用一次dfs函数

dfs函数这里不用额外一个参数维护从起始节点到当前节点的节点值总和，而是**直接修改sum**,也可以达到相同的效果,

如果sum==0，则是一个有效答案,ans++

而在主函数中递归调用自己,保证所有节点都能使用到dfs函数

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int ans;
    void dfs(TreeNode *root,int sum){
        if(root==NULL)
            return ;
        sum-=root->val;
        if(sum==0)
            ans++; // 不能直接return，因为可能有节点为0
            
        dfs(root->left,sum);
        dfs(root->right,sum);
        return;
    }
    int pathSum(TreeNode* root, int sum) {
        if(root==NULL)
            return 0;
        dfs(root,sum);
        pathSum(root->left,sum);
        pathSum(root->right,sum);
        return ans;
    }
};
```





### NC5 二叉树根节点到叶子节点的所有路径和

简单dfs。

但是注意，统计的时刻应该是到达叶子结点（left == nullptr && right == nullptr），而不是当前节点为空时。

```
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param root TreeNode类 
     * @return int整型
     */
    int sum = 0;
    
    void dfs(TreeNode* node, string cur){
        string temp = cur;  // 不可能有空节点进入dfs
        temp.push_back(node->val+'0');
        
        // 注意，只有左右子树都为空的时候才算叶子结点
        if(node->left == nullptr && node->right == nullptr){
            sum += stoi(temp);
            return ;
        }

        if(node->left){
            dfs(node->left, temp);
        }
        if(node->right){
            dfs(node->right, temp);
        }

    }
    
    int sumNumbers(TreeNode* root) {
        if(root==nullptr)
            return 0;
        else{
            dfs(root, "");
            return sum;
        }
    }
};
```



### NC8 二叉树中和为某一值的路径(二)

平平无奇DFS

```
/**
 * struct TreeNode {
 *  int val;
 *  struct TreeNode *left;
 *  struct TreeNode *right;
 *  TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 * };
 */
class Solution {
  public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     *
     * @param root TreeNode类
     * @param target int整型
     * @return int整型vector<vector<>>
     */
    vector<vector<int>> res;
    vector<int>temp;

    void dfs(TreeNode* node, int target) {
        target -= node->val;
        if (target == 0) {
            if (!node->left && !node->right) { // 只有叶子结点才能retrun
                res.push_back(temp);
                return ;
            }
        }

        if (node->left) {
            temp.push_back(node->left->val);
            dfs(node->left, target);
            temp.pop_back();
        }
        if (node->right) {
            temp.push_back(node->right->val);
            dfs(node->right, target);
            temp.pop_back();
        }
    }

    vector<vector<int> > FindPath(TreeNode* root, int target) {
        if (root == nullptr)
            return res;
        temp.push_back(root->val);
        dfs(root, target);

        return res;
    }
};
```



### NC9 二叉树中和为某一值的路径(一)

NC8 你都会，这比它更简略。

```
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param root TreeNode类 
     * @param sum int整型 
     * @return bool布尔型
     */
    bool dfs(TreeNode* node, int expectNumber){
        if(expectNumber == node->val){
            if(!node->left && !node->right){  // 只有叶子结点才能retrun
                return true;
            }
        }
        
        expectNumber -= node->val;
        
        if(node->left){
            if(dfs(node->left, expectNumber))
                return true;
        }
        if(node->right){
            if(dfs(node->right, expectNumber))
                return true;;
        }
        return false;
    }
    
    bool hasPathSum(TreeNode* root, int sum) {
        if(root==nullptr)
            return false;
        return dfs(root, sum);
    }
};
```



### NC98 判断t1树中是否有与t2树完全相同的子树

递归。

两个函数，一个isContains，一个isEqual

因为树中的值是两两不同的，所以在isContains里，如果root1->val不等于root2->val，就继续递归root1的左右子树，只要左右子树有一个contains就行，所以是return (isContains(root1->left, root2) || isContains(root1->right, root2));

在isContains的递归里，如果遇到root1->val == root2->val （此root1和上一行的root1意义不一定一样），则必须检查root1的所有结构和root2是否相同。此时该调用isEqual。return isEqual(node1->left, node2->left) && isEqual(node1->right, node2->right);

```
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param root1 TreeNode类 
     * @param root2 TreeNode类 
     * @return bool布尔型
     */
    
    bool isEqual(TreeNode* node1, TreeNode* node2){
        if(node1==nullptr && node2==nullptr) return true;
        if(node1==nullptr || node2==nullptr) return false;
        
        // 到这里说明node1和node2都有值
        if(node1->val != node2->val)
            return false;
        return isEqual(node1->left, node2->left) && isEqual(node1->right, node2->right);
    }
    
    bool isContains(TreeNode* root1, TreeNode* root2) {
        if(root1 == nullptr) return false;
        if(root1->val == root2->val){  // 如果相等了，必须左右子树全部相等
            return (isEqual(root1->left, root2->left) && isEqual(root1->right, root2->right));
        }
        
        return (isContains(root1->left, root2) || isContains(root1->right, root2));
    }
};
```



### 🔥⚡️<font color=dodgerblue>NC60 判断一棵二叉树是否为搜索二叉树和完全二叉树</font>

判断一棵二叉树是否为「二叉搜索树」的通用方法为：对该二叉树进行中序遍历，若遍历结果为「严格」单调递增的，则是一棵二叉搜索树，否则不是。

判断一棵树是否为「完全二叉树」的方式为：对其进行层次遍历，若遇到一个空结点，则其后面的结点必须全为空结点，否则不是完全二叉树。在这里改变了一下实现，**如果有缺少左儿子或者右儿子，但是该节点有儿子（不是叶子结点），返回false。 如果二叉树节点有右儿子但是没有左儿子，直接返回false）**

```
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param root TreeNode类 the root
     * @return bool布尔型vector
     */
    vector<int>vec;
    void inOrder(TreeNode* node){
        if(node==nullptr)
            return ;
        inOrder(node->left);
        vec.push_back(node->val);
        inOrder(node->right);
    }
    
    vector<bool> judgeIt(TreeNode* root) {
        bool res1, res2;
        inOrder(root);
        res1 = true;
        if(vec.size()<=1) res1 = true;
        else{
            for(int i=0; i<vec.size()-1; i++){
//                 printf("%d ", vec[i]);
                if(vec[i]>=vec[i+1]){
                    res1 = false;
                    break;
                }
            }
        }
        
        res2 = true;
        
        queue<TreeNode*>q;
        if(root)
            q.push(root);
        TreeNode* temp;
        int flag = 0;
        // 完全二叉树在遇到空节点之后剩余的应当全是空节点
        while(!q.empty()){
            temp = q.front();
            q.pop();
            
            // 如果flag为1，且存在节点左右子树不为空，则false
            if(flag && (temp->left || temp->right)){
                res2 = false;
                break;
            }
            // 左右子树有一个为空
            if(temp->left == nullptr || temp->right == nullptr){
                if(temp->right){  // 只有左子树为空，一定不是
                    res2 = false;
                    break;
                }
                else{
                    flag = 1;  // 只有右子树为空，或者两个子树都为空
                    if(temp->left) q.push(temp->left);
                    continue;
                }
            }
            
            // 到这里说明左右子树都不为空
            q.push(temp->left);
            q.push(temp->right);
            
        }
        return vector<bool>{res1, res2};
    }
};
```



### ⚡️<font color=red>剑指 Offer 36. 二叉搜索树与双向链表</font>

https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/

输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。

<img src="https://pic.leetcode-cn.com/1599401091-PKIjds-Picture1.png" alt="Picture1.png" style="zoom:50%;" />



思路：中序遍历应该能意识到，但是中序遍历怎么应用呢？

中序遍历：

```
inOrder(cur->left)
visit(cur)
inOrder(cur->right)
```

即，遍历完 cur->left 节点后就轮到了 cur。那我们可以考虑在 inOrder(cur->left) 这一步保存一个最近比 cur 小的节点（用指针记录，例如 pre）。

看极端情况，最左下角的节点（例如上图中的 node1），它在遍历完之后就轮到了node 2。此时 pre 就应该指向node1，cur指向node2。（即 在 inOrder(node1) 的结束时应该 pre = node1，即pre = cur。

然后到了 visit(node2) 时， 直接 pre(node1) 和 cur(node2) 相互指向就行。然后再更新 pre = cur(node2)，于是在 inOrder(node3)时也会有 直接 pre(node2) 和 cur(node3) 相互指向，并更新 pre = cur(node3)...  遍历完后，相当于 inOrder(node2)已结束，cur = node4，此时pre正好是 node3，即最近的比 node4小的节点。

然后是循环问题，从上面的步骤可以知道，只有当 visit(node1)时，pre是空的，并且此时正好是最小节点。所以可以用全局指针 head 来指向 cur(node1)。

最最后，所有节点都中序遍历完。head指向最小节点，pre是最大节点。一连接就行了。

```
class Solution {
public:
    Node* pre, *head;

    void inOrder(Node* cur){
        if(!cur) return ;

        inOrder(cur->left);
        // 对于本节点
        if(!pre){  // 当且仅当到达左下角最小节点时 pre 才为空
            head = cur;
            cur->left = pre;
        }
        else{  // 其他情况，pre就是最近的一个比cur小的节点
            cur->left = pre;
            pre->right = cur;
        }
        pre = cur;

        inOrder(cur->right);
    }

    Node* treeToDoublyList(Node* root) {
        if(!root) return NULL;
        pre = NULL;
        inOrder(root);
        head->left = pre;  // 最小节点指向最大节点的指针
        pre->right = head;

        return head;
    }
};
```



## 动态规划

### NC68 跳台阶

简单斐波那契。

注意空间复杂度为 O(1)，所以要开常数空间。

dp[i%3] = dp[(i-1)%3] + dp[(i-2)%3]

```
class Solution {
public:
    int jumpFloor(int number) {
        int dp[3];
        
        dp[1] = 1;
        dp[2] = 2;
        if(number<3)
            return dp[number];
        
        for(int i=3; i<=number; i++){
            dp[i%3] = dp[(i-1)%3] + dp[(i-2)%3];
        }
        return dp[number%3];
    }
};
```



### ⚠️NC65 斐波那契数列

O(n)解法和上一题一样。

```
class Solution {
public:
    int Fibonacci(int n) {
        if(n<=2) return 1;
        int dp[3];
        dp[1] = 1;
        dp[2] = 1;
        for(int i=3; i<=n; i++){
            dp[i%3] = dp[(i-1)%3] + dp[(i-2)%3];
        }
        return dp[n%3];
    }
};
```

O(logn)解法：

矩阵快速幂

https://www.cnblogs.com/simplc/p/6742928.html





### NC19 连续子数组的最大和

开常数空间。

dp[i%2] = max(dp[(i-1)%2], 0) + array[i]

```
class Solution {
public:
    int FindGreatestSumOfSubArray(vector<int> array) {
        int n = array.size();
        if(n==1){
            return array[0];
        }
        
        int dp[2];
        dp[0] = array[0];
        
        int max_sum = dp[0];
        for(int i=1; i<n; i++){
            dp[i%2] = max(dp[(i-1)%2], 0) + array[i];
            max_sum = max(max_sum, dp[i%2]);
        }
        return max_sum;
    }
};
```





### <font color=dodgerblue>最长公共子序列（LCS）</font>

https://leetcode-cn.com/problems/longest-common-subsequence/

```
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int m = text1.length();
        int n = text2.length();
        int dp[m+1][n+1];
        memset(dp, 0, sizeof(dp));

        text1.insert(0, " ");
        text2.insert(0, " ");

        for(int i=1; i<=m; i++){
            for(int j=1; j<=n; j++){
                if(text1[i] == text2[j])
                    dp[i][j] = dp[i-1][j-1] + 1;
                else{
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
                }
            }
        }
        return dp[m][n];
    }
};
```



### NC92 最长公共子序列(二)

最长公共子序列+输出此序列。

复原时从后往前。

```
class Solution {
public:
    /**
     * longest common subsequence
     * @param s1 string字符串 the string
     * @param s2 string字符串 the string
     * @return string字符串
     */
    string LCS(string s1, string s2) {
        string res;
        s1.insert(0, " ");
        s2.insert(0, " ");
        
        int dp[s1.length()+1][s2.length()+1];
        
        for(int j=0; j<s2.length(); j++)
            dp[0][j] = 0;
        for(int i=0; i<s1.length(); i++)
            dp[i][0] = 0;
        
        int maxx = -1;
        for(int i=1; i<s1.length(); i++){
            for(int j=1; j<s2.length(); j++){
                if(s1[i]==s2[j]){
                    dp[i][j] = dp[i-1][j-1]+1;
                }
                else{
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
                }
                maxx = max(maxx, dp[i][j]);
            }
        }
        if(maxx<=0)
            return "-1";
        
        // 复原
        for(int i=s1.length()-1, j=s2.length()-1; i>=1 && j>=1; ){
            if(s1[i]==s2[j]){
                res.push_back(s1[i]);
                i--; j--;
            }
            else{
                if(dp[i][j]==dp[i-1][j]){
                    i--;
                }
                else j--;
            }
        }
        reverse(res.begin(), res.end());
        return res;
    }
};
```



### <font color=orange>NC127 最长公共子串</font>

dp\[i][j] 表示**以 str1\[i] 和 str2\[j] 结尾的**最长公共子串的长度

```

class Solution {
  public:
    /**
     * longest common substring
     * @param str1 string字符串 the string
     * @param str2 string字符串 the string
     * @return string字符串
     */
    string LCS(string str1, string str2) {
        str1.insert(0, " ");
        str2.insert(0, " ");

        int len1 = str1.length();
        int len2 = str2.length();
        int dp[len1][len2];
        memset(dp, 0, sizeof(dp));

        int maxx = 0;
        int start = 0;
        string res;
        for (int i = 1; i < len1; i++) {
            for (int j = 1; j < len2; j++) {
                if (str1[i] == str2[j]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                    if (maxx < dp[i][j]) {
                        maxx = dp[i][j];
                        start = i - dp[i][j] + 1;
                    }
                }
                // else dp[i][j] = 0;
            }
        }

        res = str1.substr(start, maxx);
        return res;
    }
};
```





### ⚡️<font color=red>NC 91 最长上升子序列(三)</font>

HDU 5748 的加工！https://vjudge.net/problem/HDU-5748

select 和 level 的数组求解方式一样，但是这一题要求字典序最小，所以应当从后向前放入结果。

level以到自己为止最长上升子序列的长度作为元素。level[i]表示到自己为止的最长上升序列的长度。

select 并不是结果！

例如 输入 [2,1,5,3,6,4,8,9,7]，得到select [1, 3, 4, 7, 9], level [1, 1, 2, 2, 3, 3, 4, 5, 4]。select只是用来计算level用的，且select的长度就是最长上升子序列的长度。

得到level后，逆序放入。

>lower_bound 算法返回一个非递减序列[first, last)中的第一个大于等于值val的位置
>
>upper_bound 算法返回一个非递减序列[first, last)中第一个大于val的位置

```
class Solution {
public:
    /**
     * retrun the longest increasing subsequence
     * @param arr int整型vector the array
     * @return int整型vector
     */
    
    vector<int> LIS(vector<int>& arr) {
        vector<int>select;  // 最长临时序列，不是输出！！！
        vector<int>level(arr.size());  // level[i]表示到自己为止的最长上升序列的长度

        
        for(int i=0; i<arr.size(); i++){
            if(i==0 || arr[i]>select[select.size()-1]){
                select.push_back(arr[i]);
                level[i] = select.size();
            }
            else{
                // 找出第一个大于等于arr[i]的位置
                int index = lower_bound(select.begin(), select.end(), arr[i])-select.begin();
                select[index] = arr[i];
                level[i] = index+1;
            }
        }
        // select的长度就是最长上升子序列的长度
        vector<int>res(select.size());
        // 从原始数组中逆序放入
        for(int i=arr.size()-1, j=select.size(); i>=0; i--){
            if(level[i]==j){
                res[--j] = arr[i];
            }
        }
        return res;
    }
};
```





### <font color=red>Almost Increasing Subsequence 几乎上升子序列</font>

https://codeforces.com/contest/1818/problem/C

贪心+dp

贪心就是，遇到 ≥3 个连续下降的字符，就删除中间的几个，只保留两头。

例如：

5, 4, 3 需要删除 4；

5, 4, 3, 2 需要删除 4, 3

所以对于 a\[i\] 要检查左右两边 if(a[i-1] >= a[i] && a[i] >= a[i+1])，判断该位是不是应该被删除。

dp[i] 表示以 i 为结尾删除的元素个数。

所以最后的答案应该是 **len - 被删除的元素个数**。

对于 [l, r]，由于 r+1 不在范围内，所以 r 肯定不会被删除，应该看它的前一位 dp[r-1]；至于为什么是 dp[l]，假如在完整字符串里 l 是要被删除的，虽然 l-1 并没有在范围内，但是 dp[r-1] 已经默认把 l 被删除算进去了，所以左边界应该把自己也算进去做抵消。即  (dp[r-1] - dp[l])

```
#include <iostream>
#include <vector>
#include <algorithm>
#include <cstring>

using namespace std;

int main(){
    int n, m;
    while(cin>>n>>m){
        int a[n+1];
        int dp[n+1];  // 边界
        memset(dp, 0, sizeof(dp));
        for(int i=1; i<=n; i++){
            scanf("%d", &a[i]);
        }

        // 如果出现题目说的x，y，z序列，那么只要删去y就行。
        // 如果是连续的 w, x, y, z, ，就比如说是5 4 4 3，那么仍然是删去中间的两个。
        for(int i=2; i<=n-1; i++){
            if(a[i-1] >= a[i] && a[i] >= a[i+1]){
                dp[i] = dp[i-1] + 1;
            }
            else dp[i] = dp[i-1];
        }

        int l, r;
        for(int i = 0;i <m; i++){
            cin>>l >> r;
            int len = r-l+1;
            if(len <=2){
                cout<<len<<endl;
            }
            else{
                cout << len - (dp[r-1] - dp[l]) << endl;
            }
        }
    }

}
```





### <font color=purple>NC128 接雨水问题</font>

[lc]42.接雨水 https://leetcode.cn/problems/trapping-rain-water/

我觉得是上升（非严格）子序列和下降子序列问题。但我直接用的模拟。

![截屏2023-02-09 15.00.47](https://raw.githubusercontent.com/Lenvia/md-pic/master/uPic/%E6%88%AA%E5%B1%8F2023-02-09%2015.00.47.png)

例如，输入[3,1,2,<font color=red>5</font>,2,4]  

填满雨水后变成 [3, 3, 3, <font color=red>5</font>, 4, 4]

所以只要找到最大值，最大值左边都非下降，右边的非上升。

```
if(arr[i]<arr[i-1]){  // 左边
  res += (arr[i-1]-arr[i]);
  arr[i] = arr[i-1];
}

....

if(arr[i]<arr[i+1]){  // 右边
	res += (arr[i+1]-arr[i]);
	arr[i] = arr[i+1];
}
```

注意答案要用long long

法一：

```
class Solution {
public:
    /**
     * max water
     * @param arr int整型vector the array
     * @return long长整型
     */
    long long maxWater(vector<int>& arr) {
        if(arr.size()<=1) return 0;
        long long maxx, pos;
        maxx = -1; pos = -1;
        // 找最大值和所在的位置
        for(int i=0; i<arr.size(); i++){
            if(arr[i]>maxx){
                maxx = arr[i];
                pos = i;
            }
        }
        long long res = 0;
        // 在pos左边应该是上升（非下降）子序列，右边是下降（非上升）子序列
        for(int i=1; i<pos; i++){
            if(arr[i]<arr[i-1]){
                res += (arr[i-1]-arr[i]);
                arr[i] = arr[i-1];
            }
        }
        for(int i=arr.size()-2; i>pos; i--){
            if(arr[i]<arr[i+1]){
                res += (arr[i+1]-arr[i]);
                arr[i] = arr[i+1];
            }
        }
        return res;
    }
};
```

法二：动态规划

<img src="https://cdn.jsdelivr.net/gh/Lenvia/md-pic@master/uPic/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f65366339643234656c7931683338386c6f643573376a3231393230676f74636a2e6a7067-20230504203835000.jpeg" alt="img" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Lenvia/md-pic@master/uPic/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f65366339643234656c7931683338386d677538396c6a3231357130706b676e732e6a7067.jpeg" alt="img" style="zoom:50%;" />

```
class Solution {
public:
    int trap(vector<int>& height) {
        int n = height.size();
        if(n==0) return 0;

        int left[n];
        int right[n];

        left[0] = height[0];
        right[n-1] = height[n-1];

        for(int i=1; i<n; i++){
            left[i] = max(left[i-1], height[i]);
        }
        for(int i=n-2; i>=0; i--){
            right[i] = max(right[i+1], height[i]);
        }

        int ans = 0;
        for(int i=0; i<n; i++){
            ans += min(left[i], right[i]) - height[i];
        }
        return ans;
    }
};
```



法三：双指针

不断向内移动较小的指针。

```
class Solution {
public:
    int trap(vector<int>& height) {
        int res = 0;
        int l = 0;
        int r = height.size()-1;

        while(l<r){
            if(height[l] < height[r]){
                l++;
                if(height[l-1]-height[l] > 0){
                    res += (height[l-1] - height[l]);
                    height[l] = height[l-1];  // 填充
                }                
            }
            else{
                r--;
                if(height[r+1]-height[r] > 0){
                    res += (height[r+1] - height[r]);
                    height[r] = height[r+1];
                }  
            }
        }
        return res;
    }
};
```







### NC7 买卖股票的最好时机(一)

> 你可以买入一次股票和卖出一次股票，并非每天都可以买入或卖出一次，总共只能买入和卖出一次，且买入必须在卖出的前面的某一天

其实用不着dp，直接暴力就行。。

方法一：dp

dp[i] 表示一定在i位置卖出。（如果前面没有买入，即dp[i]=0，可以当作在i买了又卖了）

例如，输入 [8,9,2,5,4,7,1]

计算得dp[1] = 1，说明在9时卖出可以得1。如果后面的数字大于9，那直接加上差值，没问题。

但如果后面的数字小于当前，比如9后面的2。先计算 dp[i-1] + prices[i] - prices[i-1]，看看仍然在原来的位置买入，在当前点卖出亏不亏。如果不亏，ok那还有利润可以留着；如果亏了，那不在原来的位置买入了，就在自己这里买。所以 dp[i] = max(0, dp[i-1] + prices[i] - prices[i-1]);

```
class Solution {
public:
    /**
     * 
     * @param prices int整型vector 
     * @return int整型
     */
    int maxProfit(vector<int>& prices) {
        if(prices.size()<2) return 0;
        
        int maxx = 0;
        int dp[prices.size()];
        memset(dp, 0, sizeof(dp));
        
        for(int i=1; i<prices.size(); i++){
            if(prices[i]>=prices[i-1]){
                dp[i] = dp[i-1] + prices[i] - prices[i-1];
            }
            else{
                dp[i] = max(0, dp[i-1] + prices[i] - prices[i-1]);
            }
            maxx = max(maxx, dp[i]);
        }
        return maxx;
    }
};
```



方法二：常规

每天计算当天能获得的最大利润，更新截止当天的最低价。

```
class Solution {
public:
    /**
     * 
     * @param prices int整型vector 
     * @return int整型
     */
    int maxProfit(vector<int>& prices) {
        if(prices.size()<2) return 0;
        
        int minx = 0x3ffffff;
        int res = -1;
        
        for(int i=0; i<prices.size(); i++){
            minx = min(minx, prices[i]);
            res = max(res, prices[i]-minx);
        }
        return res;
    }
};
```





### ⚡️<font color=fuchsia>NC35 编辑距离(二)</font>

最短编辑距离。

给定两个字符串str1和str2，再给定三个整数ic，dc和rc，分别代表插入、删除和替换一个字符的代价，请输出将str1编辑成str2的最小代价。

动态规划。**dp\[i]\[j] 表示 原始串str1\[0:i-1] 编辑成 str2\[0: j-1] 的代价**。这里我对str1和str2前面insert了一个空格，处理一下边界。

所以变成了 dp\[i]\[j] 表示 str1\[0:i] 编辑成 str2\[0: j] 的代价。 就是说，不管你怎么操作，操作完之后只剩下str1的 i+1之后的字符 和str2的 j+1之后的字符。不能把str1的i或str2的j留到后面。

<img src="https://cdn.jsdelivr.net/gh/Lenvia/md-pic@master/uPic/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f3030386933736b4e6c7931677a63653566376c78366a3331396d30726b6a766a2e6a7067.jpeg" alt="截屏2022-02-14 01.20.38" style="zoom:50%;" />

解释一下 str1[i] != str2[j] 时的情况：

- 插入str2[j]: （图中 <font color=deepskyblue>j</font> 的位置写错了，应该在i后面）
  - 既然插入一个j和str2的j位置对齐了，那i咋办？肯定是要放在前面和j-1对齐了。所以是 dp\[i]\[j-1] + ic
- 删除str1[i]：
  - 第i位对不齐是吧，爷不要了。让str2[j] 去和 i的前一位对齐去。就是 dp\[i-1]\[j] + dc
- 替换，显然。



```
class Solution {
public:
    /**
     * min edit cost
     * @param str1 string字符串 the string
     * @param str2 string字符串 the string
     * @param ic int整型 insert cost
     * @param dc int整型 delete cost
     * @param rc int整型 replace cost
     * @return int整型
     */
    int minEditCost(string str1, string str2, int ic, int dc, int rc) {
        int dp[str1.size()+1][str2.size()+1];  // dp[i][j] 表示str1[0:i] 变成 str2[0:j]的最小编辑距离
        memset(dp, 0, sizeof(dp));
        
        for(int i=0; i<str1.size()+1; i++) dp[i][0] = dc*i;  // 只能删除
        for(int j=0; j<str2.size()+1; j++) dp[0][j] = ic*j;  // 只能插入
        
        // 边界
        str1.insert(0, " ");
        str2.insert(0, " ");
        
        for(int i=1; i<str1.size(); i++){
            for(int j=1; j<str2.size(); j++){
                if(str1[i]==str2[j]){
                    dp[i][j] = dp[i-1][j-1];
                }
                else{
                    dp[i][j] = min(min(dp[i][j-1]+ic, dp[i-1][j]+dc), dp[i-1][j-1] + rc);
                }
            }
        }
        return dp[str1.size()-1][str2.size()-1];
    }
};
```



可以看到只利用了本层和上一层。

那再使用滚动数组优化。注意！dp\[i%2][0] 是不同的。所以需要放在循环里初始化。

```
class Solution {
public:
    /**
     * min edit cost
     * @param str1 string字符串 the string
     * @param str2 string字符串 the string
     * @param ic int整型 insert cost
     * @param dc int整型 delete cost
     * @param rc int整型 replace cost
     * @return int整型
     */
    int minEditCost(string str1, string str2, int ic, int dc, int rc) {
        int dp[2][str2.size()+1];  // dp[i%2][j] 表示str1[0:i] 变成 str2[0:j]的最小编辑距离
        memset(dp, 0, sizeof(dp));
        
        // dp[i][0]等会在循环里初始化
        for(int j=0; j<str2.size()+1; j++) dp[0][j] = ic*j;  // 只能插入
        
        // 边界
        str1.insert(0, " ");
        str2.insert(0, " ");
        
        for(int i=1; i<str1.size(); i++){
            dp[i%2][0] = dc*i;
            for(int j=1; j<str2.size(); j++){
                if(str1[i]==str2[j]){
                    dp[i%2][j] = dp[(i-1)%2][j-1];
                }
                else{
                    dp[i%2][j] = min(min(dp[i%2][j-1]+ic, dp[(i-1)%2][j]+dc), dp[(i-1)%2][j-1] + rc);
                }
            }
        }
        return dp[(str1.size()-1)%2][str2.size()-1];
    }
};
```



### NC59 矩阵的最小路径和

动态规划水题，滚动数组优化。

注意边界的初始化！

```
class Solution {
public:
    /**
     * 
     * @param matrix int整型vector<vector<>> the matrix
     * @return int整型
     */
    int minPathSum(vector<vector<int> >& matrix) {
        if(matrix.empty() || matrix[0].empty())
            return 0;
        vector<vector<int>>dp(2, vector<int>(matrix[0].size(), 0));
        
        dp[0][0] = matrix[0][0];
        for(int j=1; j<matrix[0].size(); j++){
            dp[0][j] = dp[0][j-1] + matrix[0][j];
        }
        
        for(int i=1; i<matrix.size(); i++){
            dp[i%2][0] = dp[(i-1)%2][0] + matrix[i][0];  // 只能从上边来
            for(int j=1; j<matrix[0].size(); j++){
                dp[i%2][j] = min(dp[(i-1)%2][j], dp[i%2][j-1]) + matrix[i][j];
            }
        }
        return dp[(matrix.size()-1)%2][matrix[0].size()-1];
    }
};
```



### NC34 求路径

水题动态规划。m*n方格

常规方法就不写全了，

```
dp[i%2][j] = dp[(i-1)%2][j] + dp[i%2][j-1];
```

时间复杂度O(mn)，空间复杂度O(mn)，滚动数组优化后也仍然有O(n)

组合数学法：

由于在矩阵中没有障碍物，从左上角移动到右下角一共要移动m+n-2次，其中有m-1次向下，n-1次向右，对这两种操作进行组合。因此最后就是求$C_{m+n-2}^{m-1}$

时间复杂度O(min(m, n))，空间复杂度O(1)

```
int uniquePaths(int m, int n) {
    long long ret = 1;
    for (int x = n, y = 1; y < m; ++x, ++y) {
        //组合公式的循环求解
        ret = ret * x / y;
    }
    return ret;
}
```



### ⚡️<font color=red>NC83 连续子数组的最大乘积</font>

本来我一开始想的是和连续子数组的和差不多，但是乘法的话，有负数和0。

特别是负数。

参考了题解，**当前位置的最大乘积，只来源于三种情况：只有自己、前一位的最大值与自己相乘**（比如和前一位最大值同号时）、前一位的最小值与自己相乘（比如和前一位最小值同号，和最大值异号）。

然后因为只使用前一位的，就不用开数组了，直接用pre进行循环更新前一位的信息。

```
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param nums int整型vector 
     * @return int整型
     */
    int maxProduct(vector<int>& nums) {
        if(nums.size()==1) return nums[0];
        
        int cur_max, cur_min, pre_max, pre_min;
        pre_max = nums[0]; pre_min = nums[0];
        int res = nums[0];
        
        for(int i=1; i<nums.size(); i++){
            // 反正一共只有三个选择
            cur_max = max(nums[i], max(pre_max*nums[i], pre_min*nums[i]));
            cur_min = min(nums[i], min(pre_max*nums[i], pre_min*nums[i]));
            res = max(res, cur_max);
            pre_max = cur_max;
            pre_min = cur_min;
        }
        
        return res;
        
    }
};
```



### 🔥⚡️<font color=fuchsia>NC135 买卖股票的最好时机(三)</font>

状态定义：第一维表示交易天数，第二维表示交易次数，第三维表示是否持有股票状态（分未持有股票和持有股票两种）。

初始化：

> 首先dp\[0]\[k]\[0] = 0; 第0天无论进行多少次交易，只要不持有就是0
> dp\[0]\[k]\[1] = -prices[0];  第0天无论进行多少次交易，持有就是-price[0]
> 那对于 dp\[i]\[0]\[0] 和 dp\[i]\[0]\[1] 呢？
> 首先，不会有任何k>0的状态需要 dp\[i]\[0]\[1]，所以dp\[i]\[0]\[1]可随机初始化，比如设为0
> 对于dp\[i]\[0]\[0]，不就是一直没操作嘛，那肯定就是0了



状态转移：

当某一天第k次交易，并处于未持有股票状态时，其最大值，要么是之前某一天第k次交易未持有股票状态的最大值，要么是之前某一天持有股票状态卖出当天的股票，即 $dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);$

当某一天第k次交易，并处于持有股票状态时，其最大值，要么是之前某一天第k次交易持有股票状态的最大值，要么是之前某一天第k-1次交易未持有股票状态买入当天的股票（不能同时持有两只股票），即$dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);$



```
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 两次交易所能获得的最大收益
     * @param prices int整型vector 股票每一天的价格
     * @return int整型
     */
    int maxProfit(vector<int>& prices) {
        if(prices.size()<=1) return 0;
        
        int len = prices.size();
        int maxk = 2;
        int dp[len][maxk+1][2];  // dp[i][k][0] 表示第i天，第k次交易，不持有股票的收益；
        memset(dp, 0, sizeof(dp));
				// 初始化
        // 首先dp[0][k][0] = 0; 第0天无论进行多少次交易，只要不持有就是0
        // dp[0][k][1] = -prices[0];  第0天无论进行多少次交易，持有就是-price[0]
        // 那对于 dp[i][0][0] 和 dp[i][0][1] 呢？
        // 首先，不会有任何k>0的状态需要 dp[i][0][1]，所以dp[i][0][1]可随机初始化，比如设为0
        // 对于dp[i][0][0]，不就是一直没操作嘛，那肯定就是0了
        
        for(int i=0; i<len; i++){
            for(int k=1; k<=maxk; k++){
                if(i==0){
                    dp[i][k][0] = 0;  // 第0天无论进行多少次交易，只要不持有就是0
                    dp[i][k][1] = -prices[i];
                }
                else{
                    dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);
                    dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);
                }
                
            }
        }
        return dp[len-1][2][0];
    }
};
```





### ⚡️<font color=fuchsia>NC49 最长的括号子串</font>

动态规划难题。

我本来想的是枚举长度l ，每次 +=2，这样的话，每次只要考虑它上一层的三种情况，结果段错误。

标准解法是 **dp[i] 表示以第i结尾的最长合格长度（i的字符必须用上）**

那么只要考虑i-1位的两种情况就可以动态规划了。

```
class Solution {
public:
    /**
     * 
     * @param s string字符串 
     * @return int整型
     */
    int longestValidParentheses(string s) {
        int n = s.length();
        if(n<2) return 0;
        
        int dp[n];  // dp[i] 表示以第i结尾的最长合格长度（i的字符必须用上）
        memset(dp, 0, sizeof(dp));
        int ans = 0;
        
        for(int i=1; i<n; i++){
            if(s[i]==')'){  //  必须是 ')'
                if(s[i-1] == '('){  // 可以和它前一位的直接匹配
                    dp[i] = dp[i-2] + 2;
                }
                else{  // s[i-1] == ')'
                    // 这时候字符串必须是 xxx ( ( .... ) )，注：内括号可能没有，即长度为0
                    // 右边的两层括号一定是全匹配的，所以内层括号的长度就是 dp[i-1]
                    if(i-dp[i-1]-1 >=0 && s[i-dp[i-1]-1] == '('){  // 首先保证最外层括号匹配
                        // xxx的右边界就是 i-dp[i-1]-2
                        dp[i] = dp[i-1] + 2;
                        int r = i-dp[i-1]-2;
                        if(r>=0)
                            dp[i] += dp[r];
                    }
                    
                }
                ans = max(ans, dp[i]);
            }
        }
        return ans;
    }
};
```



方法二：栈

参考[官方题解](https://leetcode.cn/problems/longest-valid-parentheses/solutions/314683/zui-chang-you-xiao-gua-hao-by-leetcode-solution/)

始终保持栈底元素为当前已经遍历过的元素中「最后一个没有被匹配的右括号的下标」，这样的做法主要是考虑了边界条件的处理，栈里其他元素维护左括号的下标：

- 对于遇到的每个 '(' ，我们将它的下标放入栈中
- 对于遇到的每个 ')' ，我们先弹出栈顶元素表示匹配了当前右括号：
  - 如果栈为空，说明当前的右括号为没有被匹配的右括号，我们将其下标放入栈中来更新我们之前提到的「最后一个没有被匹配的右括号的下标」
  - 如果栈不为空，当前右括号的下标减去栈顶元素即为「以该右括号为结尾的最长有效括号的长度」



我进一步分析一下：

当遇到一个右括号时，栈只会有以下三种情况：

1. 栈顶为-1
2. 栈顶是最近的**左括号**的下标
3. 栈顶是最后一个没有被匹配的**右括号**下标

执行 st.pop()

前三种情况变为：

1. 栈空。（即-1被弹出，此后右括号下标被放入）
2. 栈不空，可能是任意情况（ **-1、左括号、右括号**）
3. 栈空。（肯定不是左括号，如果是那早就和刚弹出的右括号匹配了；由1知，刚弹出的是右括号，所以之前不可能再有-1；绝对不可能有右括号，结合本情况右括号的替代性）

我们在栈不空的时候才会计算长度。

对于第2种情况，因为刚弹出的是左括号，所以直接与栈顶计算就行了。

对于第3种情况，栈空，把自己放进去。相当于刷新了最后一个没有被匹配的右括号的下标

```
class Solution {
public:
    int longestValidParentheses(string s) {
        stack<int>st;

        if(s.length() <=1 ) return 0;
        // 始终保持栈底元素为当前已经遍历过的元素中「最后一个没有被匹配的右括号的下标」
        // 这样的做法主要是考虑了边界条件的处理，栈里其他元素维护左括号的下标
        st.push(-1);

        int res = 0;
        for(int i=0; i<s.length(); i++){
            if(s[i]=='('){
                st.push(i);
            }
            else{
                st.pop();
                if(st.empty()){
                    // 把没匹配上的右括号下标放进去
                    st.push(i);
                }
                else {
                    res = max(res, i - st.top());
                }
            }
        }
        return res;
    }
};
```





### [lc]221. 最大正方形

在一个由 `'0'` 和 `'1'` 组成的二维矩阵内，找到只包含 `'1'` 的最大正方形，并返回其面积。

https://leetcode.cn/problems/maximal-square/solutions/234964/zui-da-zheng-fang-xing-by-leetcode-solution/



如果该位置的值是 0，则 dp(i,j)=0，因为当前位置不可能在由 1 组成的正方形中；

如果该位置的值是 1，则 dp(i,j) 的值由其上方、左方和左上方的三个相邻位置的 dp 值决定。具体而言，当前位置的元素值等于三个相邻位置的元素中的最小值加1。
$$
d p(i, j)=\min (d p(i-1, j), d p(i-1, j-1), d p(i, j-1))+1
$$


<img src="https://cdn.jsdelivr.net/gh/Lenvia/md-pic@master/uPic/%E6%88%AA%E5%B1%8F2023-02-27%2001.17.03.png" alt="截屏2023-02-27 01.17.03" style="zoom:50%;" />

关于dp的意义，可以看这篇

https://leetcode.cn/problems/count-square-submatrices-with-all-ones/solutions/101706/tong-ji-quan-wei-1-de-zheng-fang-xing-zi-ju-zhen-2/



```
class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        if(matrix.size() == 0 || matrix[0].size()==0)
            return 0;
        int m = matrix.size();
        int n = matrix[0].size();

        int dp[m][n];
        int maxx = 0;
        memset(dp, 0, sizeof(dp));

        for(int i = 0; i<m; i++){
            for(int j=0; j<n; j++){
                if(matrix[i][j] == '1'){
                    if(i==0 || j==0)
                        dp[i][j] = 1;
                    else
                        dp[i][j] = min(min(dp[i-1][j], dp[i][j-1]), dp[i-1][j-1]) + 1;
                    maxx = max(maxx, dp[i][j]);
                }
            }
        }
        return maxx * maxx;
    }
};
```





### ⚡️⚡️<font color=fuchisa>【状态压缩】[lc]1755 最接近目标值的子序列和</font>

从 `nums` 中选出一个子序列，使子序列元素总和最接近 `goal` 。

> **目标值不明确**，容量不知道，不能用背包，只能枚举子集的和。
>
> 只能二分拆数组来降低复杂度，然后枚举子数组的子集的和，最后用双指针指向两个子集和的元素，不断逼近目标值。
>
> 有人看到这里可能觉得是不是写错了，这题题目已经给出了目标值，为什么还说是目标值不明确的呢？ 原因在于，题目给的target不是我们最后要组合的目标值，题目要我们求的是min的最小值，这里的最小值我们在解题之前是不知道的。



```
class Solution {
public:
    int minAbsDifference(vector<int>& nums, int goal) {
        int n = nums.size();
        int ln = n/2;
        // 拆分数组
        vector<int>lvec = {nums.begin(), nums.begin() + ln};
        vector<int>rvec = {nums.begin()+ ln, nums.end()};

        int rn = rvec.size();

        int lcnt = 1<<ln;  // 状态个数
        int ldp[lcnt];  // ldp是原数组前半部分的子数组的集合
        ldp[0] = 0;

        int rcnt = 1<<rn;
        int rdp[rcnt];
        rdp[0] = 0;

        
        int id;
        for(int i=1; i<lcnt; i++){
            for(int j=0; j<ln; j++){
               id = 1<<j;
               if(id & i){  // ldp[i]可以有多个上个状态，我们只要选到一个就行了，都是一样的
                   ldp[i] = ldp[i-id] + lvec[j];
                   break;
               } 
            }
        }
        for(int i=1; i<rcnt; i++){
            for(int j=0; j<rn; j++){
               id = 1<<j;
               if(id & i){
                   rdp[i] = rdp[i-id] + rvec[j];
                   break;
               }
            }
        }
        sort(ldp, ldp+lcnt);
        sort(rdp, rdp+rcnt);

        int target = 0x7ffffff;

        // 仅原数组前半部分子序列的和
        int index1 = lower_bound(ldp, ldp+lcnt, goal) - ldp;
        if(index1 == lcnt){
            target = abs(ldp[lcnt-1] - goal);
        }
        else if(index1 == 0){
            target = abs(ldp[0] - goal);
        }
        else{
            target = min(abs(ldp[index1] - goal), abs(ldp[index1-1] - goal));
        }
        
        // 仅原数组后半部分子序列的和
        int index2 = lower_bound(rdp, rdp+rcnt, goal) - rdp;
        if(index2 == rcnt){
            target = min(target, abs(rdp[rcnt-1] - goal));
        }
        else if(index2 == 0){
            target = min(target, abs(rdp[0] - goal));
        }
        else{
            target = min(target, min(abs(rdp[index2] - goal), abs(rdp[index2-1] - goal)));
        }


        // 从原数组前半部分取一个和，从后半部分取一个和，然后想加
        int i = 0, j = rcnt - 1;
        while (i < lcnt && j >= 0) {
            int s = ldp[i] + rdp[j];
            
            target = min(target, abs(goal - s));
            if (s > goal) {
                j--;
            } else {
                i++;
            }
        }


        return target;

    }
};
```





## 字符串

### <font color=purple>NC55 最长公共前缀</font>

https://www.nowcoder.com/practice/28eb3175488f4434a4a6207f6f484f47?tpId=188&&tqId=38627&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking

纵向扫描

```
class Solution {
public:
    /**
     * 
     * @param strs string字符串vector 
     * @return string字符串
     */
    string longestCommonPrefix(vector<string>& strs) {
        if(strs.size()==0)
            return "";
        // 纵向扫描
        for(int j=0; j<strs[0].size(); j++){
            for(int i=0; i<strs.size(); i++){
                // 如果strs[i]的第j位越界 或 如果第j位不相等
                if(j==strs[i].size() || strs[0][j] != strs[i][j])
                    return strs[0].substr(0, j);
            }
        }
        return strs[0];
    }
};
```



### ⚡️<font color=fuchsia>NC17 最长回文子串</font>

**Manacher**算法

暴力方法就是 对于每个位置，先设置延伸长度 p[i] = 1，然后看 s[i-p[i]] 是否等于 s[i+p[i]]，不断扩大p[i]。

Manacher方法就是偷懒，即p[i] 的初始化。重点是关于mx 和 id 的设置。

```
int mx = 0;  // 当前最右位置
int id = -1;  // 达到最右位置时的中心
// 设置mx和id，意思是可以保证 [2id-mx, mx] 是对称的

...

if(mx>i){  // 此时的排列顺序是  2id-mx, ..., 2id-i, ..., id, ..., i, ..., mx
    // 我们想看看 i关于 id 的对称点 2id-i 的对称情况
    // [i, mx]这段相当于 [2id-mx, 2id-i]这段关于 id 对称
    // 所以就看 2*id-i 这点的延伸长度 和 它到边界 2id-mx 的距离大小了，选小的
    p[i] = min(p[2*id-i], mx-i);
}
```

完整代码：

```
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param A string字符串 
     * @return int整型
     */
    const static int MAXN = 1001;
    int p[2*MAXN+3];
    
    
    int Manacher(string newStr){
        int maxL = -1;  // 最长回文子串长度
        int mx = 0;  // 当前最右位置
        int id = -1;  // 达到最右位置时的中心
        // 设置mx和id，意思是可以保证 [2id-mx, mx] 是对称的
        for(int i=1; i<newStr.length(); i++){
            if(mx>i){  // 此时的排列顺序是  2id-mx, ..., 2id-i, ..., id, ..., i, ..., mx
                // 我们想看看 i关于 id 的对称点 2id-i 的对称情况
                // [i, mx]这段相当于 [2id-mx, 2id-i]这段关于 id 对称
                // 所以就看 2*id-i 这点的延伸长度 和 它到边界 2id-mx 的距离大小了，选小的
                p[i] = min(p[2*id-i], mx-i);
            }
            else p[i] = 1;
            while(newStr[i-p[i]]==newStr[i+p[i]])
                p[i]++;
            if(mx< i+p[i]){
                id = i;
                mx = i+p[i];
            }
            maxL = max(maxL, p[i]-1);  // 减1的原因，自己画着看就知道了
        }
        return maxL;
    }
    
    int getLongestPalindrome(string A) {
        int len = A.length();
        // 初始化
        string newStr(2*len+3, '#');
        int newLen = newStr.length();
        newStr[0] = '$'; newStr[newLen-1] = '*';
        for(int i=0, j=2; i<A.length(); i++, j+=2){
            newStr[j] = A[i];
        }  // 例如 A = "abcbc"，则newStr = "$#a#b#c#b#c#*"
        fill(p, p+newLen, 1);
        
        // Manacher返回的是插入分隔符后的延伸长度，所以最终返回应该除以2
        return Manacher(newStr);
        
    }
};
```



（如果需要写整个程序的代码，用这个）

```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string.h>
#include <algorithm>
#include <vector>
#include <map>
#include <cmath>
#include <queue>
using namespace std;
const int MAXN = 110005;
int p[MAXN*2];
char s[MAXN*2];
string str;
string newStr;

/*
    newStr的构成不仅仅是加个# 应该给原串加完#后，再在首尾加上 不一样 的 两个 符号 比如 str = 12321
    newStr = $#1#2#3#2#1#* 如果首尾一样，会出错!!!!!
*/
void init(){
    fill(p, p+MAXN, 1);
    //在这里 newStr别手贱前面写个string，而且newStr的⻓度是2*str.length()+3
    newStr = string(2*str.length()+3, '#');
    newStr[0] = '$';
    newStr[newStr.length()-1] = '*'; //在str的每个字符后都加个“#”，得到新字符串newStr
    for(int i=0, j=2; i<str.length(); i++, j+=2){
        newStr[j] = str[i];
    }
}
int Manacher(){
    init();
    int maxL = -1; //最大回文⻓度
    int id = -1; //当前使mx达到尽可能右边时的回文中心
    int mx = 0;
    //末尾还有个#，不要放进来
    for(int i=1; i<newStr.length(); i++){
        if(mx>i){ //如果之前的中心id的最大延展位置超过了i，那么看看可不可以给p[i]赋 一个最小值，省去一些计算
            /*
            p[2*id-i]是i关于id的对称点的延伸半径。 mx-i是mx与i的距离，同时也是mx
            关于id的对称点到 i关于id的对称点的距离
            
            如果 p[2*id-i]>mx-i，说明i的对称点j的半径是大的，但是我们现在最多只能
            保证[mx对称点，mx]是对称的，所以只能先让p[i]等于mx-i
            如果 p[2*id-i]<mx-i，说明j的范围还没超过id的范围，那稍微一想就明白了，
            i的半径就是j的半径。 */
            p[i] = min(p[2*id-i], mx-i);
        }
        else p[i] = 1; //否则没有简便方法，半径只能从1开始搜了
        while(newStr[i-p[i]] == newStr[i+p[i]]){ //从上面已经预赋值的半径继续往两边寻找
            cout<<newStr[i]<<" "<<p[i]<<" "<<newStr[i-p[i]]<<" "<<newStr[i+p[i]]<<endl;
            p[i]++;
        }
        if(mx< i+p[i]){ //如果当前的最右范围超过了mx，那么更新mx。 因为mx尽可能的远 我们才能更容易偷懒。
            id = i;
            mx = i+p[i];
            
        }
        maxL = max(maxL, p[i]-1);
    }
    return maxL;
}

int main(){
    while(scanf("%s",s)!=EOF){ //用字符数组输入!!!!
        str = s;
        int maxL = -1;
        maxL = Manacher();
        cout<<maxL<<endl;
    }
}


```



动态规划算法

```
class Solution {
public:
    string longestPalindrome(string s) {
        if(s.length()<2)
            return s;
        
        int len = s.length();
        int maxLen = 1;  // 如果长度大于2，那么回文子串长度至少为1.
        int startIndex = 0;
        
        bool dp[len+1][len+1];  // dp[i][j] 表示 s[i]到s[j]是不是回文子串
        memset(dp, false, sizeof(dp));

        for(int i=0; i<len; i++)
            dp[i][i] = true;

        for(int l=2; l<=len; l++){  // 子串的长度从小到大
            for(int i=0; i<len; i++){  // 每次从最开头开始
                int j = i+l-1;  // 子串的末端
                if(j>=len)  // 越界
                    continue;
                if(s[i]!=s[j]){  // 子串 s[i]~s[j]肯定不是回文子串
                    dp[i][j] = false;
                }
                else{
                    if(l<=2)
                        dp[i][j] = true;
                    else{  // 因为s[i+1]~s[j-1]的长度更小，所以在之前就计算过了
                        dp[i][j] = dp[i+1][j-1];
                    }
                }
                if(dp[i][j] && l>maxLen){  // 记录长度和起始下标
                    maxLen = l;
                    startIndex = i;
                }
            }
        }

        return s.substr(startIndex, maxLen);
    }
};
```



### <font color=purple>NC121 字符串的排列</font>

方法一：投机取巧。用了`<algorithm>`中的 next_permutation()

```
class Solution {
public:
    
    // bool next_permutation( iterator start, iterator end);
    // next_permutation()函数功能是输出全部比当前排列大的排列。顺序是从小到大。
    vector<string> Permutation(string str) {
        vector<string>res;
        if(str.length()==0) return res;

        string first = str;
        do{
            next_permutation(str.begin(), str.end());
            res.push_back(str);
        }while(str!=first);
        
        
        return res;
    }
};
```



方法二：dfs+set

```
class Solution {
public:
    void perm(int pos, string s, set<string> &ret) {
        if (pos+1 == s.length()) {
            ret.insert(s);
            return;
        }
        // for循环和swap的含义：对于“ABC”，
        // 第一次'A' 与 'A'交换，字符串为"ABC", pos为0， 相当于固定'A'
        // 第二次'A' 与 'B'交换，字符串为"BAC", pos为0， 相当于固定'B'
        // 第三次'A' 与 'C'交换，字符串为"CBA", pos为0， 相当于固定'C'
        for (int i = pos; i < s.length(); ++i) {
            swap(s[pos], s[i]);
            perm(pos+1, s, ret);
            swap(s[pos], s[i]);
            // 回溯的原因：比如第二次交换后是"BAC"，需要回溯到"ABC"
            // 然后进行第三次交换，才能得到"CBA"
        }
    }
    vector<string> Permutation(string s) {
        if (s.empty()) return {};
        set<string> ret;
        perm(0, s, ret);
        return vector<string>({ret.begin(), ret.end()});
    }
};
```





### NC141 判断是否为回文字符串

水。直接判断原始串和reverse后相不相等。

如果不额外开辟空间的话，就直接双指针咯。

```
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 
     * @param str string字符串 待判断的字符串
     * @return bool布尔型
     */
    bool judge(string str) {
        string ori = str;
        reverse(str.begin(), str.end());
        return ori==str;
    }
};
```



### [lc]<font color=red>1910. 删除一个字符串中所有出现的给定子字符串</font>

https://leetcode-cn.com/problems/remove-all-occurrences-of-a-substring/

2022.02.15 字节面试第二题。

（面完才知道我写错了当时，我就觉得哪有问题，面试官也觉得有问题，但我俩都没看出来。。。）

模拟！其实过程很好想，但是删除之后指针应该停在哪是个问题！

所以引入了一个类似于栈/队列的思想。

一个一个压入，**如果长度满足就判断一下最近压入的len长度的子串是否需要删。**

```
class Solution {
public:
    string removeOccurrences(string s, string part) {
        int len = part.length();

        string res;
        for(int i=0; i<s.length(); i++){
            res.push_back(s[i]);
            if(res.length()>=len){
                if(res.substr(res.size()-len, len)==part){  // 删掉res末尾两个
                    res.erase(res.size()-len, len);
                }
            }
        }
        return res;
    }
};
```



### NC1 大数加法

```
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 计算两个数之和
     * @param s string字符串 表示第一个整数
     * @param t string字符串 表示第二个整数
     * @return string字符串
     */
    string solve(string s, string t) {
        // 对齐
        if(s.length() >= t.length()){
            t.insert(0, s.length()-t.length(), '0');
        }
        else{
            s.insert(0, t.length()-s.length(), '0');
        }
        int flag = 0;
        int temp;
        for(int i = s.length()-1; i>=0; i--){
            temp = (s[i]-'0') + (t[i]-'0') + flag;
            s[i] = temp%10 +'0';
            flag = temp/10;
        }
        if(flag) s.insert(0, "1");
        return s;
    }
};
```



### <font color=dodgerblue>NC111 最大数</font>

cmp函数的编写！

将多个字符串进行排列并拼接，每个数不可拆分，使得最后的结果最大。

轩神直接return s1+s2 > s2+s1。

对cmp函数进一步理解：**bool cmp(a, b)。若返回true，则a在b之前；若返回false，则b在a之前。**

所以函数内部你随便写，怎么运算都可以，只要满足上面的规则就行。

记得考虑为0的特殊情况。

方法一：（from轩神）

```
class Solution {
public:
    /**
     * 最大数
     * @param nums int整型vector 
     * @return string字符串
     */
    static bool cmp(string s1, string s2){
				return s1+s2 > s2+s1;
    }
    
    string solve(vector<int>& nums) {
        if(nums.empty()) return "0";
        vector<string>strs;
        for(int i=0; i<nums.size(); i++){
            strs.push_back(to_string(nums[i]));
        }
        sort(strs.begin(), strs.end(), cmp);
        if(strs[0][0]=='0') return "0";  // 开头就是0，没救了。
        
        string ans;
        for(int i=0; i<strs.size(); i++)
            ans+=strs[i];
        return ans;
    }
};
```



方法二：我的原始思路

s1和s2，如果完全一样，那谁排前面都行。

如果长度一样但值不一样，返回字典序大的那个。（比如 "234" 排在 "123" 前面）

如果长度不一样，看共同的前n位的字典序，返回字典序较大的。（比如 "234" 排在 "2333"前面）

如果长度不一样，但共同的前n位的字典序一样，则看比较长的下一位。（比如 "235" 和 "23"，比较 '5'和开头的 '2'）。

原因很显然，比如 s1 = "235"，s2="23"，s1排在前面是s1+s2 = "23523"。s2+s1 = "23235"。他们不一样的地方就是 '5'和'2'。

```
class Solution {
public:
    /**
     * 最大数
     * @param nums int整型vector 
     * @return string字符串
     */
    static bool cmp(string s1, string s2){
        if(s1==s2) return s1>s2;
        
        int minLen = min(s1.length(), s2.length());
        if(s1.substr(0, minLen) == s2.substr(0, minLen)){
            // 解释一下。比如 23 和 235，前缀23一样。然后5>2，所以235要排在23前面
            if(minLen==s1.length()){
                return s2[minLen] < s2[0];
            }
            else{
                return s1[minLen] > s1[0];
            }
        }
        else{  // 前n位不一样，那取字典序最大的。 比如"235" 和 "229"
            return s1 > s2;
        }
    }
    
    string solve(vector<int>& nums) {
        if(nums.empty()) return "0";
        vector<string>strs;
        for(int i=0; i<nums.size(); i++){
            strs.push_back(to_string(nums[i]));
        }
        sort(strs.begin(), strs.end(), cmp);
        if(strs[0][0]=='0') return "0";  // 开头就是0，没救了。
        
        string ans;
        for(int i=0; i<strs.size(); i++)
            ans+=strs[i];
        return ans;
    }
};
```



### ⚡️<font color=purple>NC28 最小覆盖子串</font>

给出两个字符串 s 和 t，要求在 s 中找出最短的包含 t 中所有字符的连续子串。

双指针。队列思想。

既然不要求顺序，那直接统计个数不就行了。对于s的某一子串sub，只要sub里包含的目标字符个数足够，那么sub就合法（我没说最小）。

那么就滑动呗。 首先初始化left = 0, right = 0。如果子串满足了，left向右走（收缩），如果不满足，right向右走（扩展）。然后每次合法都记录一下长度，更新就行了。

**边界逻辑要处理好。**

完整代码：

```

class Solution {
public:
    /**
     * 
     * @param S string字符串 
     * @param T string字符串 
     * @return string字符串
     */

    unordered_map<char, int> count1;
    unordered_map<char, int> count2;
    unordered_map<char, int>:: iterator it;
    int minL = INT_MAX;

    bool judge(){
        for(it=count2.begin(); it!=count2.end(); it++){
            if(!count1.count(it->first) || (count1[it->first] < it->second))
                return false;
        }
        return true;
    }

    string minWindow(string S, string T) {
        if(S.length() < T.length()) return "";
        count1.clear();
        count2.clear();

        for(int i=0; i<T.length(); i++){
            count2[T[i]]++;
        }

        int l, r;
        l = 0; r = 0;
        string res;
        while(r<S.length()){
            count1[S[r]]++;
            while(judge() && l<=r){  // 如果当前满足条件，继续把左指针右移
                if(minL > r-l+1){
                    minL = r-l+1;
                    res = S.substr(l, r-l+1);
                }
                count1[S[l]]--;
                l++;
            }
            // 这时候不满足了
            r++;
        }
        return res;
    }
};
```



### [lc]子串的最大出现次数

- 子串中不同字母的数目必须小于等于 `maxLetters` 。
- 子串的长度必须大于等于 `minSize` 且小于等于 `maxSize` 

https://leetcode-cn.com/problems/maximum-number-of-occurrences-of-a-substring/

题目中maxSize是没用的。因为长的一定包含短的。

法一：暴力遍历，先把长度为minSize的子串都放进去，然后检查子串合法性和数量

```
class Solution {
public:
    map<string, int>count;
    map<char, int>kinds;

    bool isValid(string str, int maxLetters){
        kinds.clear();
        for(int i=0; i<str.length(); i++){
            kinds[str[i]]++;
        }
        if(kinds.size()>maxLetters) return false;
        return true;
    }

    int maxFreq(string s, int maxLetters, int minSize, int maxSize) {
        if(maxSize<minSize) return 0;

        // 先丢进去统计
        for(int i=0; i<s.length()-minSize+1; i++){
            count[s.substr(i, minSize)]++;
        }

        map<string, int>::iterator it;
        int maxx = 0;
        for(it = count.begin(); it!=count.end(); it++){
            if(isValid(it->first, maxLetters)){
                maxx = max(maxx, it->second);
            }
        }
        return maxx;
    }
};
```



法二：滑动窗口。在遍历的同时观察是否合法，并且由于滑动窗口每次只改变两个char的数量，统计起来比较快。

```c++
class Solution {
public:
    
    int maxFreq(string s, int maxLetters, int minSize, int maxSize) {
        if(maxSize < minSize || s.size() < minSize) return 0;

        map<char, int>cnt;
        map<string, int>str_map;
        int maxx = 0;

        // 双指针
        string str;
        int l =0;
        int r = minSize-1;
        str = s.substr(l, minSize);
        // 统计[l, r)
        for(int i=l; i<r; i++){
            cnt[s[i]]++;
        }
        

        // 滑动窗口
        while(r<s.size()){
            cnt[s[r]]++;
            if(cnt.size()<=maxLetters){
                str = s.substr(l, minSize);
                str_map[str]++;
                if(maxx < str_map[str]){
                    maxx = str_map[str];
                }
            }
            cnt[s[l]]--;
            if(!cnt[s[l]]) cnt.erase(s[l]);  // 记得删掉
            // 滑动
            l++;
            r++;
        }

        return maxx;
    }
};
```





### <font color=purple>NC149 kmp算法</font>

next数组多开一位！

```
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 计算模板串S在文本串T中出现了多少次
     * @param S string字符串 模板串
     * @param T string字符串 文本串
     * @return int整型
     */
    
    void getNextTable(string pattern, int* nextTable){
        int k = -1;
        int j = 0;
        int len = pattern.length();
        nextTable[j] = k;
        while(j<len+1){
            if(k==-1 || pattern[j]==pattern[k]){
                j++;
                k++;
                nextTable[j] = k;
            }
            else{
                k = nextTable[k];
            }
        }
    }
    
    int KMP(string S, string T, int* nextTable){
        int i = 0;
        int j = 0;
        int len1 = T.length();  // 主串
        int len2 = S.length();  // 模式串
        int count = 0;
        
        while(i<len1){
            if(j==-1 || T[i]==S[j]){
//                 printf("%d %d\n", i, j);
                i++;
                j++;
            }
            else{
                j = nextTable[j];
            }
            
            if(j==len2){  // 找到了一个
                j = nextTable[j];
                count++;
            }
        }
        
        return count;
    }
    
    int kmp(string S, string T) {
        int nextTable[S.length()+1];  // 多开一位！
        
        getNextTable(S, nextTable);
        
        return KMP(S, T, nextTable);
    }
};
```



### NC142 最长重复子串

第一层循环枚举长度，第二层循环枚举起点。

和下面一题有一点点关联。

```
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 
     * @param a string字符串 待计算字符串
     * @return int整型
     */
    int solve(string a) {
        int n = a.length();
        int res =  0;  // res 表示重复的长度

        int flag = 0;

        for(int i = n/2; i>0; i--){  // 枚举长度
            for(int j=0; j< n-i; j++){  // 枚举起点
                if(a[j] == a[i+j]){
                    res++;
                }
                else{
                    res = 0;
                }
                if(res == i) return i*2;  // 完全重复
            }
        }
        return 0;
    }
};
```





### ⚡️[unknown]求一个字符串中<font color=red>连续出现</font>次数最多的子串

先确定 [i, j) 与 [j, j+j-i] 这一段是否相等。如果相等说明至少连续出现了。

然后开始从 j+j-i 开始往后找循环节，统计次数。

```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string.h>
#include <algorithm>
#include <vector>
#include <map>
#include <cmath>
#include <queue>
using namespace std;


string str;

int main(){
    int maxx = 0;
    string maxstr;
    string temp;
    int n = 0;
    while(getline(cin, str) && str!="#"){
        n++;
        for(int i=0; i<str.length(); i++){
            for(int j=i+1; j<str.length(); j++){
                // 每个内循环，固定循环节是 [i, j)，长度是offset
                int count = 1;
                int offset = j-i;
                temp = str.substr(i, offset);  // 循环节
                if(temp == str.substr(j, offset)){
                    count++;
                }
                else continue;
                
                for(int k=j+offset; k<str.length(); k+=offset){
                    if(temp == str.substr(k, offset)){
                        count++;
                    }
                    else break;
                }
                if(maxx<count){
                    maxx = count;
                    maxstr = temp;
                }
                
                
            }
        }
        cout<<"Case: "<<n<<": "<<maxstr<<endl;
    }
    return 0;
}

```





## 数学

### ⚡️NC112 进制转换

这个进制转换比较水，原数不是大数（字符串）

**不断进行求模和整除运算，便可依次求得被移动到最低数位的值；以此类推，便可得到所有数位上的值。**

记得最后翻转一下。

大数的任意进制转换参考`题目无关.md`

```
class Solution {
public:
    /**
     * 进制转换
     * @param M int整型 给定整数
     * @param N int整型 转换到的进制
     * @return string字符串
     */
    char int2char(int x){
        if(x>=0 && x<=9){
            return x+'0';
        }
        else return x-10+'A';
    }
    
    string solve(int M, int N) {
        string res;
        int flag = 0;
        if(M<0){
            M = -M;
            flag = 1;
        }
        
        while(M){
            // 每次作除法，得到余数
            int remain = M%N;
            M = M/N;
            res.push_back(int2char(remain));  // 记得最后要反过来
        }
        reverse(res.begin(), res.end());
        if(flag)  // 添加负号
            res.insert(0, "-");
        
        return res;
    }
};
```



### ⚡️<font color=fuchsia>NC79 丑数</font>

**[lc]面试题 17.09. 第 k 个数**

https://leetcode-cn.com/problems/get-kth-magic-number-lcci/

2022.02.16 字节二面第一题



把只包含质因子xxxx的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n个丑数。

多指针。

我哭了啊，这一题在我的刷题列表里，但我没刷到这一题。当时没做出来。

这一题用的是2、3、5。面试时是2，3，5，7

```
class Solution {
public:
    int GetUglyNumber_Solution(int index) {
        vector<int>dp;
        dp.push_back(1);  // dp[0] = 1;
        int p1, p2, p3;
        p1 = 0; p2 = 0; p3 = 0;
        int v1, v2, v3;
        for(int i=1; i<index; i++){
            v1 = dp[p1]*2;
            v2 = dp[p2]*3;
            v3 = dp[p3]*5;
            dp.push_back(min(v1, min(v2, v3)));
            // 防止重复，同步一下
            if(dp[i]==v1) p1++;
            if(dp[i]==v2) p2++;
            if(dp[i]==v3) p3++;
        }
        
        return dp[index-1];
    }
};
```



### <font color=dodgerblue>NC151 最大公约数</font>

$gcd(a,b) <=> gcd(b,a\%b)$

递归写法

```
int gcd(int a, int b){
	return b==0? a: gcd(b, a%b);
}
```

```
int gcd(int a, int b ) {
    if(b==0) return a;
    return gcd(b, a%b);
}
```

非递归写法

```
int gcd(int a, int b) {
    if(a<b)
        swap(a, b);
    int temp;
    while(b!=0){
        temp = a;
        a = b;
        b = temp%b;
    }
    return a;
}
```





## 其他

### 实现前缀树

https://leetcode-cn.com/problems/implement-trie-prefix-tree/

其实我没太搞懂它想让我用什么做。我直接暴力map实现

```
class Trie {
public:
    map<string, bool>str2bool;
    Trie() {
        str2bool.clear();
    }
    
    void insert(string word) {
        str2bool[word] = true;
    }
    
    bool search(string word) {
        if(str2bool.find(word)==str2bool.end())
            return false;
        return true;
    }
    
    bool startsWith(string prefix) {
        map<string, bool>::iterator it;
        int len = prefix.length();
        int flag = 0;  // 遇到第一个字母相等的，启动
        for(it=str2bool.begin(); it!=str2bool.end(); it++){
            if(!flag && it->first[0]!=prefix[0])
                continue;
            flag = 1;  // 运行到这里说明之前已经遇到了第一个字符匹配的
            //map是按字典排序的，如果第一个字符都不匹配，那后面不可能有匹配的了
            if(it->first[0]!=prefix[0]){
                return false;
            }
            if(it->first.substr(0,len) == prefix)
                return true;
        }
        return false;
    }
};

/**
 * Your Trie object will be instantiated and called as such:
 * Trie* obj = new Trie();
 * obj->insert(word);
 * bool param_2 = obj->search(word);
 * bool param_3 = obj->startsWith(prefix);
 */
```








## 没来得及做

