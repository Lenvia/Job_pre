[TOC]

# 链接

[【美团2021第10场】](https://www.nowcoder.com/exam/test/68986953/submission?pid=28665343&pageSource=testHistory)

[【美团2021第9场】](https://www.nowcoder.com/exam/test/68955630/submission?pid=28665338&pageSource=testHistory)

[【美团2021第8场】](https://www.nowcoder.com/exam/test/68977715/submission?pid=28665331&pageSource=testHistory)

[【美团2021第7场】](https://www.nowcoder.com/exam/test/68980317/submission?pid=28665326&pageSource=testHistory)

[【美团2021第6场】](https://www.nowcoder.com/exam/test/68990478/submission?pid=28665320&pageSource=testHistory)



# 题目

## 暴力 & 模拟

#### 【美团2021第7场】六位数

```
小团想要编写一个程序，希望可以统计在M和N之间（M<N，且包含M和N）有多少个六位数ABCDEF满足以下要求：

(1) ABCDEF这六个数字均不相同，即A、B、C、D、E和F表示六个不同的数字。

(2) AB+CD=EF。即将这个六位数拆成三个两位数，使得第1个和第2个两位数的和等于第3个两位数。


数据范围：
100000≤M<N≤999999 
```



输入描述：

```
单组输入。输入两个六位正整数M和N（M
```

输出描述：

```
输出在M到N之间（包含M和N）满足要求的六位数的个数。
```

示例1

输入例子：

```
100000 110000
```

输出例子：

```
0
```

------

打表：

```
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

vector<int>vec;
void init(){  // 找出100以内所有 AB+CD=EF的
    int e, f;
    int temp;
    for(int a = 1; a<=8; a++){
        for(int b=1; b<=9; b++){  // 个位不可能为0
            if(b==a) continue;
            for(int c=0; c<=9; c++){
                if(c==b || c==a) continue;
                for(int d=1; d<=9; d++){
                    if(d==c|| d==b || d==a) continue;
                    temp = a*10 + b + c*10 + d;
                    if(temp>=100) continue;
                    e = temp/10;
                    f = temp%10;
                    if(e==d || e==c|| e==b || e==a) continue;
                    if(f==e || f==d || f==c || f==b || f==a) continue;
//                    printf("%d %d %d %d %d %d\n", a, b, c, d, e, f);
                    int sum = a*100000 + b*10000 + c*1000 + d*100 + e*10 + f;
                    vec.push_back(sum);
                }
            }
        }
    }
}

int main() {
    int a, b;
    init();
    sort(vec.begin(), vec.end());

    while (cin >> a >> b) {
        int left = lower_bound(vec.begin(),vec.end(), a) - vec.begin();
        if(left < 0){
            cout<<0<<endl;
            continue;
        }
        int res = 0;
        for(int i=left; i<vec.size(); i++){
            if(vec[i] <= b)
                res++;
            else break;
        }
        cout<<res<<endl;
    }
}
// 64 位输出请用 printf("%lld")
```







#### 【美团2021第8场】小美的书架

```
小美的书架上有很多书。小美是个爱读书的新时代好青年。
小团虽然也喜欢看书，但小团大多数时候都更喜欢来小美家蹭书读。
这就导致小美的书架上很多书都会被小团借走。
小美很烦这一点，就想出了一个招数，小美的书架是一行一行的，他会对一些行加锁，这样小团就借不走了。
现在小团想要借书，请你帮忙看看小团能不能借到书，如果可以借到的话在哪一行书架上有这本书。
为了简单起见，每本书将用一个正整数进行编号，小美的书架一共有N行。
```

输入描述：

```
第一行两个正整数N，M，Q，表示小美书架有N行编号1到N，书本编号从1到M，接下来有Q个操作接下来Q行，每行是下列操作中的一种：1 x y : x是书本的编号，y是书架的行编号，代表小美将编号为x的书本放置到y行上。若该书本在小团手上则放置无效，若原来该书在书架上且原行上锁则放置无效，若该书被放置到一个锁了的行上则放置无效。2 y : y是书架的行编号，代表小美将行编号为y的书架加锁，对已经上锁的书架行该操作无效。3 y : y是书架的行编号，代表小美将行编号为y的书架锁去掉，对无锁的书架行该操作无效。4 x : x是书本的编号，代表小团想借编号为x的书本，对该操作若可以借到输出一行正整数在哪一行，借不到输出一行-15 x : x是书本的编号，代表小团还回来编号为x的书本。若该书本不在小团手上该操作无效。
```

输出描述：

```
对于每个操作4，若可以借到输出一行正整数在哪一行，借不到输出一行-1
```

示例1

输入例子：

```
5 5 10
1 1 4
1 2 3
1 3 1
2 1
4 1
5 2
4 3
4 5
3 1
4 2
```

输出例子：

```
4
-1
-1
3
```



------

水题，不过注意如果只是用map来判断存在，

例如 map<int, bool>have，最好用 if(have[x]) 而不是 if(have.count(x)) 和 have.erase(x)操作，可能有越界。

```
#include <iostream>
#include <map>
#include <vector>
#include <cstring>
using namespace std;

int main() {
    int n,m,q;
    while(scanf("%d %d %d", &n, &m, &q)!=EOF){
        map<int, bool>lock;
        map<int, int>store;  // 书->行
        map<int, bool>have;  // 借到的书
        int op;
        int x, y;
        while(q--){
            cin>>op;
            switch (op) {
                case 1:  // 放书
                    cin>>x>>y;
                    if(have[x] || (store[x] && lock[store[x]]) || lock[y])
                        break;
                    store[x] = y;
                    break;
                case 2:  // 加锁
                    cin>>y;
                    lock[y] = true;
                    break;
                case 3:  // 解锁
                    cin>>y;
                    lock[y] = false;
                    break;
                case 4:  // 借书
                    cin>>x;
                    if(store[x] && !lock[store[x]]){  // 有书且没上锁
                        have[x] = true;
                        cout<<store[x]<<endl;
                        store[x] = false;
                    }
                    else cout<<-1<<endl;
                    break;
                case 5:  // 还书
                    cin>>x;
                    if(!have[x]) break;
                    have[x] = false;
                    break;
            }
        }
    }
}
```



## 链表

## 查找

#### ⌛️【华为机试】猴子吃桃

https://blog.csdn.net/weixin_44052055/article/details/123959390

先判断桃树个数是否合法，然后以最多桃子为最大值，1为最小值开始二分。



```
孙悟空喜欢吃蟠桃，一天他乘守卫蟠桃园的天兵天将离开了而偷偷的来到王母娘娘的蟠桃园偷吃蟠桃。
已知蟠桃园有 N 棵蟠桃树，第 i 棵蟠桃树上有 N[i]（大于 0）个蟠桃，天兵天将将在 H（不小于蟠桃树棵数）小时后回来。
孙悟空可以决定他吃蟠桃的速度 K（单位：个/小时），每个小时他会选择一颗蟠桃树，从中吃掉 K 个蟠桃，如果这棵树上的蟠桃数小于 K，他将吃掉这棵树上所有蟠桃，然后这一小时内不再吃其余蟠桃树上的蟠桃。
孙悟空喜欢慢慢吃，但仍想在天兵天将回来前将所有蟠桃吃完。
求孙悟空可以在 H 小时内吃掉所有蟠桃的最小速度 K（K 为整数）。
```
输入描述:
```
从标准输入中读取一行数字，前面数字表示每棵数上蟠桃个数，最后的数字表示天兵天将将离开的时间。
```
输出描述：
```
吃掉所有蟠桃的 最小速度 K（K 为整数）或 输入异常时输出 -1。
```

示例 1：

输入

```java
3 11 6 7 8
1
```

输出

```java
4
1
```







## 搜索

### DFS

### BFS

#### <font color=blue>【美团2021第9场】神秘的苹果树</font>

无根输入指定根，转有根树模版。



```
小团找到一颗有n个节点的苹果树，以1号节点为根，且每个节点都有一个苹果，苹果都有一个颜色，但是这棵树被施加了咒术，这使得小团只能从某一个节点的子树中选取某一种颜色的拿。小团想要拿到数量最多的那种颜色的所有苹果，请帮帮她。每次她会指定一个节点t，如果小团只能从节点t的子树中选取某一种颜色的苹果，选取什么颜色能拿到最多的苹果？如果有多种颜色都可以拿同样多的苹果，输出颜色编号最小的那个对应的编号。

节点x的子树定义为所有将x当作祖先的节点，x也视为x的子树的一部分。
```

输入描述：

```
第一行一个正整数n表示这颗树上节点的个数。接下来n-1行，每行两个正整数xi,yi,表示树上第i条边连接的两个节点。接下来一行n个正整数c_i，分别表示从1~n号节点上的苹果的颜色。接下来一行一个正整数q,表示接下来有q次独立的询问。接下来q行，每行一个正整数t表示询问：如果小团只能从节点t的子树中选取某一种颜色的苹果，选取什么颜色能拿到最多的苹果？如果有多种颜色都可以拿同样多的苹果，输出颜色编号最小的那个对应的编号。      对于100%的数据n≤5000, 1≤xi,yi,t≤n, ci≤1000000000,q≤1000
```

输出描述：

```
输出q行，每行一个整数，表示答案。   
```

示例1

输入例子：

```
7
1 2
1 3
2 4
2 5
3 6
3 7
1 1 2 1 2 2 3
7
1
2
3
4
5
6
7
```

输出例子：

```
1
1
2
1
2
2
3
```

------

题目中只告诉我们1为根节点，因此在输入两个有边相连的节点时，我们并不知道哪个是父节点哪个是子节点，需要先构建无向图的邻接表。然后从根节点1开始，自顶向下删去子节点指向父节点的关系，将无向图修改为有向图。 

在每次query的过程中，利用bfs求得每个节点 **t** 的子树对应的所有节点，然后对节点颜色进行计数，输出出现最多且编号最小的颜色即可。 

```
#include <iostream>
#include <map>
#include <vector>
#include <cstring>
#include <queue>
using namespace std;

const int MAXN = 5005;
int color[MAXN+5];
map<int, vector<int>>g;
map<int, int>cnt;  // 颜色

void bfs(int node){  // bfs遍历当前树
    queue<int> q;
    q.push(node);
    while(!q.empty()){
        int cur = q.front();
        q.pop();
        cnt[color[cur]]++;
        for(int i=0; i<g[cur].size(); i++){
            q.push(g[cur][i]);
        }
    }

}

void clean(int root){  // 无向图转有向图
    if(g[root].size()>0){
        for(int i=0; i<g[root].size(); i++){
            int node = g[root][i];
            for(auto it=g[node].begin(); it!=g[node].end(); it++){
                if(*it == root){  // 删除指向父节点的
                    g[node].erase(it);
                    break;
                }
            }
            clean(node);  // 递归删除
        }
    }
}

int main() {
    int n;
    while(scanf("%d", &n)!=EOF){
        int x, y;
        g.clear();
        for(int i=0; i<n-1; i++){
            scanf("%d %d", &x, &y);
            g[x].push_back(y);
            g[y].push_back(x);
        }
        clean(1);  // 转有向图
        for(int i=1; i<=n; i++){
            cin>>color[i];
        }
        int q;
        cin>>q;
        int start;
        while(q--){
            cin>>start;
            cnt.clear();
            bfs(start);

            // 排序
            int maxx = -1;
            int clr = 0;
            for(auto it = cnt.begin(); it!=cnt.end(); it++){
                if(it->second > maxx){
                    maxx = it->second;
                    clr = it->first;
                }
            }
            cout<<clr<<endl;
            
        }

    }
}
// 64 位输出请用 printf("%lld")
```



#### 【美团2021第8场】十字路口

```
在小美和小团生活的城市中，有n行m列共计n*m个十字路口，第i行j列的十字路口有两个属性aij，b­ij。当行人处在i行j列的路口，对于任意非负整数k:
当时间处在[k*aij+k*bij), (k+1)*aij+k*bij)时，行人可以选择走到i±1行j列的路口。
当时间处在[(k+1)*aij+k*bij), (k+1)*aij+(k+1)*bij)时，行人可以选择走到i行j±1列的路口。
每次移动花费的时间为1，且要保证将要去的十字路口存在，即属于n*m个路口当中。可以选择原地静止不动。
在第0时刻，小美处在xs行ys列的十字路口处，要去xt行yt列的十字路口找小团。小团原地不动等小美，请问小美所花费的时间最少是多少
```

输入描述：

```
第一行六个正整数n，m，xs，ys，xt，yt，含义如上文所示。以样例第一行【5、5、2、4、4、3】 共计6个数字为例，前两位数字代表有5*5的二维数组，三、四位数字代表小美处在2行4列的十字路口处，五、六位数字代表要去4行3列的十字路口找小团。接下来n行每行m个正整数，在样例中为第一个5*5的二维数组，第i行第j个数代表i行j列十字路口的属性aij。接下来n行每行m个正整数，在样例中为第二个5*5的二维数组，第i行第j个数代表i行j列十字路口的属性bij。对于100%的数据，1≤n，m，xs，ys，xt，yt，aij，bij≤100。
```

输出描述：

```
输出1行1个整数代表答案。
```

示例1

输入例子：

```
5 5 2 4 4 3
2 1 1 3 1
1 4 2 3 1
4 4 4 2 1
3 1 1 2 4
5 1 5 5 1
5 3 4 1 3
1 1 2 2 2
2 1 4 4 5
1 1 5 3 3
3 2 1 3 3
```

输出例子：

```
3
```

------



1. 每次循环使用优先级队列pq维护的当前最近的点    
2. 并使用数组来记录已经遍历的结果，防止重复遍历。    
3. 一旦出现需要的结果立刻跳出循环。    



我本来是用DFS写的，但是用例 7/10超时。后来改成优先队列。

⚠️有个问题，我觉得横向和纵向的时间不是一回事，我用DFS就开了俩数组分别记录。而下面这个一视同仁，只开了一个数组也过了。有空再琢磨琢磨。

注意优先队列结构体运算符重载！

```c++
#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>
using namespace std;

int UD[2][2] = {{-1, 0}, {1, 0}};
int LR[2][2] = {{0, -1}, {0, 1}};

const int MAXN = 105;
const int MAXM = 105;

int visit[MAXN][MAXM];  // 刚到达时可以上下走
int a[MAXN][MAXM];
int b[MAXN][MAXM];

int n, m, sx, sy, tx, ty;
int res;

struct node{
    int t;
    int x;
    int y;
    node(){}
    node(int t, int x, int y):t(t), x(x), y(y){}
    bool operator< (const node &node) const  // t小的在前
    {
        return t > node.t;
    }
};

int main() {
    while(scanf("%d %d %d %d %d %d", &n, &m, &sx, &sy, &tx, &ty)!=EOF){
        sx -=1; sy-=1; tx-=1; ty-=1;
        // 初始化
        res = 0x7ffffff;
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++) {
                scanf("%d", &a[i][j]);
                visit[i][j] = 0x7ffffff;
            }
        }
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++) {
                scanf("%d", &b[i][j]);
            }
        }

        priority_queue<node>pq;
        pq.push({node(0, sx, sy)});
        int cx, cy, t;
        int newx, newy;
        while(!pq.empty()){
            node cur = pq.top();
            pq.pop();

            cx = cur.x;
            cy = cur.y;
            t = cur.t;
//            printf("%d %d | %d\n", cx, cy, t);

            if(cx == tx && cy == ty){
                res = t;
                break;
            }

            if(visit[cx][cy] < t)
                continue;
            visit[cx][cy] = t;

            int full = a[cx][cy] + b[cx][cy];  // 区间时间
            int time = t %(full);
            if(time < a[cx][cy]) {  // 当前红绿灯上下通行
                for(int i=0; i<2; i++){
                    newx = cx + UD[i][0];
                    newy = cy + UD[i][1];
                    if(newx < 0 || newx == n || newy <0 || newy ==m)
                        continue;
                    pq.push(node(t+1,newx, newy));  // 直接过
                }
                for(int i=0; i<2; i++){
                    newx = cx + LR[i][0];
                    newy = cy + LR[i][1];
                    if(newx < 0 || newx == n || newy <0 || newy ==m)
                        continue;
                    pq.push(node(t+ a[cx][cy] - time + 1,newx, newy));  // 等灯变
                }
            }
            else{
                for(int i=0; i<2; i++){
                    newx = cx + LR[i][0];
                    newy = cy + LR[i][1];
                    if(newx < 0 || newx == n || newy <0 || newy ==m)
                        continue;
                    pq.push(node(t+1,newx, newy));
                }
                for(int i=0; i<2; i++){
                    newx = cx + UD[i][0];
                    newy = cy + UD[i][1];
                    if(newx < 0 || newx == n || newy <0 || newy ==m)
                        continue;
                    pq.push(node(t+ full - time + 1,newx, newy));
                }
            }
        }
        cout<<res<<endl;

    }
}
```





## 查找&排序

## 双指针

## 数据结构

### 优先队列

#### <font color=red>【美团2021第10场】公司食堂</font>

```
小美和小团所在公司的食堂有N张餐桌，从左到右摆成一排，每张餐桌有2张餐椅供至多2人用餐，公司职员排队进入食堂用餐。小美发现职员用餐的一个规律并告诉小团：当男职员进入食堂时，他会优先选择已经坐有1人的餐桌用餐，只有当每张餐桌要么空着要么坐满2人时，他才会考虑空着的餐桌；

当女职员进入食堂时，她会优先选择未坐人的餐桌用餐，只有当每张餐桌都坐有至少1人时，她才会考虑已经坐有1人的餐桌；

无论男女，当有多张餐桌供职员选择时，他会选择最靠左的餐桌用餐。现在食堂内已有若干人在用餐，另外M个人正排队进入食堂，小团会根据小美告诉他的规律预测排队的每个人分别会坐哪张餐桌
```

**输入描述：**

```
第一行输入一个整数T（1<=T<=10），表示数据组数。每组数据占四行，第一行输入一个整数N（1<=N<=500000）；第二行输入一个长度为N且仅包含数字0、1、2的字符串，第i个数字表示左起第i张餐桌已坐有的用餐人数；第三行输入一个整数M（1<=M<=2N且保证排队的每个人进入食堂时都有可供选择的餐桌）；第四行输入一个长度为M且仅包含字母M、F的字符串，若第i个字母为M，则排在第i的人为男性，否则其为女性。
```

**输出描述：**

```
每组数据输出占M行，第i行输出一个整数j（1<=j<=N），表示排在第i的人将选择左起第j张餐桌用餐。
```

**示例1**

输入例子：

```
1
5
01102
6
MFMMFF
```

输出例子：

```
2
1
1
3
4
4
```



------

法一：小顶堆

使用三个小根堆，分别存储当前人数为0,1,2的三种桌子的桌号，记为pq0,pq1,pq2  

以男职员为例： 

1.    先尝试坐人数为1的桌子，该桌子人数就变成了2，等价于：将pq1的堆顶弹出，同时推入pq2    
2.    如果没有人数为1的桌子了，等价于pq1为空，就去坐人数为0的桌子，等价于：将pq0的堆顶弹出，同时推入pq1   

 因为桌号存储在优先队列，所以堆顶的桌号总是最小的，保证每个人有多个选择时优先坐最左边的桌子。 

 女职员同理。 

```c++
#include <iostream>
#include <algorithm>
#include <cstdlib>
#include <vector>
#include <map>
#include <string>
#include <queue>

using namespace std;

int main() {
    int t;
    cin>>t;
    while(t--) {
        int n;
        string pos;
        int m;
        string come;

        cin >> n >> pos >> m >> come;
        priority_queue<int, vector<int>, greater<int>> pq0;
        priority_queue<int, vector<int>, greater<int>> pq1;
        priority_queue<int, vector<int>, greater<int>> pq2;
        for(int i=0; i<n; i++){
            if(pos[i] == '0')
                pq0.push(i+1);
            else if(pos[i] == '1')
                pq1.push(i+1);
            else pq2.push(i+1);
        }

        int res[m];
        for(int i=0; i<m; i++){
            if(come[i] == 'M'){
                if(!pq1.empty()){
                    res[i] = pq1.top();
                    pq1.pop();
                    pq2.push(res[i]);
                }
                else{
                    res[i] = pq0.top();
                    pq0.pop();
                    pq1.push(res[i]);
                }
            }
            else{
                if(!pq0.empty()){
                    res[i] = pq0.top();
                    pq0.pop();
                    pq1.push(res[i]);
                }
                else{
                    res[i] = pq1.top();
                    pq1.pop();
                    pq2.push(res[i]);
                }
            }
        }
        for(int i=0; i<m; i++){
            printf("%d\\n", res[i]);
        }

    }
}
/*
1
5
01102
6
MFMMFF
 */
```

法二：模拟

用2个指针f0和f1维护当前最左边的坐了0个人的位置和坐了1个人的位置

```
for (int i = 0;i < N;++i) {
    if (f_zero != -1 && f_one != -1) break;
    else if (f_zero == -1 && desk[i] == '0') f_zero = i;
    else if (f_one == -1 && desk[i] == '1') f_one = i;
}
for (int i = 0;i < M;++i) {
    if (que[i] == 'M') {
        if (f_one < N) {
            printf("%d\n", f_one + 1);
            desk[f_one] = '2';
            while (f_one < N && desk[f_one] != '1') f_one++;
        }
        else {
            printf("%d\n", f_zero + 1);
            desk[f_zero] = '1';
            if (f_zero < f_one) f_one = f_zero;
            while (f_zero < N && desk[f_zero] != '0') f_zero++;
        }
    }
    else {
        if (f_zero < N) {
            printf("%d\n", f_zero + 1);
            desk[f_zero] = '1';
            if (f_zero < f_one) f_one = f_zero;
            while (f_zero < N && desk[f_zero] != '0') f_zero++;
        }
        else {
            printf("%d\n", f_one + 1);
            desk[f_one] = '2';
            while (f_one < N && desk[f_one] != '1') f_one++;
        }
    }
}
```





#### 【美团2021第6场】小团的装饰物2

滑动窗口

```
小团需要购买m样装饰物。商店出售n种装饰物，按照从小到大的顺序从左到右摆了一排。对于每一个装饰物，小团都给予了一个美丽值ai
小团希望购买的装饰物有着相似的大小，所以他要求购买的装饰物在商店中摆放的位置是连续的一段。小团还认为，一个装饰物的美丽值不能低于k，否则会不好看。
现在，请你计算小团有多少种不同的购买方案。
```

输入描述：

```
输入第一行包含三个数n, m, k接下来一行n个数，空格隔开，表示商店从左到右摆放的每个装饰物的美丽值。
```

输出描述：

```
输出一个数，表示小团购买的方案数。
```

示例1

输入例子：

```
8 2 5
5 5 5 4 5 5 5 5
```

输出例子：

```
5
```

例子说明：

```
有[1,2][2,3][5,6][6,7][7,8] 共5段
```

------

```
#include <iostream>
#include <cstring>
using namespace std;

int main() {
    int n, m, k;
    while (cin >> n >> m >>k){
        int a[n];
        int temp;
        for(int i=0; i <n; i++){
            cin>>temp;
            if(temp>=k)
                a[i] = 1;
            else a[i] = 0;
        }
        int res = 0;
        // 滑动窗口
        int l = 0; int r = l+m-1;
        int sum = 0;
        for(int i=l; i<r; i++){  // [l, r)的和
            sum += a[i];
        }

        while(r<n){
            sum+= a[r];
            if(sum>=m){
                res++;
            }
            sum-= a[l];
            l++;
            r++;
        }

        cout<<res<<endl;
    }
}
```







## 二叉树

## 并查集

## 动态规划

#### <font color=red>【美团2021第6场】填数游戏</font>

```
小团和小美正在玩一个填数游戏，这个游戏是给一个等式，其中有一些数被挖掉了，你需要向其中填数字，使得等式成立。
比如 ___+12=34，那么横线填的一定是22
现在，这个游戏到了最后一关，这一关的等式很奇特：_+_+_+...+_=n
这里可以填任意多个正整数（甚至可能是1个），只要这些数的和等于n即可。
但是，有一个额外的限制，填入的所有数必须小于等于k，大于等于1，填入的数的最大值必须大于等于d。
请你计算，有多少个不同的等式满足这些限制。由于答案可能很大，请将答案mod(998244353)后输出。
```

输入描述：

```
输入包含三个数n, k, d
```

输出描述：

```
输出包含一行，即方案数。
```

示例1

输入例子：

```
5 3 2
```

输出例子：

```
12
```

例子说明：

```
2+3=5
3+2=5
1+1+3=5
1+3+1=5
3+1+1=5
1+2+2=5
2+1+2=5
2+2+1=5
1+1+1+2=5
1+1+2+1=5
1+2+1+1=5
2+1+1+1=5
共12种填法
```

------

我本来想的是拆， i+j = n，然后dfs(i) 和 dfs(j)，后来要考虑的情况太多了。因为 i 可分解，j可分解，还要考虑i和j是否相等、i和j是否小于k，是否小于d。而且 i 和 j 的顺序也是可以调换的。



所以应当固定第一位置，然后拆分第二位置。

```
(1) 如果此时要填的数 j<d： 
因为凑成 i 没有使用大于等于 d 的数，那凑成 i-j 也没有使用大于等于 d 的数，dp[i][0]只会从dp[i-j][0]转移过来，dp[i][1]也只会从dp[i-j][1]转移过来。而这种填数游戏在 i-j 的填数方案已经确定的情况下，现在要填数 j 应该满足累加的原则，所以在遍历 j 时，j 每取一个值就把前面的方案数加一次，状态转移方程为： 
	dp[i][0] = dp[i][0] + ∑dp[i-j][0]  
	dp[i][1] = dp[i][1] + ∑dp[i-j][1]
	
(2) 如果此时要填的数 j>=d：因为现在要填的 j 已经满足大于等于 d 了，所以填数方案中至少得有一个数大于等于d的成就已经达成，凑成 i-j 有没有使用大于等于 d 的数已经不重要。此时只更新dp[i][1]，dp[i][1]可以从dp[i-j][0]和dp[i-j][1]两个状态转移过来，状态转移方程为：  
	dp[i][1] = dp[i][1] + ∑(dp[i-j][0]+dp[i-j][1])。  
```



dp\[i\]\[1\] 表示和为i，包含大于等于d的组合法，dp\[i\]\[0\]表示不包含。


```c++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int MAXN = 10005;
typedef long long ll;
const ll mod = 998244353;
ll dp[MAXN][2];  // dp[i][1] 表示和为i，包含大于等于d的组合法，dp[i][0]表示不包含
int n, k, d;

int main() {
    while (cin >> n >> k >> d) {
        memset(dp, 0, sizeof(dp));
        dp[0][0] = 1;

        for (int i = 1; i <= n; i++) {
            int bound = min(k, i);
            // 因为位置可以不一样，所以我们干脆还是遍历固定第一个数j，然后分解第二个位置
            // j + (i - j) = i
            // j + _ + ... + _ = i
            // 注意，我们已经固定j了！不要再考虑j的分解了
            for (int j = 1; j <= bound; j++) {
                if (j < d) {
                    dp[i][0] += dp[i - j][0];  // 要求的不包含d的组合i，那么 i-j也一定不包含
                    dp[i][0] %= mod;
                    dp[i][1] += dp[i - j][1];  // 要求 i-j 必须包含
                    dp[i][1] %= mod;
                } else {  // j 已经满足条件了，i-j无所谓
                    dp[i][1] += (dp[i - j][0] + dp[i - j][1]);
                    dp[i][1] %= mod;
                }
            }
        }
        cout<<dp[n][1]<<endl;
    }
}
```





### 子序列

#### <font color=blue>【美团2021第9场】回转寿司</font>

```
小美请小团吃回转寿司。转盘上有N盘寿司围成一圈，第1盘与第2盘相邻，第2盘与第3盘相邻，…，第N-1盘与第N盘相邻，第N盘与第1盘相邻。小团认为第i盘寿司的美味值为A[i]（可能是负值，如果小团讨厌这盘寿司）。现在，小团要在转盘上选出连续的若干盘寿司，使得这些寿司的美味值之和最大（允许不选任何寿司，此时美味值总和为0）。
```

输入描述：

```
第一行输入一个整数T（1<=T<=10），表示数据组数。每组数据占两行，第一行输入一个整数N（1<=N<=10^5）；第二行输入N个由空格隔开的整数，表示A[1]到A[N]（-10^4<=A[i]<=10^4）。
```

输出描述：

```
每组数据输出占一行，输出一个整数，表示连续若干盘寿司的美味值之和的最大值。
```

示例1

输入例子：

```
1
4
3 -2 4 -1
```

输出例子：

```
6
```

例子说明：

```
美味值之和最大连续若干盘寿司为第3盘、第4盘和第1盘。 
```



------

解答：

最大和和最小和，一定有一个是不需要旋转的。

首尾相连的情况，逆向思维，所有的值减最小值就是首尾相连的最大值

```
#include <iostream>
#include <cmath>
using namespace std;

int main() {
    int t;
    cin>>t;
    while(t--){
        int n;
        cin>>n;
        int a[n];
        int sum = 0;  // 总和
        for(int i=0; i<n; i++){
            cin>>a[i];
            sum+= a[i];
        }
        int dpMax[n];  // dpMax[i]表示以i为结尾的最大子序列和（无旋转）
        int dpMin[n];
        dpMax[0] = a[0];
        dpMin[0] = a[0];
        int maxx = -1;
        int minx = 0x7fffff;
        for(int i=1; i<n; i++){
            dpMax[i] = a[i] + max(0, dpMax[i-1]);
            maxx = max(maxx, dpMax[i]);
            dpMin[i] = a[i] + min(0, dpMin[i-1]);
            minx = min(minx, dpMin[i]);
        }
        // 结果就两种，有旋转最大和无旋转最大
        // 如果有旋转最大，那么最小子序列就一定是无旋转的，所以可以用总和减去最小子序列
        cout<< max(maxx, sum-minx) << endl;
    }
    
}
```





#### 【美团2021第8场】偏爱字母

```
小美喜欢字母E，讨厌字母F。在小美生日时，小团送了小美一个仅包含字母E和F的字符串，小美想从中选出一个包含字母E数量与字母F数量之差最大的子串。

*子串：从字符串前面连续删去若干个字符，从后面连续删去若干个字符剩下的字符串（也可以一个都不删），例如abcab是fabcab的子串，而不是abcad的子串。我们将空串看作所有字符串的子串。
```

输入描述：

```
第一行一个正整数n表示字符串的长度。第二行长度为n，且仅包含大写字母’E’,’F’的字符串（不含引号） 
```

输出描述：

```
输出一个整数，表示最大的差值
```

示例1

输入例子：

```
5
EFEEF
```

输出例子：

```
2
```

例子说明：

```
选择子串EE,此时有2个E，0个F,有最大差值2-0=2另外，选择子串EFEE也可以达到最大差值。
```



------

一看“连续子串”，不是双指针就是dp...

E是加分，F是扣分，E和F的数量差不就是这个子串的得分吗。所以转化成子串最大和

```
#include <iostream>
#include <map>
using namespace std;

map<char, int>ch2int;

int main() {
    int n;
    ch2int['E'] = 1;
    ch2int['F'] = -1;
    while(cin>>n){
        int dp[n];
        string str;
        cin>>str;
        dp[0] = ch2int[str[0]];
        int maxx = dp[0];
        for(int i=i; i<n; i++){
            dp[i] = ch2int[str[i]] + max(dp[i-1], 0);
            maxx = max(dp[i], maxx);
        }
        cout<<maxx<<endl;
    }
}
// 64 位输出请用 printf("%lld")
```





### 背包

#### <font color=red>【美团2021第6场】密室闯关</font>

```
小团和小美正在密室中解密。他们现在来到了一个新的关卡面前。这一关是一个配合关卡，有n个巨大的齿轮摆成一排，每个齿轮上有两个按钮和按顺时针排成一环的26个大写字母。在齿轮的最上面有一个孔，透过孔可以看到齿轮最上方的字母。
小团发现，每次他可以按住一个齿轮的一个按钮，小美就可以顺时针移动这个齿轮，使得孔里看到的字母变为其对应的下一个字母（比如A变为B，Y变为Z），并且如果小团按下的第一个按钮，则齿轮与上一个齿轮咬合，上一个齿轮的能看见的字母会变为其减1的字母（即B变为A，Z变为Y），进行这个操作的时候，不会影响上一个齿轮之前的齿轮。如果小团按下的第二个按钮，则下一个齿轮能看见的字母会变为其减1的字母，同样，这个操作不会影响下一个齿轮之后的齿轮。
如果这个齿轮是第一个齿轮，或者上一个齿轮的字母为A，小团按下第一个按钮后小美将不能移动。同理，如果这个齿轮是最后一个齿轮，或者下一个齿轮的字母为A，小团按下第二个按钮后小美将不能移动。
如果该齿轮上的字母是Z，该齿轮按下按钮后也不能移动。这个齿轮组的某个状态所组成的字符串将会是通关密码。
现在，小团想计算出可以变化出多少种齿轮的组合，他会依据这个数字来计算是否可以暴力计算出密码。请你帮助他。
```

输入描述：

```
输入包含多组数据。对于每组数据，将会输入两行。第一行会输入一个数n，代表齿轮的个数。接下来一行n个大写字母，代表每个齿轮最开始能看见的字母。
```

输出描述：

```
对于每组数据，输出一行一个数字，代表密码可能的组合数，对998244353取模。
```

示例1

输入例子：

```
2
BB
3
ABA
```

输出例子：

```
3
3
```

例子说明：

```
对于样例1,有以下三种最终可能的组合：AC,BB,CA
对于样例2,有以下三种最终可能的组合：BAA,ABA,AAB
```

------



本问题的实质是将 a-z 视为 0-25 的数字，然后只有两种操作： 
1、a[i] += 1 并且 a[i - 1] -= 1
2、a[i - 1] += 1 并且 a[i] -= 1

操作的前提是不能让 a[i] 小于 0 或者 大于 25 
此处可以发现，无论执行多少次操作，都不会对整个串的权值和造成影响。 
比如 ABA = 0+1+0 = 1，能从 ABA 转化的 AAB 和 BAA 的权值都是 1。 

也就是说 状态 x 能转移到的 状态集合 s 具有权值和相同的特点。 

⭐️为了统计 x 能达到多少个状态，也就是统计状态集合 s 的大小，同样也是统计 s 相对应的 sum 可能出现多少次 

那么这个问题就变成了用 n 个 0-25 的数字，凑成和为 sum 的方案数 

题目中明确了多组数据，那么显然每次都使用非记忆的 DFS 是不合理的，必须在输入前进行预处理，将所有的 {n, sum} 数对都处理出来，然后每次询问 O1 得到就行了 



```c++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int MAXN = 105;
const int MAXSUM = 25*MAXN;

long long dp[MAXN+1][MAXSUM+1];  // dp[i][j] 表示 有i个位置（每个位置为 [0. 25]），总和为j的方案数。
long long mod = 998244353;

void init(){
    // 转换成背包问题，现在已经和a没关系了。
    // 相当于有n个位置，每个位置都可以选 [0, 25]
    // 为了方便，位置的首位为1
    memset(dp, 0, sizeof(dp));
    dp[0][0] = 1;

    for(int i=1; i<=MAXN; i++){
        dp[i][0] = 1;
        for(int j=1; j<=MAXSUM; j++){
            for(int k=0; k<=25; k++){  // 当前位置的取值
                if(j-k>=0){
                    dp[i][j] += dp[i-1][j-k];
                    dp[i][j] %= mod;
                }
            }
        }

    }
}


int main(){
    int n;
    string str;
    init();
    while(scanf("%d", &n) != EOF){
        cin>>str;
        int a[n];
        int sum = 0;
        for(int i=0; i<n; i++){
            a[i] = str[i] - 'A';
            sum += a[i];
        }

        cout<<dp[n][sum]<<endl;
    }
}
```



### 状态压缩

### 树形DP

#### <font color=red>【美团2021第10场】最优二叉树II</font>

```
小团有一个由N个节点组成的二叉树，每个节点有一个权值。定义二叉树每条边的开销为其两端节点权值的乘积，二叉树的总开销即每条边的开销之和。小团按照二叉树的中序遍历依次记录下每个节点的权值，即他记录下了N个数，第i个数表示位于中序遍历第i个位置的节点的权值。之后由于某种原因，小团遗忘了二叉树的具体结构。在所有可能的二叉树中，总开销最小的二叉树被称为最优二叉树。现在，小团请小美求出最优二叉树的总开销。
```

输入描述：

```
第一行输入一个整数N（1<=N<=300），表示二叉树的节点数。第二行输入N个由空格隔开的整数，表示按中序遍历记录下的各个节点的权值，所有权值均为不超过1000的正整数。
```

输出描述：

```
输出一个整数，表示最优二叉树的总开销。
```

**示例1**

![img](https://uploadfiles.nowcoder.com/images/20210208/310922_1612799416933/49754179E8857A76EAF13CD0D08FCBA5)

输入例子：

```
5
7 6 5 1 3
```

输出例子：

```
45
```

例子说明：

```
总开销为7*1+6*5+5*1+1*3=45。
```



------

我们初始化一个虚拟根（权值为0），把整个过程看成不断切割区间选出子根，与当前已知根相连。

例如：本题 [0, n-1] 的最优开销，相当于从 [0, n-1] 中选出一个子根 i，变成：

<u>以i为根的左子树[l, i-1] 开销</u> + <u>以i为根的右子树[i+1, r]开销</u> + <u>根i * 已知根</u>

假如 dp\[l\]\[r\]\[root\] 表示已知根为 root，[l, r] 的最优开销，那么：

```
dp[l][r][root] = 选出一个i => dp[l][i-1][i] + dp[i+1][r][i] + weight[i] * weight[root]
```



```
#include <iostream>
#include <vector>
#include <map>
#include <cstring>
using namespace std;

const int MAXN = 305;
int weight[MAXN];
int dp[MAXN][MAXN][MAXN];  // dp[l][r][root]

int dfs(int l, int r, int root){  // 在 [l, r]区间内，以root为根节点的最优子树值
    if(l>r) return 0;
    if(dp[l][r][root]!= -1) return dp[l][r][root];

    int temp = 0x7ffffff;
    // 在 [l, r] 区间内，选择一个次根节点，与 root相连。
    // 所以 以root为根节点的最优子树值 = 次根及其左子树最优值 + 次根及其右子树最优值 + 次根与root边权
    for(int i=l; i<=r; i++){
        // 以i为根节点，分成 [l, i-1] 和 [i+1, r]
        int left = dfs(l, i-1, i);
        int right = dfs(i+1, r, i);
        // 边界情况就是 dfs(x, x, x+-1)，他们返回的就是 weight[x]*weight[x+-1]
        temp = min(temp, left+right+weight[i]*weight[root]);
    }
//    cout<<l<<" "<<r<<" "<<root<<" | "<<temp<<endl;
    dp[l][r][root] = temp;
    return temp;

}

int main(){
    int n;
    while(cin>>n){
        for(int i=0; i<n; i++){
            cin>>weight[i];
        }

        memset(dp, -1, sizeof(dp));
        int res;
        // 结果相当于从 [0, n-1] 区间内选出一个次根，然后次根与0相乘。
        weight[n] = 0;
        res = dfs(0, n-1, n);

        cout<<res<<endl;
    }
}
```



## 字符串



## 图论

### 树

#### <font color=blue>【美团2021第7场】小美的美丽树</font>



```
小美在观察一棵美丽的无根树。

小团问小美：“小美，我考考你，如果我选一个点为根，你能不能找出子树大小不超过K的前提下，子树内最大值和最小值差最大的子树的根是哪个点？多个点的话你给我编号最小的那个点就行了。”

小美思索一番，说这个问题难不倒他。
```

输入描述：

```
第一行两个正整数N和K，表示全树有N个节点，要求子树大小不超过K。第二行是N个正整数空格分隔，表示每个点的点权。以点编号从1到N的顺序给出点权。接下来N-1行每行两个正整数表示哪两个点之间有边相连。最后一行一个正整数root表示小团所选的根节点编号为root。
```

输出描述：

```
一行，一个正整数，含义如问题描述，输出在子树大小不超过K的前提下，子树内最大值和最小值差最大的子树的根的编号
```

示例1

输入例子：

```
5 2
1 3 2 4 5
1 2
2 3
3 4
4 5
3
```

输出例子：

```
2
```

------

一开始我没读懂题，以为子树大小不超过K是指，一个子树区域（不一定到叶子节点）的节点小于K，不会做。后来发现意思很简单，就是一当前节点为根的子树，所有元素不超过K。

那就是先无根树转有根树，再DFS。

维护几个数组：weight（输入自带），num（当前节点的子树节点总数），maxV（当前节点的子树最大值），minV

一开始初始化 num[i] = 1, maxV[i] = weight[i], minV[i] = weight[i]

然后遍历自己的所有孩子（注意不要重复搜索），然后根据孩子的信息更新上面的数组。

```c++
#include <iostream>
#include <vector>
#include <map>
#include <cstring>
using namespace std;

const int MAXN = 100005;
int weight[MAXN + 1];
map<int, vector<int>>g;
int num[MAXN + 1]; // num[i]表示以i为根的子树的节点个数
int maxV[MAXN + 1]; // maxV[i]表示以i为根的子树里最大值
int minV[MAXN + 1];
int n, k;
int maxDiff;
int res;

void dfs(int root) {
    if (num[root]) return; // 已访问

    num[root] = 1;  // 自己
    maxV[root] = weight[root];
    minV[root] = weight[root];

    for (int i = 0; i < g[root].size(); i++) { // 总结所有孩子信息
        int child = g[root][i];
        dfs(child);
        num[root] += num[child];
        maxV[root] = max(maxV[root], maxV[child]);
        minV[root] = min(minV[root], minV[child]);
    }

    int diff = maxV[root] - minV[root];
//    cout<< root << " " << num[root] << " " << diff<<endl;
    if (num[root] <= k && diff >= maxDiff) {
        if (diff == maxDiff)
            res = min(res, root);
        else {
            res = root;
            maxDiff = diff;
        }
    }
}

void clean(int root) {
    if (!g[root].empty()) {
        for (int i = 0; i < g[root].size(); i++) {
            int child = g[root][i];
            for (auto it = g[child].begin(); it != g[child].end(); it++) {
                if (*it == root) {  // 删除指向父节点的
                    g[child].erase(it);
                    break;
                }
            }
            clean(child);
        }
    }
}

int main() {
    while (scanf("%d %d", &n, &k) != EOF) {
        for (int i = 0; i < n; i++) {
            cin >> weight[i + 1];
        }
        int x, y;
        g.clear();
        for (int i = 0; i < n - 1; i++) {
            cin >> x >> y;
            g[x].push_back(y);
            g[y].push_back(x);
        }
        int root;
        cin >> root;
        clean(root);  // 转有向图
        memset(num, 0, sizeof(num));
        maxDiff = -1;
        dfs(root);
        cout << res << endl;
    }
}
// 64 位输出请用 printf("%lld")
```





### 最小生成树

### 最短路径

### 拓扑排序

### 关键路径

### 二分图



## 贪心

#### 【美团2021第8场】搭配出售

```
服装店新进了a条领带，b条裤子，c个帽子，d件衬衫，现在要把这些搭配起来售卖。有三种搭配方式，一条领带和一件衬衫，一条裤子和一件衬衫，一个帽子和一件衬衫。卖出一套领带加衬衫可以得到e元，卖出一套裤子加衬衫可以得到f元，卖出一套帽子加衬衫可以得到g元。现在你需要输出最大的获利方式
```

输入描述：

```
第一行两个正整数N，M，Q，表示小美书架有N行编号1到N，书本编号从1到M，接下来有Q个操作接下来Q行，每行是下列操作中的一种：1 x y : x是书本的编号，y是书架的行编号，代表小美将编号为x的书本放置到y行上。若该书本在小团手上则放置无效，若原来该书在书架上且原行上锁则放置无效，若该书被放置到一个锁了的行上则放置无效。2 y : y是书架的行编号，代表小美将行编号为y的书架加锁，对已经上锁的书架行该操作无效。3 y : y是书架的行编号，代表小美将行编号为y的书架锁去掉，对无锁的书架行该操作无效。4 x : x是书本的编号，代表小团想借编号为x的书本，对该操作若可以借到输出一行正整数在哪一行，借不到输出一行-15 x : x是书本的编号，代表小团还回来编号为x的书本。若该书本不在小团手上该操作无效。
```

输出描述：

```
对于每个操作4，若可以借到输出一行正整数在哪一行，借不到输出一行-1
```

示例1

输入例子：

```
5 5 10
1 1 4
1 2 3
1 3 1
2 1
4 1
5 2
4 3
4 5
3 1
4 2
```

输出例子：

```
4
-1
-1
3
```

------

简单贪心。直接按价格从高到低排序卖出。此外卡大数。

```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

struct node{
    long long num;
    long long value;
    node(){}
    node(long long n, long long v): num(n), value(v){}
};

bool cmp(node x, node y){
    return x.value > y.value;
}

int main() {
    long long a, b,c,d,e,f,g;
    while(scanf("%lld %lld %lld %lld %lld %lld %lld", &a, &b, &c, &d, &e, &f, &g)!=EOF){
        vector<node> vec{node(a,e), node(b,f), node(c,g)};
        if(d>=a+b+c){
            cout<< a*e+b*f+c*g<<endl;
            continue;
        }
        long long res = 0;
        sort(vec.begin(), vec.end(), cmp);
        // 贪心
        while(d){
            if(d>= vec[0].num){
                res += vec[0].num * vec[0].value;
                d-=vec[0].num;
                vec.erase(vec.begin());
            }
            else{
                res += vec[0].value * d;
                break;
            }
        }
        cout<<res<<endl;


    }
}
// 64 位输出请用 printf("%lld")
```





## 分治

## 数学

### 数论

### 组合数学

### 高精度

### 进制转换

### 位运算

