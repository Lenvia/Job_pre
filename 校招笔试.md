# 校招笔试

# 链接映射

[【美团2021第10场】](https://www.nowcoder.com/exam/test/68952198/submission?examPageSource=Company&pid=28665343&testCallback=https%3A%2F%2Fwww.nowcoder.com%2Fexam%2Fcompany%3FcurrentTab%3Drecommand%26jobId%3D100%26selectStatus%3D0%26tagIds%3D652,665,138,179,134,139,239,151,898,147,931,9079,1000000&testclass=%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91)





------



## 链表

## 查找

## 搜索

### DFS

### BFS

## 查找&排序

## 双指针

## 数据结构

### 优先队列

#### <font color=red>【美团2021第10场】公司食堂</font>

小美和小团所在公司的食堂有N张餐桌，从左到右摆成一排，每张餐桌有2张餐椅供至多2人用餐，公司职员排队进入食堂用餐。小美发现职员用餐的一个规律并告诉小团：当男职员进入食堂时，他会优先选择已经坐有1人的餐桌用餐，只有当每张餐桌要么空着要么坐满2人时，他才会考虑空着的餐桌；

当女职员进入食堂时，她会优先选择未坐人的餐桌用餐，只有当每张餐桌都坐有至少1人时，她才会考虑已经坐有1人的餐桌；

无论男女，当有多张餐桌供职员选择时，他会选择最靠左的餐桌用餐。现在食堂内已有若干人在用餐，另外M个人正排队进入食堂，小团会根据小美告诉他的规律预测排队的每个人分别会坐哪张餐桌

**输入描述：**

```
第一行输入一个整数T（1<=T<=10），表示数据组数。每组数据占四行，第一行输入一个整数N（1<=N<=500000）；第二行输入一个长度为N且仅包含数字0、1、2的字符串，第i个数字表示左起第i张餐桌已坐有的用餐人数；第三行输入一个整数M（1<=M<=2N且保证排队的每个人进入食堂时都有可供选择的餐桌）；第四行输入一个长度为M且仅包含字母M、F的字符串，若第i个字母为M，则排在第i的人为男性，否则其为女性。
```

**输出描述：**

```
每组数据输出占M行，第i行输出一个整数j（1<=j<=N），表示排在第i的人将选择左起第j张餐桌用餐。
```

**示例1**

```
输入例子：
1
5
01102
6
MFMMFF
输出例子：
2
1
1
3
4
4
```

法一：小顶堆

使用三个小根堆，分别存储当前人数为0,1,2的三种桌子的桌号，记为pq0,pq1,pq2  

以男职员为例： 

1.    先尝试坐人数为1的桌子，该桌子人数就变成了2，等价于：将pq1的堆顶弹出，同时推入pq2    
2.    如果没有人数为1的桌子了，等价于pq1为空，就去坐人数为0的桌子，等价于：将pq0的堆顶弹出，同时推入pq1   

 因为桌号存储在优先队列，所以堆顶的桌号总是最小的，保证每个人有多个选择时优先坐最左边的桌子。 

 女职员同理。 

```c++
#include <iostream>
#include <algorithm>
#include <cstdlib>
#include <vector>
#include <map>
#include <string>
#include <queue>

using namespace std;

int main() {
    int t;
    cin>>t;
    while(t--) {
        int n;
        string pos;
        int m;
        string come;

        cin >> n >> pos >> m >> come;
        priority_queue<int, vector<int>, greater<int>> pq0;
        priority_queue<int, vector<int>, greater<int>> pq1;
        priority_queue<int, vector<int>, greater<int>> pq2;
        for(int i=0; i<n; i++){
            if(pos[i] == '0')
                pq0.push(i+1);
            else if(pos[i] == '1')
                pq1.push(i+1);
            else pq2.push(i+1);
        }

        int res[m];
        for(int i=0; i<m; i++){
            if(come[i] == 'M'){
                if(!pq1.empty()){
                    res[i] = pq1.top();
                    pq1.pop();
                    pq2.push(res[i]);
                }
                else{
                    res[i] = pq0.top();
                    pq0.pop();
                    pq1.push(res[i]);
                }
            }
            else{
                if(!pq0.empty()){
                    res[i] = pq0.top();
                    pq0.pop();
                    pq1.push(res[i]);
                }
                else{
                    res[i] = pq1.top();
                    pq1.pop();
                    pq2.push(res[i]);
                }
            }
        }
        for(int i=0; i<m; i++){
            printf("%d\\n", res[i]);
        }

    }
}
/*
1
5
01102
6
MFMMFF
 */
```

法二：模拟

用2个指针f0和f1维护当前最左边的坐了0个人的位置和坐了1个人的位置

```
for (int i = 0;i < N;++i) {
    if (f_zero != -1 && f_one != -1) break;
    else if (f_zero == -1 && desk[i] == '0') f_zero = i;
    else if (f_one == -1 && desk[i] == '1') f_one = i;
}
for (int i = 0;i < M;++i) {
    if (que[i] == 'M') {
        if (f_one < N) {
            printf("%d\n", f_one + 1);
            desk[f_one] = '2';
            while (f_one < N && desk[f_one] != '1') f_one++;
        }
        else {
            printf("%d\n", f_zero + 1);
            desk[f_zero] = '1';
            if (f_zero < f_one) f_one = f_zero;
            while (f_zero < N && desk[f_zero] != '0') f_zero++;
        }
    }
    else {
        if (f_zero < N) {
            printf("%d\n", f_zero + 1);
            desk[f_zero] = '1';
            if (f_zero < f_one) f_one = f_zero;
            while (f_zero < N && desk[f_zero] != '0') f_zero++;
        }
        else {
            printf("%d\n", f_one + 1);
            desk[f_one] = '2';
            while (f_one < N && desk[f_one] != '1') f_one++;
        }
    }
}
```



## 二叉树

## 并查集

## 动态规划

### 子序列

#### ⭐️【美团2021第9场】回转寿司

最大和和最小和，一定有一个是不需要旋转的。

首尾相连的情况，逆向思维，所有的值减最小值就是首尾相连的最大值



### 背包

### 状态压缩

### 树形DP

#### ❌【美团2021第10场】最优二叉树II

小团有一个由N个节点组成的二叉树，每个节点有一个权值。定义二叉树每条边的开销为其两端节点权值的乘积，二叉树的总开销即每条边的开销之和。小团按照二叉树的中序遍历依次记录下每个节点的权值，即他记录下了N个数，第i个数表示位于中序遍历第i个位置的节点的权值。之后由于某种原因，小团遗忘了二叉树的具体结构。在所有可能的二叉树中，总开销最小的二叉树被称为最优二叉树。现在，小团请小美求出最优二叉树的总开销。

输入描述：

```
第一行输入一个整数N（1<=N<=300），表示二叉树的节点数。第二行输入N个由空格隔开的整数，表示按中序遍历记录下的各个节点的权值，所有权值均为不超过1000的正整数。
```

输出描述：

```
输出一个整数，表示最优二叉树的总开销。
```

**示例1**

![img](https://uploadfiles.nowcoder.com/images/20210208/310922_1612799416933/49754179E8857A76EAF13CD0D08FCBA5)

```
输入例子：
5
7 6 5 1 3
输出例子：
45
例子说明：
总开销为7*1+6*5+5*1+1*3=45。
```





## 字符串

## 分治

## 数学

### 数论

### 组合数学

### 高精度

### 进制转换

### 位运算

## 图论

### 最小生成树

### 最短路径

### 拓扑排序

### 关键路径

### 二分图