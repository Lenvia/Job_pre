# 链接

[【美团2021第10场】](https://www.nowcoder.com/exam/test/68952198/submission?examPageSource=Company&pid=28665343&testCallback=https%3A%2F%2Fwww.nowcoder.com%2Fexam%2Fcompany%3FcurrentTab%3Drecommand%26jobId%3D100%26selectStatus%3D0%26tagIds%3D652,665,138,179,134,139,239,151,898,147,931,9079,1000000&testclass=%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91)

[【美团2021第9场】](https://www.nowcoder.com/exam/test/68955630/submission?pid=28665338&pageSource=testHistory)

------

# 题目

## 暴力 & 模拟

#### 【美团2021第8场】小美的书架

```
小美的书架上有很多书。小美是个爱读书的新时代好青年。
小团虽然也喜欢看书，但小团大多数时候都更喜欢来小美家蹭书读。
这就导致小美的书架上很多书都会被小团借走。
小美很烦这一点，就想出了一个招数，小美的书架是一行一行的，他会对一些行加锁，这样小团就借不走了。
现在小团想要借书，请你帮忙看看小团能不能借到书，如果可以借到的话在哪一行书架上有这本书。
为了简单起见，每本书将用一个正整数进行编号，小美的书架一共有N行。
```

输入描述：

```
第一行两个正整数N，M，Q，表示小美书架有N行编号1到N，书本编号从1到M，接下来有Q个操作接下来Q行，每行是下列操作中的一种：1 x y : x是书本的编号，y是书架的行编号，代表小美将编号为x的书本放置到y行上。若该书本在小团手上则放置无效，若原来该书在书架上且原行上锁则放置无效，若该书被放置到一个锁了的行上则放置无效。2 y : y是书架的行编号，代表小美将行编号为y的书架加锁，对已经上锁的书架行该操作无效。3 y : y是书架的行编号，代表小美将行编号为y的书架锁去掉，对无锁的书架行该操作无效。4 x : x是书本的编号，代表小团想借编号为x的书本，对该操作若可以借到输出一行正整数在哪一行，借不到输出一行-15 x : x是书本的编号，代表小团还回来编号为x的书本。若该书本不在小团手上该操作无效。
```

输出描述：

```
对于每个操作4，若可以借到输出一行正整数在哪一行，借不到输出一行-1
```

示例1

输入例子：

```
5 5 10
1 1 4
1 2 3
1 3 1
2 1
4 1
5 2
4 3
4 5
3 1
4 2
```

输出例子：

```
4
-1
-1
3
```



------

水题，不过注意如果只是用map来判断存在，

例如 map<int, bool>have，最好用 if(have[x]) 而不是 if(have.count(x)) 和 have.erase(x)操作，可能有越界。

```
#include <iostream>
#include <map>
#include <vector>
#include <cstring>
using namespace std;

int main() {
    int n,m,q;
    while(scanf("%d %d %d", &n, &m, &q)!=EOF){
        map<int, bool>lock;
        map<int, int>store;  // 书->行
        map<int, bool>have;  // 借到的书
        int op;
        int x, y;
        while(q--){
            cin>>op;
            switch (op) {
                case 1:  // 放书
                    cin>>x>>y;
                    if(have[x] || (store[x] && lock[store[x]]) || lock[y])
                        break;
                    store[x] = y;
                    break;
                case 2:  // 加锁
                    cin>>y;
                    lock[y] = true;
                    break;
                case 3:  // 解锁
                    cin>>y;
                    lock[y] = false;
                    break;
                case 4:  // 借书
                    cin>>x;
                    if(store[x] && !lock[store[x]]){  // 有书且没上锁
                        have[x] = true;
                        cout<<store[x]<<endl;
                        store[x] = false;
                    }
                    else cout<<-1<<endl;
                    break;
                case 5:  // 还书
                    cin>>x;
                    if(!have[x]) break;
                    have[x] = false;
                    break;
            }
        }
    }
}
```



## 链表

## 查找

## 搜索

### DFS

### BFS

#### 【美团2021第9场】神秘的苹果树

```
小团找到一颗有n个节点的苹果树，以1号节点为根，且每个节点都有一个苹果，苹果都有一个颜色，但是这棵树被施加了咒术，这使得小团只能从某一个节点的子树中选取某一种颜色的拿。小团想要拿到数量最多的那种颜色的所有苹果，请帮帮她。每次她会指定一个节点t，如果小团只能从节点t的子树中选取某一种颜色的苹果，选取什么颜色能拿到最多的苹果？如果有多种颜色都可以拿同样多的苹果，输出颜色编号最小的那个对应的编号。

节点x的子树定义为所有将x当作祖先的节点，x也视为x的子树的一部分。
```

输入描述：

```
第一行一个正整数n表示这颗树上节点的个数。接下来n-1行，每行两个正整数x­­i,yi,表示树上第i条边连接的两个节点。接下来一行n个正整数c_i，分别表示从1~n号节点上的苹果的颜色。接下来一行一个正整数q,表示接下来有q次独立的询问。接下来q行，每行一个正整数t表示询问：如果小团只能从节点t的子树中选取某一种颜色的苹果，选取什么颜色能拿到最多的苹果？如果有多种颜色都可以拿同样多的苹果，输出颜色编号最小的那个对应的编号。      对于100%的数据n≤5000, 1≤xi,yi,t≤n, ci≤1000000000,q≤1000
```

输出描述：

```
输出q行，每行一个整数，表示答案。   
```

示例1

输入例子：

```
7
1 2
1 3
2 4
2 5
3 6
3 7
1 1 2 1 2 2 3
7
1
2
3
4
5
6
7
```

输出例子：

```
1
1
2
1
2
2
3
```

------

题目中只告诉我们1为根节点，因此在输入两个有边相连的节点时，我们并不知道哪个是父节点哪个是子节点，需要先构建无向图的邻接表。然后从根节点1开始，自顶向下删去子节点指向父节点的关系，将无向图修改为有向图。 

在每次query的过程中，利用bfs求得每个节点 **t** 的子树对应的所有节点，然后对节点颜色进行计数，输出出现最多且编号最小的颜色即可。 

```
#include <iostream>
#include <map>
#include <vector>
#include <cstring>
#include <queue>
using namespace std;

const int MAXN = 5005;
int color[MAXN+5];
map<int, vector<int>>g;
map<int, int>cnt;  // 颜色

void bfs(int node){  // bfs遍历当前树
    queue<int> q;
    q.push(node);
    while(!q.empty()){
        int cur = q.front();
        q.pop();
        cnt[color[cur]]++;
        for(int i=0; i<g[cur].size(); i++){
            q.push(g[cur][i]);
        }
    }

}

void clean(int root){  // 无向图转有向图
    if(g[root].size()>0){
        for(int i=0; i<g[root].size(); i++){
            int node = g[root][i];
            for(auto it=g[node].begin(); it!=g[node].end(); it++){
                if(*it == root){  // 删除指向父节点的
                    g[node].erase(it);
                    break;
                }
            }
            clean(node);  // 递归删除
        }
    }
}

int main() {
    int n;
    while(scanf("%d", &n)!=EOF){
        int x, y;
        g.clear();
        for(int i=0; i<n-1; i++){
            scanf("%d %d", &x, &y);
            g[x].push_back(y);
            g[y].push_back(x);
        }
        clean(1);  // 转有向图
        for(int i=1; i<=n; i++){
            cin>>color[i];
        }
        int q;
        cin>>q;
        int start;
        while(q--){
            cin>>start;
            cnt.clear();
            bfs(start);

            // 排序
            int maxx = -1;
            int clr = 0;
            for(auto it = cnt.begin(); it!=cnt.end(); it++){
                if(it->second > maxx){
                    maxx = it->second;
                    clr = it->first;
                }
            }
            cout<<clr<<endl;
            
        }

    }
}
// 64 位输出请用 printf("%lld")
```



#### 【美团2021第8场】十字路口

```
在小美和小团生活的城市中，有n行m列共计n*m个十字路口，第i行j列的十字路口有两个属性aij，b­ij。当行人处在i行j列的路口，对于任意非负整数k:
当时间处在[k*aij+k*bij), (k+1)*aij+k*bij)时，行人可以选择走到i±1行j列的路口。
当时间处在[(k+1)*aij+k*bij), (k+1)*aij+(k+1)*bij)时，行人可以选择走到i行j±1列的路口。
每次移动花费的时间为1，且要保证将要去的十字路口存在，即属于n*m个路口当中。可以选择原地静止不动。
在第0时刻，小美处在xs行ys列的十字路口处，要去xt行yt列的十字路口找小团。小团原地不动等小美，请问小美所花费的时间最少是多少
```

输入描述：

```
第一行六个正整数n，m，xs，ys，xt，yt，含义如上文所示。以样例第一行【5、5、2、4、4、3】 共计6个数字为例，前两位数字代表有5*5的二维数组，三、四位数字代表小美处在2行4列的十字路口处，五、六位数字代表要去4行3列的十字路口找小团。接下来n行每行m个正整数，在样例中为第一个5*5的二维数组，第i行第j个数代表i行j列十字路口的属性aij。接下来n行每行m个正整数，在样例中为第二个5*5的二维数组，第i行第j个数代表i行j列十字路口的属性bij。对于100%的数据，1≤n，m，xs，ys，xt，yt，aij，bij≤100。
```

输出描述：

```
输出1行1个整数代表答案。
```

示例1

输入例子：

```
5 5 2 4 4 3
2 1 1 3 1
1 4 2 3 1
4 4 4 2 1
3 1 1 2 4
5 1 5 5 1
5 3 4 1 3
1 1 2 2 2
2 1 4 4 5
1 1 5 3 3
3 2 1 3 3
```

输出例子：

```
3
```

------



1. 每次循环使用优先级队列pq维护的当前最近的点    
2. 并使用数组来记录已经遍历的结果，防止重复遍历。    
3. 一旦出现需要的结果立刻跳出循环。    



我本来是用DFS写的，但是用例 7/10超时。后来改成优先队列。

⚠️有个问题，我觉得横向和纵向的时间不是一回事，我用DFS就开了俩数组分别记录。而下面这个一视同仁，只开了一个数组也过了。有空再琢磨琢磨。

注意优先队列结构体运算符重载！

```c++
#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>
using namespace std;

int UD[2][2] = {{-1, 0}, {1, 0}};
int LR[2][2] = {{0, -1}, {0, 1}};

const int MAXN = 105;
const int MAXM = 105;

int visit[MAXN][MAXM];  // 刚到达时可以上下走
int a[MAXN][MAXM];
int b[MAXN][MAXM];

int n, m, sx, sy, tx, ty;
int res;

struct node{
    int t;
    int x;
    int y;
    node(){}
    node(int t, int x, int y):t(t), x(x), y(y){}
    bool operator< (const node &node) const  // t小的在前
    {
        return t > node.t;
    }
};

int main() {
    while(scanf("%d %d %d %d %d %d", &n, &m, &sx, &sy, &tx, &ty)!=EOF){
        sx -=1; sy-=1; tx-=1; ty-=1;
        // 初始化
        res = 0x7ffffff;
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++) {
                scanf("%d", &a[i][j]);
                visit[i][j] = 0x7ffffff;
            }
        }
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++) {
                scanf("%d", &b[i][j]);
            }
        }

        priority_queue<node>pq;
        pq.push({node(0, sx, sy)});
        int cx, cy, t;
        int newx, newy;
        while(!pq.empty()){
            node cur = pq.top();
            pq.pop();

            cx = cur.x;
            cy = cur.y;
            t = cur.t;
//            printf("%d %d | %d\n", cx, cy, t);

            if(cx == tx && cy == ty){
                res = t;
                break;
            }

            if(visit[cx][cy] < t)
                continue;
            visit[cx][cy] = t;

            int full = a[cx][cy] + b[cx][cy];  // 区间时间
            int time = t %(full);
            if(time < a[cx][cy]) {  // 当前红绿灯上下通行
                for(int i=0; i<2; i++){
                    newx = cx + UD[i][0];
                    newy = cy + UD[i][1];
                    if(newx < 0 || newx == n || newy <0 || newy ==m)
                        continue;
                    pq.push(node(t+1,newx, newy));  // 直接过
                }
                for(int i=0; i<2; i++){
                    newx = cx + LR[i][0];
                    newy = cy + LR[i][1];
                    if(newx < 0 || newx == n || newy <0 || newy ==m)
                        continue;
                    pq.push(node(t+ a[cx][cy] - time + 1,newx, newy));  // 等灯变
                }
            }
            else{
                for(int i=0; i<2; i++){
                    newx = cx + LR[i][0];
                    newy = cy + LR[i][1];
                    if(newx < 0 || newx == n || newy <0 || newy ==m)
                        continue;
                    pq.push(node(t+1,newx, newy));
                }
                for(int i=0; i<2; i++){
                    newx = cx + UD[i][0];
                    newy = cy + UD[i][1];
                    if(newx < 0 || newx == n || newy <0 || newy ==m)
                        continue;
                    pq.push(node(t+ full - time + 1,newx, newy));
                }
            }
        }
        cout<<res<<endl;

    }
}
```





## 查找&排序

## 双指针

## 数据结构

### 优先队列

#### <font color=red>【美团2021第10场】公司食堂</font>

```
小美和小团所在公司的食堂有N张餐桌，从左到右摆成一排，每张餐桌有2张餐椅供至多2人用餐，公司职员排队进入食堂用餐。小美发现职员用餐的一个规律并告诉小团：当男职员进入食堂时，他会优先选择已经坐有1人的餐桌用餐，只有当每张餐桌要么空着要么坐满2人时，他才会考虑空着的餐桌；

当女职员进入食堂时，她会优先选择未坐人的餐桌用餐，只有当每张餐桌都坐有至少1人时，她才会考虑已经坐有1人的餐桌；

无论男女，当有多张餐桌供职员选择时，他会选择最靠左的餐桌用餐。现在食堂内已有若干人在用餐，另外M个人正排队进入食堂，小团会根据小美告诉他的规律预测排队的每个人分别会坐哪张餐桌
```

**输入描述：**

```
第一行输入一个整数T（1<=T<=10），表示数据组数。每组数据占四行，第一行输入一个整数N（1<=N<=500000）；第二行输入一个长度为N且仅包含数字0、1、2的字符串，第i个数字表示左起第i张餐桌已坐有的用餐人数；第三行输入一个整数M（1<=M<=2N且保证排队的每个人进入食堂时都有可供选择的餐桌）；第四行输入一个长度为M且仅包含字母M、F的字符串，若第i个字母为M，则排在第i的人为男性，否则其为女性。
```

**输出描述：**

```
每组数据输出占M行，第i行输出一个整数j（1<=j<=N），表示排在第i的人将选择左起第j张餐桌用餐。
```

**示例1**

```
输入例子：
1
5
01102
6
MFMMFF
输出例子：
2
1
1
3
4
4
```

------

法一：小顶堆

使用三个小根堆，分别存储当前人数为0,1,2的三种桌子的桌号，记为pq0,pq1,pq2  

以男职员为例： 

1.    先尝试坐人数为1的桌子，该桌子人数就变成了2，等价于：将pq1的堆顶弹出，同时推入pq2    
2.    如果没有人数为1的桌子了，等价于pq1为空，就去坐人数为0的桌子，等价于：将pq0的堆顶弹出，同时推入pq1   

 因为桌号存储在优先队列，所以堆顶的桌号总是最小的，保证每个人有多个选择时优先坐最左边的桌子。 

 女职员同理。 

```c++
#include <iostream>
#include <algorithm>
#include <cstdlib>
#include <vector>
#include <map>
#include <string>
#include <queue>

using namespace std;

int main() {
    int t;
    cin>>t;
    while(t--) {
        int n;
        string pos;
        int m;
        string come;

        cin >> n >> pos >> m >> come;
        priority_queue<int, vector<int>, greater<int>> pq0;
        priority_queue<int, vector<int>, greater<int>> pq1;
        priority_queue<int, vector<int>, greater<int>> pq2;
        for(int i=0; i<n; i++){
            if(pos[i] == '0')
                pq0.push(i+1);
            else if(pos[i] == '1')
                pq1.push(i+1);
            else pq2.push(i+1);
        }

        int res[m];
        for(int i=0; i<m; i++){
            if(come[i] == 'M'){
                if(!pq1.empty()){
                    res[i] = pq1.top();
                    pq1.pop();
                    pq2.push(res[i]);
                }
                else{
                    res[i] = pq0.top();
                    pq0.pop();
                    pq1.push(res[i]);
                }
            }
            else{
                if(!pq0.empty()){
                    res[i] = pq0.top();
                    pq0.pop();
                    pq1.push(res[i]);
                }
                else{
                    res[i] = pq1.top();
                    pq1.pop();
                    pq2.push(res[i]);
                }
            }
        }
        for(int i=0; i<m; i++){
            printf("%d\\n", res[i]);
        }

    }
}
/*
1
5
01102
6
MFMMFF
 */
```

法二：模拟

用2个指针f0和f1维护当前最左边的坐了0个人的位置和坐了1个人的位置

```
for (int i = 0;i < N;++i) {
    if (f_zero != -1 && f_one != -1) break;
    else if (f_zero == -1 && desk[i] == '0') f_zero = i;
    else if (f_one == -1 && desk[i] == '1') f_one = i;
}
for (int i = 0;i < M;++i) {
    if (que[i] == 'M') {
        if (f_one < N) {
            printf("%d\n", f_one + 1);
            desk[f_one] = '2';
            while (f_one < N && desk[f_one] != '1') f_one++;
        }
        else {
            printf("%d\n", f_zero + 1);
            desk[f_zero] = '1';
            if (f_zero < f_one) f_one = f_zero;
            while (f_zero < N && desk[f_zero] != '0') f_zero++;
        }
    }
    else {
        if (f_zero < N) {
            printf("%d\n", f_zero + 1);
            desk[f_zero] = '1';
            if (f_zero < f_one) f_one = f_zero;
            while (f_zero < N && desk[f_zero] != '0') f_zero++;
        }
        else {
            printf("%d\n", f_one + 1);
            desk[f_one] = '2';
            while (f_one < N && desk[f_one] != '1') f_one++;
        }
    }
}
```



## 二叉树

## 并查集

## 动态规划

### 子序列

#### <font color=blue>【美团2021第9场】回转寿司</font>

```
小美请小团吃回转寿司。转盘上有N盘寿司围成一圈，第1盘与第2盘相邻，第2盘与第3盘相邻，…，第N-1盘与第N盘相邻，第N盘与第1盘相邻。小团认为第i盘寿司的美味值为A[i]（可能是负值，如果小团讨厌这盘寿司）。现在，小团要在转盘上选出连续的若干盘寿司，使得这些寿司的美味值之和最大（允许不选任何寿司，此时美味值总和为0）。
```

输入描述：

```
第一行输入一个整数T（1<=T<=10），表示数据组数。每组数据占两行，第一行输入一个整数N（1<=N<=10^5）；第二行输入N个由空格隔开的整数，表示A[1]到A[N]（-10^4<=A[i]<=10^4）。
```

输出描述：

```
每组数据输出占一行，输出一个整数，表示连续若干盘寿司的美味值之和的最大值。
```

示例1

```
输入例子：
1
4
3 -2 4 -1

输出例子：

6


例子说明：
美味值之和最大连续若干盘寿司为第3盘、第4盘和第1盘。 
```



------

解答：

最大和和最小和，一定有一个是不需要旋转的。

首尾相连的情况，逆向思维，所有的值减最小值就是首尾相连的最大值

```
#include <iostream>
#include <cmath>
using namespace std;

int main() {
    int t;
    cin>>t;
    while(t--){
        int n;
        cin>>n;
        int a[n];
        int sum = 0;  // 总和
        for(int i=0; i<n; i++){
            cin>>a[i];
            sum+= a[i];
        }
        int dpMax[n];  // dpMax[i]表示以i为结尾的最大子序列和（无旋转）
        int dpMin[n];
        dpMax[0] = a[0];
        dpMin[0] = a[0];
        int maxx = -1;
        int minx = 0x7fffff;
        for(int i=1; i<n; i++){
            dpMax[i] = a[i] + max(0, dpMax[i-1]);
            maxx = max(maxx, dpMax[i]);
            dpMin[i] = a[i] + min(0, dpMin[i-1]);
            minx = min(minx, dpMin[i]);
        }
        // 结果就两种，有旋转最大和无旋转最大
        // 如果有旋转最大，那么最小子序列就一定是无旋转的，所以可以用总和减去最小子序列
        cout<< max(maxx, sum-minx) << endl;
    }
    
}
```





#### 【美团2021第8场】偏爱字母

```
小美喜欢字母E，讨厌字母F。在小美生日时，小团送了小美一个仅包含字母E和F的字符串，小美想从中选出一个包含字母E数量与字母F数量之差最大的子串。

*子串：从字符串前面连续删去若干个字符，从后面连续删去若干个字符剩下的字符串（也可以一个都不删），例如abcab是fabcab的子串，而不是abcad的子串。我们将空串看作所有字符串的子串。
```

输入描述：

```
第一行一个正整数n表示字符串的长度。第二行长度为n，且仅包含大写字母’E’,’F’的字符串（不含引号） 
```

输出描述：

```
输出一个整数，表示最大的差值
```

示例1

```
输入例子：
5
EFEEF

输出例子：
2

例子说明：
选择子串EE,此时有2个E，0个F,有最大差值2-0=2另外，选择子串EFEE也可以达到最大差值。
```

------

一看“连续子串”，不是双指针就是dp...

E是加分，F是扣分，E和F的数量差不就是这个子串的得分吗。所以转化成子串最大和

```
#include <iostream>
#include <map>
using namespace std;

map<char, int>ch2int;

int main() {
    int n;
    ch2int['E'] = 1;
    ch2int['F'] = -1;
    while(cin>>n){
        int dp[n];
        string str;
        cin>>str;
        dp[0] = ch2int[str[0]];
        int maxx = dp[0];
        for(int i=i; i<n; i++){
            dp[i] = ch2int[str[i]] + max(dp[i-1], 0);
            maxx = max(dp[i], maxx);
        }
        cout<<maxx<<endl;
    }
}
// 64 位输出请用 printf("%lld")
```





### 背包

### 状态压缩

### 树形DP

#### ❌【美团2021第10场】最优二叉树II

小团有一个由N个节点组成的二叉树，每个节点有一个权值。定义二叉树每条边的开销为其两端节点权值的乘积，二叉树的总开销即每条边的开销之和。小团按照二叉树的中序遍历依次记录下每个节点的权值，即他记录下了N个数，第i个数表示位于中序遍历第i个位置的节点的权值。之后由于某种原因，小团遗忘了二叉树的具体结构。在所有可能的二叉树中，总开销最小的二叉树被称为最优二叉树。现在，小团请小美求出最优二叉树的总开销。

输入描述：

```
第一行输入一个整数N（1<=N<=300），表示二叉树的节点数。第二行输入N个由空格隔开的整数，表示按中序遍历记录下的各个节点的权值，所有权值均为不超过1000的正整数。
```

输出描述：

```
输出一个整数，表示最优二叉树的总开销。
```

**示例1**

![img](https://uploadfiles.nowcoder.com/images/20210208/310922_1612799416933/49754179E8857A76EAF13CD0D08FCBA5)

```
输入例子：
5
7 6 5 1 3
输出例子：
45
例子说明：
总开销为7*1+6*5+5*1+1*3=45。
```

------





## 字符串



## 图论

### 最小生成树

### 最短路径

### 拓扑排序

### 关键路径

### 二分图



## 贪心

#### 【美团2021第8场】搭配出售

```
服装店新进了a条领带，b条裤子，c个帽子，d件衬衫，现在要把这些搭配起来售卖。有三种搭配方式，一条领带和一件衬衫，一条裤子和一件衬衫，一个帽子和一件衬衫。卖出一套领带加衬衫可以得到e元，卖出一套裤子加衬衫可以得到f元，卖出一套帽子加衬衫可以得到g元。现在你需要输出最大的获利方式
```

输入描述：

```
第一行两个正整数N，M，Q，表示小美书架有N行编号1到N，书本编号从1到M，接下来有Q个操作接下来Q行，每行是下列操作中的一种：1 x y : x是书本的编号，y是书架的行编号，代表小美将编号为x的书本放置到y行上。若该书本在小团手上则放置无效，若原来该书在书架上且原行上锁则放置无效，若该书被放置到一个锁了的行上则放置无效。2 y : y是书架的行编号，代表小美将行编号为y的书架加锁，对已经上锁的书架行该操作无效。3 y : y是书架的行编号，代表小美将行编号为y的书架锁去掉，对无锁的书架行该操作无效。4 x : x是书本的编号，代表小团想借编号为x的书本，对该操作若可以借到输出一行正整数在哪一行，借不到输出一行-15 x : x是书本的编号，代表小团还回来编号为x的书本。若该书本不在小团手上该操作无效。
```

输出描述：

```
对于每个操作4，若可以借到输出一行正整数在哪一行，借不到输出一行-1
```

示例1

输入例子：

```
5 5 10
1 1 4
1 2 3
1 3 1
2 1
4 1
5 2
4 3
4 5
3 1
4 2
```

输出例子：

```
4
-1
-1
3
```

------

简单贪心。直接按价格从高到低排序卖出。此外卡大数。

```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

struct node{
    long long num;
    long long value;
    node(){}
    node(long long n, long long v): num(n), value(v){}
};

bool cmp(node x, node y){
    return x.value > y.value;
}

int main() {
    long long a, b,c,d,e,f,g;
    while(scanf("%lld %lld %lld %lld %lld %lld %lld", &a, &b, &c, &d, &e, &f, &g)!=EOF){
        vector<node> vec{node(a,e), node(b,f), node(c,g)};
        if(d>=a+b+c){
            cout<< a*e+b*f+c*g<<endl;
            continue;
        }
        long long res = 0;
        sort(vec.begin(), vec.end(), cmp);
        // 贪心
        while(d){
            if(d>= vec[0].num){
                res += vec[0].num * vec[0].value;
                d-=vec[0].num;
                vec.erase(vec.begin());
            }
            else{
                res += vec[0].value * d;
                break;
            }
        }
        cout<<res<<endl;


    }
}
// 64 位输出请用 printf("%lld")
```





## 分治

## 数学

### 数论

### 组合数学

### 高精度

### 进制转换

### 位运算

