## 图论

### 并查集

#### 【并查集】HDU 1213

> 今天是伊格内修斯的生日。他邀请了很多朋友。现在是晚餐时间。Ignatius 想知道他至少需要多少张桌子。你要注意到，并不是所有的朋友都互相认识，所有的朋友都不愿意和陌生人在一起。
>
> 这个问题的一个重要规则是，如果我告诉你 A 知道 B，B 知道 C，那就意味着 A、B、C 彼此认识，所以他们可以留在一张表中。
>
> 例如：如果我告诉你A知道B，B知道C，D知道E，那么A，B，C可以留在一张表中，而D，E必须留在另一张表中。所以 Ignatius 至少需要 2 张桌子。

 

输入

输入以整数 T(1<=T<=25) 开头，表示测试用例的数量。然后是 T 测试用例。每个测试用例以两个整数 N 和 M(1<=N,M<=1000) 开始。N表示好友数量，好友从1到N进行标记。接下来是M行。每行由两个整数A和B（A！=B）组成，这意味着朋友A和朋友B互相认识。两种情况之间会有一个空行。



输出

对于每个测试用例，只需输出 Ignatius 至少需要多少个表。不要打印任何空白。

 

输入样本

```
2
5 3
1 2
2 3
4 5

5 1
2 5
```

 样本输出

```
2
4
```



解：

```
#include <iostream>
using namespace std;

const int MAXN = 1001;
int father[MAXN];

int Find(int x){
    if(father[x]!=x){
        father[x] = Find(father[x]);
    }
    return father[x];
}

void Union(int x, int y){
    int fx = Find(x);
    int fy = Find(y);
    if(fx != fy){
        father[fy] = fx;
    }
}

int main(){
    int t;
    cin>>t;

    int n, m;
    while(t--){
        cin>>n>>m;
        for(int i=1; i<=n; i++)  // 初始化父节点为自己
            father[i] = i;
        int x, y;
        for(int i=0; i<m; i++){
            cin>>x>>y;
            Union(x, y);
        }

        int res = 0;
        for(int i=1; i<=n; i++){
            if(father[i] == i)
                res++;
        }

        cout<<res<<endl;
    }
    return 0;
}
/**
2
5 3
1 2
2 3
4 5

5 1
2 5
*/
```





#### 【带权并查集】HDU 3038



#### 【带权并查集】POJ 2492 / HDU 1829



#### 【带权并查集】POJ 1182







### 最短路径

#### 【Dijkstra】HDU 2544



#### 【Floyd】HDU 1596









### 最小生成树

#### 【Kruskal】HDU 1301







### 拓扑排序

#### 【拓扑排序】HDU 3342





### 关键路径（最长路径）

#### 【关键路径】HDU 4109

#### 【最长路径】SDUT 2498







### 二分图

#### 【判定+最大匹配】HDU 2444



#### 【判定】HDU 4751



#### 【最小顶点覆盖】HDU 1054



#### 【最小顶点覆盖】HDU 1150



#### 【最大独立集】HDU 1068



#### 【最小路径覆盖】HDU 1151





### 欧拉路径

#### 【判定】HDU 1878







## 贪心



## DP

### 背包

#### 【多重背包】HDU 1059



#### 【完全背包】HDU 1114



#### 【完全背包】HDU 2159





### 子序列/字符串

#### 【LCS】HDU 1159

#### 【LIS】HDU 1160





#### 【nlogn最长上升子序列】HDU 1025

#### 【最长非下降子序列】HDU 1950





### 状态压缩

#### 【状态压缩】HDU 1074





### 树形DP





## 递归/分治

### 搜索

#### 【记忆化搜索】HDU 1331



### 分治



### 递推







## 树

### 二叉树

#### 【后缀建树】HDU 1805





### 树状数组

#### 【累加-单点更新-区间查询】HDU 1166

#### 【累加-区间更新-单点查询】洛谷 3368

#### 【最大值-单点更新-区间查询】HDU 1754





### 线段树

#### 【累加-单点更新-区间查询】HDU 1166

#### 【累加-区间更新-单点查询】洛谷 3368

#### 【最大值-单点更新-区间查询】HDU 1754

#### 【累加-区间更新-区间查询】HDU 1698

