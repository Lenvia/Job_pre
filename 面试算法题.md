[TOC]

注：⚠️表示有更好的方法没有补充。



## 链表

### NC78 反转链表【美团】【字节】

https://leetcode-cn.com/problems/reverse-linked-list/

https://zhuanlan.zhihu.com/p/240694166

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* cur = head;
        ListNode* pre = nullptr;
        ListNode* temp = nullptr;
        while(cur){
            temp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = temp;  // 每轮末尾，cur和temp都会指向一个正常节点
        }
        return pre;
    }
};
```



### <font color=red>NC50 链表中的节点每k个一组翻转</font>

https://www.nowcoder.com/practice/b49c3dc907814e9bbfa8437c251b028e?tpId=196&tqId=37080&rp=1&ru=/exam/oj&qru=/exam/oj&sourceUrl=%2Fexam%2Foj%3Ftab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D196%26page%3D1&difficulty=undefined&judgeStatus=undefined&tags=&title=

方法一：暴力模拟（用vector）

时间复杂度 O(n)，空间复杂度O(n)

```
/**
 * struct ListNode {
 *	int val;
 *	struct ListNode *next;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param head ListNode类 
     * @param k int整型 
     * @return ListNode类
     */
    ListNode* reverseKGroup(ListNode* head, int k) {
        vector<int>vec;
        vec.clear();
        ListNode* cur = head;
        while(cur){  // 放进vector里
            vec.push_back(cur->val);
            cur = cur->next;
        }
        // 翻转
        for(int i=0; i<vec.size(); i+=k){
            if(i+k <= vec.size()){
                reverse(vec.begin()+i, vec.begin()+i+k);
            }
            else break;
        }
        
        cur = head;
        for(int i=0; i<vec.size(); i++){
            cur->val = vec[i];
            cur = cur->next;
        }
        return head;
    }
};
```



方法二：递归

> 首先，我们要实现一个reverse函数反转一个区间之内的元素。
>
> 反转以a为头结点的链表其实就是反转a到null之间的结点，那么反转a到b之间的结点就只需要吧null改为b是不是就可以实现了？

reverseKGroup 递归的思路比较绕！！！

运行完这一行后，

```
ListNode* res = reverse(head, cur);
```

这一小段翻转后的链表，头指针就是res，尾指针是head！

完整代码：

```
/**
 * struct ListNode {
 *	int val;
 *	struct ListNode *next;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param head ListNode类 
     * @param k int整型 
     * @return ListNode类
     */
    // 翻转 [left, right) 的链表
    ListNode* reverse(ListNode* left, ListNode* right){
        ListNode* cur = left;
        ListNode* pre = nullptr;
        ListNode* nxt;
        
        while(cur!=right){
            nxt = cur->next;
            cur->next = pre;
            pre = cur;
            cur = nxt;
        }
        return pre;  // 翻转后的头节点
    }
    
    ListNode* reverseKGroup(ListNode* head, int k) {
        ListNode* cur = head;
        // 找到这一段的末节点
        for(int i=0; i<k; i++){
            if(cur==nullptr)  // 如果为空，说明不足k个，直接返回头指针
                return head;
            cur = cur->next;
        }
        // 现在就要翻转 [head, cur) 之间的链表
        ListNode* res = reverse(head, cur);
        // 此时head 指向这一小段的末节点
        head->next = reverseKGroup(cur, k);
        
        return res;
    }
};
```



### <font color=purple>NC4 判断链表中是否有环</font>

链表找环路的问题，<font color=purple>快慢指针(Floyd 判圈法)</font>。

> 给定两个指针， 分别命名为 slow 和 fast，起始位置在链表的开头。每次<font color=red> fast 前进两步</font>，slow 前进一步。如果 fast 可以走到尽头，那么说明没有环路;如果 fast 可以无限走下去，那么说明一定有环路，且一定存 在一个时刻 slow 和 fast 相遇。当 slow 和 fast 第一次相遇时，我们将 fast 重新移动到链表开头，并 让 <font color=red>slow 和 fast 每次都前进一步</font>。当 slow 和 fast 第二次相遇时，相遇的节点即为环路的开始点。

注意一开始是do while 循环。

**被注释掉的部分是找到环的入口。**

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        if(head == nullptr)
            return false;
        ListNode* fast = head;
        ListNode* slow = head;
        
        do{  // 先进行一次
            if(fast==nullptr || fast->next==nullptr){  // 一次就走到头了
                return false;
            }
            fast = fast->next->next;
            slow = slow->next;
        }while(fast!=slow);
        
        return true;
        
//         // 执行到这里说明有环，让fast归零
//         fast = head;
//         while(fast!=slow){
//             fast = fast->next;
//             slow = slow->next;
//         }  // 循环结束后，fast就指向环的入口
        
//         return true;
    }
};
```



### <font color=purple>NC3 链表中环的入口结点</font>

见上面 NC4 的解析。

```
/*
struct ListNode {
    int val;
    struct ListNode *next;
    ListNode(int x) :
        val(x), next(NULL) {
    }
};
*/
class Solution {
public:
    ListNode* EntryNodeOfLoop(ListNode* pHead) {
        ListNode* fast = pHead, *slow = pHead;
        
        do{
            if(fast == nullptr || fast->next ==nullptr)
                return nullptr;
            fast = fast->next->next;
            slow = slow->next;
        }while(fast!=slow);
        
        // 执行到这里说明有环，让fast归零
        fast = pHead;
        while(fast != slow){
            fast = fast->next;
            slow = slow->next;
        }  // 循环结束后，fast就指向环的入口
        return fast;
    }
};
```



### NC53 删除链表的倒数第n个节点

先统计一遍个数，然后找到是正数第几个节点。

为了直观，先判断是否是删头节点，删头节点的话直接return head->next。

否则， 指向它前面一个节点，找到，修改。

```
/**
 * struct ListNode {
 *	int val;
 *	struct ListNode *next;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param head ListNode类 
     * @param n int整型 
     * @return ListNode类
     */
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        // write code here
        ListNode* cur = head;
        int count = 0;
        while(cur){
            count++;
            cur = cur->next;
        }
        if(count == n)// 删除的是头节点
            return head->next;
        cur = head;
        // 被删除的节点是正数第 count-n+1个节点，它前面的节点是第 count-n个
        // 从head开始，执行 count-n-1次循环到达
        int num = count-n-1;
        while(num--){
            cur = cur->next;
        }
        cur->next = cur->next->next;
        return head;
    }
};
```



### ⚠️<font color=purple>NC66 两个链表的第一个公共结点</font>

给定两个单链表，若含有公共结点，返回第一个公共结点的指针。

方法一：同一起跑线

如果有公共节点，那么后面部分应该是一样的，直接把较长的链表的前面切除，先保证一样长。

然后双指针同时走，如果为空或者相等了就返回。

是空，表示无公共。如果非空，则有公共。

```
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
    ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) {
        ListNode* cur1 = pHead1;
        ListNode* cur2 = pHead2;
        if(!cur1 || !cur2)  // 如果有空链表
            return nullptr;
        
        int count1 = 0;
        int count2 = 0;
        while(cur1){
            count1++;
            cur1 = cur1->next;
        }
        while(cur2){
            count2++;
            cur2 = cur2->next;
        }
        
        // 再次初始化
        cur1 = pHead1;
        cur2 = pHead2;
        if(count1>=count2){
            for(int i=0; i<count1-count2; i++)
                cur1 = cur1->next;
        }
        else{
            for(int i=0; i<count2-count1; i++)
                cur2 = cur2->next;
        }
        // 现在cur1和cur2在同一起跑线
        while(cur1 && cur2 && cur1!=cur2){
            cur1 = cur1->next;
            cur2 = cur2->next;
        }
        // 如果cur1是空，表示无公共。如果非空，则有公共。反正都是一样返回
        return cur1;
        
    }
};
```



方法二：题解中Dylan的回答（待更新）



### <font color=purple>NC45 分隔链表</font>

由于需要保留两个分区中每个节点的初始相对位置。

所以整个数组就只有两类，小于x的、大于等于x的。用level进行区分。

进行一个stable_sort，忽略值的大小，只对level排序

```
/**
 * struct ListNode {
 *	int val;
 *	struct ListNode *next;
 *	ListNode(int x) : val(x), next(nullptr) {}
 * };
 */
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param head ListNode类 
     * @param x int整型 
     * @return ListNode类
     */
    struct node{
        int val;
        int level;
        node(int v, int l): val(v), level(l){}
    };
    
    static bool cmp(node a, node b){
        return a.level<b.level;
    }

    ListNode* partition(ListNode* head, int x) {
        if(head==nullptr)
            return head;
        vector<node>vec;
        ListNode* cur = head;
        // 由于需要保留两个分区中每个节点的初始相对位置
        // 所以整个数组就只有两类，小于x的、大于等于x的。用level进行区分
        while(cur){
            if(cur->val<x)
                vec.push_back(node(cur->val, 0));
            else vec.push_back(node(cur->val, 1));
            cur = cur->next;
        }
        
        // 进行一个stable sort，忽略值的大小，只对level排序
        stable_sort(vec.begin(), vec.end(), cmp);
        
        cur = head;
        for(int i=0; i<vec.size(); i++){
            cur->val = vec[i].val;
            cur = cur->next;
        }
        return head;
    }
};
```



废弃方法：插入排序。 TLE！！！（但思路可以看一下！）

如果当前值大于等于x，不动。否则，不断向前换，直到前面的值小于x

```
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
        if(head==nullptr)
            return head;
        vector<int>vec;
        ListNode* cur = head;
        while(cur){
            vec.push_back(cur->val);
            cur = cur->next;
        }
        
        // 插入排序
        // 如果当前值大于等于x，不动。否则，不断向前换，直到前面的值小于x
        int tempI, tempV;
        for(int i=1; i<vec.size(); i++){
            tempI = i;
            tempV = vec[i];
            if(tempV>=x)
                continue;
            for(int j=i-1; j>=0; j--){
                if(vec[j]>=x){
                    tempI = j;
                    vec[j+1] = vec[j];  // 右移动
                }
            }
            vec[tempI] = tempV;  // 放到这个位置
        }
        
        cur = head;
        for(int i=0; i<vec.size(); i++){
            cur->val = vec[i];
            cur = cur->next;
        }
        return head;
    }
};
```



### ⚠️NC40 两个链表生成相加链表

方法一：

转为字符串处理。大数加法。

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */

class Solution {
public:
    /**
     * 
     * @param head1 ListNode类 
     * @param head2 ListNode类 
     * @return ListNode类
     */
    // 字符串大数加法
    string strAdd(string str1, string str2){
        // 长度对齐
        if(str1.length()>=str2.length())
            str2.insert(0, str1.length()-str2.length(),'0');
        else
            str1.insert(0, str2.length()-str1.length(),'0');
        
        int temp,add;
        add = 0;
        
        for(int i=str1.length()-1; i>=0; i--){
            temp = (str1[i]-'0') + (str2[i] -'0') + add;
            str1[i] = temp%10+'0';
            add = temp/10;
        }
        if(add)
            str1.insert(0, "1");
        return str1;
    }
    
    ListNode* addInList(ListNode* head1, ListNode* head2) {
        ListNode* cur1, *cur2;
        cur1 = head1;
        cur2 = head2;
        string s1, s2, res;
        
        // 转为字符串
        while(cur1){
            s1.push_back(cur1->val + '0');
            cur1 = cur1->next;
        }
        while(cur2){
            s2.push_back(cur2->val + '0');
            cur2 = cur2->next;
        }
        
        // 字符串大数加法
        res = strAdd(s1, s2);
        
        // 字符串生成链表，注意边界（头节点）
        cur1 = head1;
        head1->val = res[0]-'0';
        for(int i=1; i<res.length(); i++){
            ListNode* newptr = new ListNode(res[i]-'0');
            cur1->next = newptr;
            cur1 = newptr;
        }
        return head1;
        
    }
};
```



方法二：

辅助栈





## 搜索

### NC105 二分查找-II【美团】

从左到右第一个出现的target的下标

先判断小于和大于，最后的else再给等于。

找到目标值之后，向左查找，保证第一次出现。

```
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 如果目标值存在返回下标，否则返回 -1
     * @param nums int整型vector 
     * @param target int整型 
     * @return int整型
     */
    int search(vector<int>& nums, int target) {
        if(nums.size()==0 || nums[0]>target || nums[nums.size()-1] < target)
            return -1;
        int l = 0;
        int r = nums.size()-1;
        while(l<=r){
//             printf("%d %d\n", l, r);
            int mid = (l+r)/2;
            if(nums[mid]<target){
                l = mid+1;
            }
            else if(nums[mid]>target){
                r = mid-1;
            }
            else{  // 找到目标，继续向左
                while(mid>0 && nums[mid-1]==target){
                    mid--;
                }
                return mid;
            }
        }
        return -1;
    }
};
```



方法二：

直接lower_bound

```
int search(vector<int>& nums, int target) {
        if(nums.size()==0 || nums[0]>target || nums[nums.size()-1] < target)
            return -1;
        
        int index = lower_bound(nums.begin(), nums.end(), target) - nums.begin();
        if(index==0){  // index==0可能本来就是0，也可能是没找到
            if(nums[0]!=target)
                return -1;
        }
        return index;
    }
```





## 排序

### NC140 排序【美团】【字节】

https://www.nowcoder.com/practice/2baf799ea0594abd974d37139de27896?tpId=117&&tqId=37851&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking

快排。（这一版写的不好，参考 <font color=red>NC119 NC88</font> 的 partition）

```
void quickSort(int* a, int left, int right){
//    printf("%d, %d\n", left, right);
    if(left >= right)  // 这里要是大于等于！！！！
        return;
    if(left+1==right){  // 仅两个元素
        if(a[left]>a[right]){
            swap(a[left], a[right]);
        }
        return;
    }
    
    int tempV = a[left];  // 首元素
    int tempI = left;
    int index1 = left, index2 = right;

    while(index1<index2){
        while(index1 < index2 && a[index2]>=tempV)  // 从右边数直到有一个小于首元素的停止
            index2--;
        a[tempI] = a[index2];  // 用该元素填坑
        tempI = index2;
        
        while(index1 < index2 && a[index1]<=tempV)  // 从左边数知道有一个大雨首元素的停止
            index1++;
        a[tempI] = a[index1];  // 填刚才的坑
        tempI = index1;
    }  // 循环结束 index1 == index2
    a[index1] = tempV;
//    printArray(a);
    quickSort(a, left, index1);
    quickSort(a, index1+1, right);
}
```



### <font color=orange>NC119 最小的K个数</font>【美团】【字节】

https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=117&&tqId=37765&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking

1. 直接sort
2. **优先队列**：大顶堆，如果达到size后，判断新来的是否比队首小，如果小，则pop并放入新的。
3. 快排

对数组[l, r]一次快排partition过程可得到，[l, p), p, [p+1, r]三个区间

[l,p)为小于等于p的值，[p+1,r]为大于等于p的值。

然后再判断p，利用二分法



1. 如果[l,p), p，也就是p+1个元素（因为下标从0开始），如果p+1 == k, 找到答案
2. 如果p+1 < k, 说明答案在[p+1, r)区间内
3. 如果p+1 > k , 说明答案在[l, p)内

```
class Solution {
public:
    int partition(vector<int>& vec, int l, int r){  // [l, r]
        int randm = rand()%(r-l+1) + l;  // 随机取一个座位pivot
        swap(vec[randm], vec[r]);
        
        int pivot = vec[r];
        int i = l;
        for(int j=l; j<r; j++){
            if(vec[j]<pivot){
                swap(vec[i], vec[j]);
                i++;  // i永远指向第一个不小于pivot的元素
            }
        }
        swap(vec[i], vec[r]);
        return i;
    }
    
    vector<int> GetLeastNumbers_Solution(vector<int> input, int k) {
        vector<int>res;
        if(k==0 || k>input.size())
            return res;
        int left, right, index;
        left = 0;
        right = input.size()-1;
        while(left<=right){
            index = partition(input, left, right);
            if(index+1 < k){  // 答案在右半边
                left = index+1;
            }
            else if(index+1 > k){  // 答案在左半边
                right = index-1;
            }
            else{
                return vector<int>({input.begin(), input.begin()+k});
            }
        }
        return res;
    }
};
```



优先队列解法

```
class Solution {
public:
    priority_queue<int> q;  // 大顶堆
    vector<int> GetLeastNumbers_Solution(vector<int> input, int k) {
        while(!q.empty()) q.pop();
        
        vector<int>res;
        int count = 0;
        if(k==0 || k>input.size())
            return res;
        
        for(int i=0; i<input.size(); i++){
            if(count<k){
                q.push(input[i]);
                count++;
            }
            else{
                int temp = q.top();  // 堆顶元素
                if(temp>input[i]){  // 如果新来的更小，放入堆，替换掉堆顶
                    q.pop();
                    q.push(input[i]);
                }
            }
        }
        while(!q.empty()){
            res.push_back(q.top());
            q.pop();
        }
        return res;
    }
};
```



### NC88 寻找第K大【美团】【字节】

https://www.nowcoder.com/practice/e016ad9b7f0b45048c58a9f27ba618bf?tpId=117&&tqId=37791&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking

快排+二分

```
class Solution {
public:
    
    int partition(vector<int> &input, int l, int r) {  // [l, r]
        int randm = rand()%(r-l+1) + l;
        swap(input[randm], input[r]);
        
        int pivot = input[r];
        int i = l;
        for (int j=l; j<r; ++j) {
            if (input[j] < pivot) {
                swap(input[i++], input[j]);  // i每次更新后永远指向第一个大于等于pivot的数
            }
        }
        swap(input[i], input[r]);
        return i;
    }
    
    int findKth(vector<int> a, int n, int K) {
        // 第K大，就是从小到大排序后 索引为 n-K
        int l = 0;
        int r = n-1;
        int curI;
        while(l<r){
            curI = partition(a, l, r);
            
            if(curI > n-K){
                r--;
            }
            else if(curI<n-K){
                l++;
            }
            else{
                return a[curI];
            }
        }
        return a[curI];
        
        
    }
};
```



### NC22 合并两个有序的数组【美团】

https://www.nowcoder.com/practice/89865d4375634fc484f3a24b7fe65665?tpId=188&&tqId=38585&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking

双指针 从后往前归并排序

```
class Solution {
public:
    void merge(int A[], int m, int B[], int n) {
        int end = m+n-1;
        int i = m-1;
        int j = n-1;
        
        while(i>=0 && j>=0){
            if(A[i]>=B[j]){
                A[end--] = A[i--];
            }
            else{
                A[end--] = B[j--];
            }
        }

        while(j>=0){  // B还有元素
            A[end--] = B[j--];
        }

    }
};
```



### NC70 单链表的排序【美团】

https://www.nowcoder.com/practice/f23604257af94d939848729b1a5cda08?tpId=188&&tqId=38554&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking

单链表排序，放到vector里，排完再放回去。

```
/**
 * struct ListNode {
 *	int val;
 *	struct ListNode *next;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param head ListNode类 the head node
     * @return ListNode类
     */
    ListNode* sortInList(ListNode* head) {
        // write code here
        vector<int>vec;
        ListNode* cur = head;
        while(cur){
            vec.push_back(cur->val);
            cur = cur->next;
        }
        sort(vec.begin(), vec.end());
        cur = head;
        for(int i=0; i<vec.size(); i++){
            cur->val = vec[i];
            cur = cur->next;
        }
        return head;
    }
};
```





## 数据结构

### <font color=red>NC93 设计LRU缓存结构</font>【美团】【字节】

https://www.nowcoder.com/practice/e3769a5f49894d49b871c09cadd13a61?tpId=117&&tqId=37804&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking

```
#include <unordered_map>
class Solution {
public:
    /**
     * lru design
     * @param operators int整型vector<vector<>> the ops
     * @param k int整型 the k
     * @return int整型vector
     */
    int capacity;
    list<pair<int, int>> lrulist;//双端队列模拟
    unordered_map<int, list<pair<int, int>>::iterator> lrumap;//map的value放的是引用
    vector<int> LRU(vector<vector<int> >& operators, int k) {
        // write code here
        vector<int> res;
        capacity = k;
        if(operators.empty())
            return res;
        for(auto it = operators.begin(); it != operators.end(); ++it){
            vector<int> temp = *it;
            if(temp[0] == 1)
                set(temp[1], temp[2]);
            else{
                res.push_back(get(temp[1]));
            }
                
        }
        return res;
    }
    
    void set(int key, int value){
        auto it = lrumap.find(key);
        if(it == lrumap.end()){//没找到
            if(lrumap.size() == capacity){//满了，删除最久未使用
                lrumap.erase(lrulist.back().first);  // back()函数返回一个引用，指向list的最后一个元素
                lrulist.pop_back();
            }
        }
        else//找到了 删除提前
            lrulist.erase(it->second);
        lrulist.push_front({key, value});
        lrumap[key] = lrulist.begin();//begin：返回一个迭代器 front：返回引用
    }
    
    int get(int key){
        auto it = lrumap.find(key);
        if(it == lrumap.end())
            return -1;
        int val = it->second->second;//找到了，记录值并把它提到最前面
        lrulist.erase(it->second);
        lrulist.push_front(*it->second);//*迭代器为其指向的元素
        return val; 
    }
    
};
```



### NC61 两数之和

哈希。

在数组中找出两个加起来等于目标值的数的下标。

```
class Solution {
public:
    /**
     * 
     * @param numbers int整型vector 
     * @param target int整型 
     * @return int整型vector
     */
    unordered_map<int, int>pos;
    vector<int> twoSum(vector<int>& numbers, int target) {
        // write code here
        pos.clear();
        vector<int>res;
        
        for(int i=0; i<numbers.size(); i++){
            if(pos.find(target-numbers[i])==pos.end()){  // map中没有该元素的互补元素
                if(pos.find(numbers[i])==pos.end()){
                    pos[numbers[i]] = i;
                }
            }
            else{
                res.push_back(pos[target-numbers[i]]+1);
                res.push_back(i+1);
            }
        }
        return res;
    }
};
```



### ⚠️NC41 最长无重复子数组

方法一：暴力（不推荐）

子数组一定是连续的，那就不断固定起始位置，往后找，直到遇到重复的。时间复杂度 O(n^2)。竟然没超时...

小的优化是把 for(int i=0; i<arr.size(); i++) 改成 for(int i=0; i<arr.size()-maxl; i++) 剪枝一下。

```
class Solution {
public:
    /**
     * 
     * @param arr int整型vector the array
     * @return int整型
     */
    unordered_map<int, bool>visited;
    int maxLength(vector<int>& arr) {
        if(arr.size()==0)
            return 0;
        
        visited.clear();
        int maxl = 1;
        
        for(int i=0; i<arr.size(); i++){
            visited[arr[i]] = true;
            int cur = 1;
            for(int j=i+1; j<arr.size(); j++){
                if(visited.find(arr[j])!=visited.end()){  // 已存在，打破循环
                    break;
                }
                else{
                    visited[arr[j]] = true;
                    cur++;
                }
            }
            maxl = max(maxl, cur);
            visited.clear();  // 清空所有
        }
        return maxl;
    }
};
```



方法二：队列

把元素不停的加入到队列中，如果有相同的元素，就把队首的元素移除，直到不包含相同元素。

```
class Solution {
public:
    /**
     * 
     * @param arr int整型vector the array
     * @return int整型
     */
    unordered_map<int, bool>visited;
    queue<int>q;
    int maxLength(vector<int>& arr) {
        if(arr.size()==0)
            return 0;
        
        visited.clear();
        while(!q.empty()) q.pop();
        
        int maxl = 0;
        
        for(int i=0; i<arr.size(); i++){
            // 如果队列有相同的元素了
            while(visited.find(arr[i])!= visited.end()){
                int temp = q.front();
                q.pop();
                visited.erase(temp);
            }
            // 这时候已经被清除了
            q.push(arr[i]);
            visited[arr[i]] = true;
            maxl = max(maxl, (int)q.size());
        }
        return maxl;
    }
};
```





方法三：双指针队列

思想相同，只不过用left和right当队头队尾。



方法四：

暂时搁置



### NC52 有效括号序列

简单的匹配括号。用栈。

注意判断栈空。

```
class Solution {
public:
    /**
     * 
     * @param s string字符串 
     * @return bool布尔型
     */
    bool isValid(string s) {
        // write code here
        stack<char>st;
        for(int i=0; i<s.length(); i++){
            if(s[i]=='(' || s[i]=='[' || s[i]=='{')
                st.push(s[i]);
            else{
                if(st.empty()) return false;  // 来了右半边但栈空，无匹配
                if(s[i]==')'){
                    if(st.top()=='(')
                        st.pop();
                    else return false;
                }
                else if(s[i]==']'){
                    if(st.top()=='[')
                        st.pop();
                    else return false;
                }
                else if(s[i]=='}'){
                    if(st.top()=='{')
                        st.pop();
                    else return false;
                }
            }
        }
        if(!st.empty())  // 栈不空，还有字符没匹配
            return false;
        else return true;
    }
};
```





## 二叉树

### NC45 实现二叉树先序，中序和后序遍历【美团】【字节】

https://www.nowcoder.com/practice/a9fec6c46a684ad5a3abd4e365a9d362?tpId=117&&tqId=37819&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking

```
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 * };
 */
#include <vector>
class Solution {
public:
    /**
     * 
     * @param root TreeNode类 the root of binary tree
     * @return int整型vector<vector<>>
     */
    vector<vector<int>>res;
    vector<int>temp;
    
    void preOrder(TreeNode* root){
        if(root==nullptr)
            return;
        temp.push_back(root->val);
        preOrder(root->left);
        preOrder(root->right);
        return ;
    }
    void inOrder(TreeNode* root){
        if(root==nullptr)
            return;
        
        inOrder(root->left);
        temp.push_back(root->val);
        inOrder(root->right);
        return ;
    }
    void postOrder(TreeNode* root){
        if(root==nullptr)
            return;
        
        postOrder(root->left);
        postOrder(root->right);
        temp.push_back(root->val);
        return ;
    }
    
    
    vector<vector<int> > threeOrders(TreeNode* root) {
        res.clear();
        temp.clear();
        preOrder(root);
        res.push_back(temp);
        
        temp.clear();
        inOrder(root);
        res.push_back(temp);
        
        temp.clear();
        postOrder(root);
        res.push_back(temp);

        return res;
    }
};
```



### NC15 求二叉树的层序遍历【美团】【字节】

https://www.nowcoder.com/practice/04a5560e43e24e9db4595865dc9c63a3?tpId=117&&tqId=37723&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking

BFS队列

结构体 存储节点指针以及层数。

每次超过当前最大层，push该层结果，然后清空。

注意！队列为空时退出了while，但还有一层结果记得push

```
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param root TreeNode类 
     * @return int整型vector<vector<>>
     */
    struct node{
        TreeNode* ptr;
        int level;
        node(TreeNode* p, int l): ptr(p), level(l){}
    };
    
    vector<vector<int> > levelOrder(TreeNode* root) {
        vector<vector<int>>res;
        if(root==nullptr){
            return res;
        }
        vector<int>temp;  // 用来存储一层
        queue<node>q;
        q.push(node(root, 0));
        int maxLevel = 0;  // 当前最大层
        int val;
        int level;
        while(!q.empty()){
            node point = q.front();
            q.pop();
            
            val = point.ptr->val;
            level = point.level;
            
//             printf("%d %d\n", val, level);
            
            if(level>maxLevel){  // 保存上一层结果，清空
                maxLevel = level;
                res.push_back(temp);
                temp.clear();
            }
            temp.push_back(val);
            
            if(point.ptr->left!=nullptr){
                q.push(node(point.ptr->left, level+1));
            }
            if(point.ptr->right!=nullptr){
                q.push(node(point.ptr->right, level+1));
            }
        }
        res.push_back(temp);  // 由于最后队列空了，最后一个temp没存
        return res;
    
    }
};
```



### NC14 按之字形顺序打印二叉树

NC 15 的进阶。

注意在循环中每次 level > maxLevel 时，temp就变成了上一层的结果。

跳出循环后，temp表示最后一层的结果，即level层。

```
/*
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }
    
};
*/
class Solution {
public:
    struct node{
        TreeNode* ptr;
        int level;
        node(TreeNode* p, int l): ptr(p), level(l){}
    };
    vector<vector<int> > Print(TreeNode* pRoot) {
        vector<vector<int>>res;
        if(pRoot==nullptr)
            return res;
        
        vector<int>temp;  // 用来存储一层
        queue<node>q;
        q.push(node(pRoot, 0));
        int maxLevel = 0;  // 当前最大层
        int val;
        int level;
        while(!q.empty()){
            node point = q.front();
            q.pop();
            
            val = point.ptr->val;
            level = point.level;
            
            if(level>maxLevel){  // 保存上一层结果，清空
                maxLevel = level;
                if(level & 1)  // temp 是上一层结果！所以如果当前level是奇，则上一层不用翻转
                    res.push_back(temp);
                else{
                    reverse(temp.begin(), temp.end());
                    res.push_back(temp);
                }
                temp.clear();
            }
            temp.push_back(val);
            
            if(point.ptr->left!=nullptr){
                q.push(node(point.ptr->left, level+1));
            }
            if(point.ptr->right!=nullptr){
                q.push(node(point.ptr->right, level+1));
            }
        }
        // 最后一层还没有输出
        if((level+1) & 1)  // 这里temp就是当前层结果了。
            res.push_back(temp);
        else{
            reverse(temp.begin(), temp.end());
            res.push_back(temp);
        }
        return res;
    }
    
};
```



### NC6 二叉树最大路径和【美团】

https://www.nowcoder.com/practice/da785ea0f64b442488c125b441a4ba4a?tpId=196&tqId=37050&rp=1&ru=/exam/oj&qru=/exam/oj&sourceUrl=%2Fexam%2Foj%3Ftab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D196%26page%3D1&difficulty=undefined&judgeStatus=undefined&tags=&title=

https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/

```
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param root TreeNode类 
     * @return int整型
     */
    int MAX_SUM = -1001;  // 即使全是负数，最小也不会小于-1001
    
    int maxGain(TreeNode* node){
        if(node==nullptr){
            return 0;
        }
        // 左右子树能给该节点的贡献值
        // 与0比较是因为，如果子树反而提供负贡献，就直接抛弃
        int left_gain = max(maxGain(node->left), 0);
        int right_gain = max(maxGain(node->right), 0);
        
        int cur_sum = node->val + left_gain + right_gain;  // 当前路径和
        MAX_SUM = max(MAX_SUM, cur_sum);
        return node->val + max(left_gain, right_gain);  // 每次只能选择一颗子树
    }
    int maxPathSum(TreeNode* root) {
        // write code here
        maxGain(root);
        return MAX_SUM;
    }
};
```







## 动态规划

### NC68 跳台阶

简单斐波那契。

注意空间复杂度为 O(1)，所以要开常数空间。

dp[i%3] = dp[(i-1)%3] + dp[(i-2)%3]

```
class Solution {
public:
    int jumpFloor(int number) {
        int dp[3];
        
        dp[1] = 1;
        dp[2] = 2;
        if(number<3)
            return dp[number];
        
        for(int i=3; i<=number; i++){
            dp[i%3] = dp[(i-1)%3] + dp[(i-2)%3];
        }
        return dp[number%3];
    }
};
```



### NC19 连续子数组的最大和

开常数空间。

dp[i%2] = max(dp[(i-1)%2], 0) + array[i]

```
class Solution {
public:
    int FindGreatestSumOfSubArray(vector<int> array) {
        int n = array.size();
        if(n==1){
            return array[0];
        }
        
        int dp[2];
        dp[0] = array[0];
        
        int max_sum = dp[0];
        for(int i=1; i<n; i++){
            dp[i%2] = max(dp[(i-1)%2], 0) + array[i];
            max_sum = max(max_sum, dp[i%2]);
        }
        return max_sum;
    }
};
```





### 最长公共子序列（LCS）【美团】

https://leetcode-cn.com/problems/longest-common-subsequence/

```
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int m = text1.length();
        int n = text2.length();
        int dp[m+1][n+1];
        memset(dp, 0, sizeof(dp));

        text1.insert(0, " ");
        text2.insert(0, " ");

        for(int i=1; i<=m; i++){
            for(int j=1; j<=n; j++){
                if(text1[i] == text2[j])
                    dp[i][j] = dp[i-1][j-1] + 1;
                else{
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
                }
            }
        }
        return dp[m][n];
    }
};
```



### NC127 最长公共子串

```
class Solution {
public:
    /**
     * longest common substring
     * @param str1 string字符串 the string
     * @param str2 string字符串 the string
     * @return string字符串
     */
    string LCS(string str1, string str2) {
        // write code here
        int len1 = str1.length();
        int len2 = str2.length();
        
        
        int dp[len1+1][len2+1];
        memset(dp, 0, sizeof(dp));
        
        // 处理边界
        str1.insert(0, " ");
        str2.insert(0, " ");
        // dp[0][0] = 0;
        
        int maxC = 0;
        string res;
        for(int i=1; i<=len1; i++){
            for(int j=1; j<=len2; j++){
                if(str1[i]==str2[j]){
                    dp[i][j] = dp[i-1][j-1] +1;
                    if(maxC < dp[i][j]){
                        maxC = dp[i][j];
                        // 子串长度为dp[i][j]
                        res = str1.substr(i-dp[i][j]+1, dp[i][j]);
                    }
                }
                // else dp[i][j] = 0;
            }
        }
        return res;
    }
};
```



## 字符串

### <font color=purple>NC55 最长公共前缀</font>【美团】

https://www.nowcoder.com/practice/28eb3175488f4434a4a6207f6f484f47?tpId=188&&tqId=38627&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking

纵向扫描

```
class Solution {
public:
    /**
     * 
     * @param strs string字符串vector 
     * @return string字符串
     */
    string longestCommonPrefix(vector<string>& strs) {
        if(strs.size()==0)
            return "";
        // 纵向扫描
        for(int j=0; j<strs[0].size(); j++){
            for(int i=0; i<strs.size(); i++){
                // 如果strs[i]的第j位越界 或 如果第j位不相等
                if(j==strs[i].size() || strs[0][j] != strs[i][j])
                    return strs[0].substr(0, j);
            }
        }
        return strs[0];
    }
};
```



### <font color=fuchsia>最长回文子串</font>【美团】

**Manacher**算法

```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string.h>
#include <algorithm>
#include <vector>
#include <map>
#include <cmath>
#include <queue>
using namespace std;
const int MAXN = 110005;
int p[MAXN*2];
char s[MAXN*2];
string str;
string newStr;

/*
    newStr的构成不仅仅是加个# 应该给原串加完#后，再在首尾加上 不一样 的 两个 符号 比如 str = 12321
    newStr = $#1#2#3#2#1#* 如果首尾一样，会出错!!!!!
*/
void init(){
    fill(p, p+MAXN, 1);
    //在这里 newStr别手贱前面写个string，而且newStr的⻓度是2*str.length()+3
    newStr = string(2*str.length()+3, '#');
    newStr[0] = '$';
    newStr[newStr.length()-1] = '*'; //在str的每个字符后都加个“#”，得到新字符串newStr
    for(int i=0, j=2; i<str.length(); i++, j+=2){
        newStr[j] = str[i];
    }
}
int Manacher(){
    init();
    int maxL = -1; //最大回文⻓度
    int id = -1; //当前使mx达到尽可能右边时的回文中心
    int mx = 0;
    //末尾还有个#，不要放进来
    for(int i=1; i<newStr.length(); i++){
        if(mx>i){ //如果之前的中心id的最大延展位置超过了i，那么看看可不可以给p[i]赋 一个最小值，省去一些计算
            /*
            p[2*id-i]是i关于id的对称点的延伸半径。 mx-i是mx与i的距离，同时也是mx
            关于id的对称点到 i关于id的对称点的距离
            如果 p[2*id-i]>mx-i，说明i的对称点j的半径是大的，但是我们现在最多只能
            保证[mx对称点，mx]是对称的，所以只能先让p[i]等于mx-i
            如果 p[2*id-i]<mx-i，说明j的范围还没超过id的范围，那稍微一想就明白了，
            i的半径就是j的半径。 */
            p[i] = min(p[2*id-i], mx-i);
        }
        else p[i] = 1; //否则没有简便方法，半径只能从1开始搜了 while(newStr[i-p[i]] == newStr[i+p[i]]){ //从上面已经预赋值的半径继续往两边寻找
        while(newStr[i-p[i]] == newStr[i+p[i]]){ //从上面已经预赋值的半径继续往两边寻找
            cout<<newStr[i]<<" "<<p[i]<<" "<<newStr[i-p[i]]<<" "<<newStr[i+p[i]]<<endl;
            p[i]++;
        }
        if(mx< i+p[i]){ //如果当前的最右范围超过了mx，那么更新mx。 因为mx尽可能的远 我们才能更容易偷懒。
            id = i;
            mx = i+p[i];
            
        }
        maxL = max(maxL, p[i]-1);
    }
    return maxL;
}

int main(){
    while(scanf("%s",s)!=EOF){ //用字符数组输入!!!!
        str = s;
        int maxL = -1;
        maxL = Manacher();
        cout<<maxL<<endl;
    }
}


```



动态规划算法

```
class Solution {
public:
    string longestPalindrome(string s) {
        if(s.length()<2)
            return s;
        
        int len = s.length();
        int maxLen = 1;  // 如果长度大于2，那么回文子串长度至少为1.
        int startIndex = 0;
        
        bool dp[len+1][len+1];  // dp[i][j] 表示 s[i]到s[j]是不是回文子串
        memset(dp, false, sizeof(dp));

        for(int i=0; i<len; i++)
            dp[i][i] = true;

        for(int l=2; l<=len; l++){  // 子串的长度从小到大
            for(int i=0; i<len; i++){  // 每次从最开头开始
                int j = i+l-1;  // 子串的末端
                if(j>=len)  // 越界
                    continue;
                if(s[i]!=s[j]){  // 子串 s[i]~s[j]肯定不是回文子串
                    dp[i][j] = false;
                }
                else{
                    if(l<=2)
                        dp[i][j] = true;
                    else{  // 因为s[i+1]~s[j-1]的长度更小，所以在之前就计算过了
                        dp[i][j] = dp[i+1][j-1];
                    }
                }
                if(dp[i][j] && l>maxLen){  // 记录长度和起始下标
                    maxLen = l;
                    startIndex = i;
                }
            }
        }

        return s.substr(startIndex, maxLen);
    }
};
```

