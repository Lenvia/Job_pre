[TOC]

注：⚠️表示有更好的方法没有补充。

<font color=fuchisa>粉色</font>：起码我一开始想不到/做不出来

<font color=red>红色</font>：较难

<font color=orange>橙色</font>：稍微难

<font color=purple>紫色</font>：技巧



## 模拟

### NC38 螺旋矩阵

简单模拟。注意别找重复了！

在底部，从右往左时注意top!=bottom

在左边，从下往上时注意left!=right

```
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int> > &matrix) {
        vector<int>res;
        if(matrix.empty()) return res;
        int left,right,top,bottom;
        left = 0; right = matrix[0].size()-1;
        top = 0; bottom = matrix.size()-1;
        
        while(left<=right && top<=bottom){
            // 从左往右
            for(int j=left; j<=right; j++){
                res.push_back(matrix[top][j]);
            }
            // 从上往下
            for(int i=top+1; i<=bottom; i++){
                res.push_back(matrix[i][right]);
            }
            // 从右往左（注意top!=bottom）
            for(int j=right-1; top!=bottom && j>=left; j--){
                res.push_back(matrix[bottom][j]);
            }
            // 从下往上（注意left!=right）
            for(int i=bottom-1; left!=right && i>top; i--){
                res.push_back(matrix[i][left]);
            }
            left++; right--; top++; bottom--;
        }
        return res;
        
    }
};
```







### <font color=dodgerblue>NC76 用两个栈实现队列</font>

未优化版本：

stack1用来进，stack2用来出。

push时，把stack2的元素压入stack1，再push进stack1

pop时，把stack1的元素压入stack2，再从stack2中pop

这样的策略，每次push或pop时，都要把全部元素转移一遍，执行完后，至少一个stack是空的。

那么如果push和pop交替着来，光转移元素就浪费了大量的时间！可以优化！

```
class Solution
{
public:
    void push(int node) {
        while(!stack2.empty()){
            stack1.push(stack2.top());
            stack2.pop();
        }
        stack1.push(node);
    }

    int pop() {
        while(!stack1.empty()){
            stack2.push(stack1.top());
            stack1.pop();
        }
        int res = stack2.top();
        stack2.pop();
        return res;
    }

private:
    stack<int> stack1;
    stack<int> stack2;
};
```



优化版本：

首先已知stack1永远保持先来的在底部，stack2永远保持先来的在顶部。

如果说从stack2 pop肯定需要从stack1拿元素，这很显然，可我stack1进行push时和你stack2的元素有什么关系？

push时并不会改变stack1的内部顺序，那还管什么stack2？

同样的，pop时，stack2如果还有元素，直接pop就是了，反正stack2的顶部是最老的元素。只要stack2不空，就不用从stack1取。

```
class Solution
{
public:
    void push(int node) {
        stack1.push(node);
    }

    int pop() {
        if(stack2.empty()){  // 空了的时候再取
            while(!stack1.empty()){
                stack2.push(stack1.top());
                stack1.pop();
            }
        }
        
        int res = stack2.top();
        stack2.pop();
        return res;
    }

private:
    stack<int> stack1;
    stack<int> stack2;
};
```





### <font color=fuchsia>NC137 表达式求值</font>

[简易计算器](http://t.cn/AiKoGS94)的改进

因为不涉及除法，所以全用的int。如果需要带上除法，记得修改pri和cal函数。

相比于简易计算器，支持括号！

左右括号的优先级 和 末尾的特殊字符'$' 一样。就是说，小于正常运算符（加减乘）的优先级。

关于符号栈：

- 如果新来的是左括号 或者 新来的优先级高，直接压进去
- 新来的（包括右括号）没有栈顶的高，先计算里面的。注意，这时候新来的不要入栈，index也不更新
  - 如果当前符号是右括号，栈顶是左括号，表明括号内部的已经完成了。 弹出左括号，index++，并contiue

```
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 返回表达式的值
     * @param s string字符串 待计算的表达式
     * @return int整型
     */
    stack<char>ops;
    stack<int>nums;
    
    int pri(char ch){
        int p = -1;
        if(ch=='#') return 0;
        if(ch=='$' || ch=='(' || ch==')') return 1;
        if(ch=='+' || ch=='-') return 2;
        if(ch=='*') return 3;
        return p;
    }
    
    int getNumber(string s, int& index){  // 带地址！
        int res = 0;
        while(isdigit(s[index])){
            res = 10*res;
            res += (s[index]-'0');
            index++;
        }
        return res;
    }
    
    int cal(int x, int y, char ch){
        int result=0;
        if(ch=='+')
            result=x+y;
        else if(ch=='-')
            result=x-y;
        else if(ch=='*')
            result=x*y;
        return result;
    }
    
    int solve(string s) {
        s.push_back('$');
        ops.push('#');
        int index = 0;
        while(index < s.length()){
            if(s[index]==' ')
                index++;
            else if(isdigit(s[index])){
                nums.push(getNumber(s, index));
            }
            else{
                // 新来的是左括号 或者 新来的优先级高，直接压进去
                if(s[index]=='(' || pri(s[index]) > pri(ops.top())){
                    ops.push(s[index]);
                    index++;
                }
                else{  // 新来的没有栈顶的高，先计算里面的。注意，这时候新来的不要入栈，index也不更新
                    if(s[index]==')' && ops.top()=='('){  // 括号内的都计算完了，该滚蛋了
                        index++;
                        ops.pop();
                        continue;
                    }
                    int y = nums.top();
                    nums.pop();
                    int x = nums.top();
                    nums.pop();
                    char ch = ops.top();
                    ops.pop();
                    nums.push(cal(x, y, ch));
                }
            }
        }
        return nums.top();
    }
};
```



### NC100 把字符串转换成整数(atoi)

感觉题目没说清楚。。。提交错了好多次

还有关于边界问题。

甚至也可能超过long long的范围！

以及 INT_MAX 的绝对值 比 INT_MIN 的绝对值少1

以及 INT_MAX 不能加一，而是应该 res - 1 >INT_MAX 来判断

```
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param s string字符串 
     * @return int整型
     */
    long long getNumber(string s, int index){
        long long res = 0;
        while(isdigit(s[index])){
            res = 10*res + (s[index]-'0');
            if(res-1>INT_MAX)  // 这里没考虑符号，所以要考虑到INT_MIN的绝对值
                return res;  // 只要大于 INT_MIN的绝对值，那铁定越界，随便返回
            index++;
        }
        return res;
    }
    
    int StrToInt(string s) {
        int flag = 0;  // 默认为正数，如果遇到负号flag置为1
        int hold = 0;  // 如果遇到正负号，后面再遇到直接忽略
        // 先去除前导空格
       int index = 0;
        while(s[index]==' ')
            index++;
        s = s.substr(index);
        
        long long temp = 0;
        int res = 0;
        // 遍历
        for(int i=0; i<s.length(); i++){
            if(isdigit(s[i])){
                temp = getNumber(s, i);
                break;
            }
            else{
                if(s[i]=='+' || s[i]=='-'){
                    if(!hold){  // 之前没遇到过正负号
                        hold = 1;
                        flag = s[i]=='+'?0:1;
                    }
                    // 后面再遇到正负号直接算错误
                    else return 0;
                }
                else return 0;  // 如果先遇到的是字母，则失败
            }
        }
        
        
        temp = flag==0?temp:-temp;
        
        if(temp>INT_MAX)
            res = INT_MAX;
        else if(temp<INT_MIN)
            res = INT_MIN;
        else res = (int)temp;
        
        return res;
    }
};
```





## 链表/指针

### NC78 反转链表【美团】【字节】

https://leetcode-cn.com/problems/reverse-linked-list/

https://zhuanlan.zhihu.com/p/240694166

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* cur = head;
        ListNode* pre = nullptr;
        ListNode* temp = nullptr;
        while(cur){
            temp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = temp;  // 每轮末尾，cur和temp都会指向一个正常节点
        }
        return pre;
    }
};
```



### <font color=red>NC50 链表中的节点每k个一组翻转</font>

https://www.nowcoder.com/practice/b49c3dc907814e9bbfa8437c251b028e?tpId=196&tqId=37080&rp=1&ru=/exam/oj&qru=/exam/oj&sourceUrl=%2Fexam%2Foj%3Ftab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D196%26page%3D1&difficulty=undefined&judgeStatus=undefined&tags=&title=

方法一：暴力模拟（用vector）

时间复杂度 O(n)，空间复杂度O(n)

```
/**
 * struct ListNode {
 *	int val;
 *	struct ListNode *next;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param head ListNode类 
     * @param k int整型 
     * @return ListNode类
     */
    ListNode* reverseKGroup(ListNode* head, int k) {
        vector<int>vec;
        vec.clear();
        ListNode* cur = head;
        while(cur){  // 放进vector里
            vec.push_back(cur->val);
            cur = cur->next;
        }
        // 翻转
        for(int i=0; i<vec.size(); i+=k){
            if(i+k <= vec.size()){
                reverse(vec.begin()+i, vec.begin()+i+k);
            }
            else break;
        }
        
        cur = head;
        for(int i=0; i<vec.size(); i++){
            cur->val = vec[i];
            cur = cur->next;
        }
        return head;
    }
};
```



方法二：递归

> 首先，我们要实现一个reverse函数反转一个区间之内的元素。
>
> 反转以a为头结点的链表其实就是反转a到null之间的结点，那么反转a到b之间的结点就只需要吧null改为b是不是就可以实现了？

reverseKGroup 递归的思路比较绕！！！

运行完这一行后，

```
ListNode* res = reverse(head, cur);
```

这一小段翻转后的链表，头指针就是res，尾指针是head！

完整代码：

```
/**
 * struct ListNode {
 *	int val;
 *	struct ListNode *next;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param head ListNode类 
     * @param k int整型 
     * @return ListNode类
     */
    // 翻转 [left, right) 的链表
    ListNode* reverse(ListNode* left, ListNode* right){
        ListNode* cur = left;
        ListNode* pre = nullptr;
        ListNode* nxt;
        
        while(cur!=right){
            nxt = cur->next;
            cur->next = pre;
            pre = cur;
            cur = nxt;
        }
        return pre;  // 翻转后的头节点
    }
    
    ListNode* reverseKGroup(ListNode* head, int k) {
        ListNode* cur = head;
        // 找到这一段的末节点
        for(int i=0; i<k; i++){
            if(cur==nullptr)  // 如果为空，说明不足k个，直接返回头指针
                return head;
            cur = cur->next;
        }
        // 现在就要翻转 [head, cur) 之间的链表
        ListNode* res = reverse(head, cur);
        // 此时head 指向这一小段的末节点
        head->next = reverseKGroup(cur, k);
        
        return res;
    }
};
```



### NC21 链表内指定区间反转

利用NC50提到的区间翻转，连起来就行。

翻转[a, b] 要找到四个节点， a->pre, a, b, b->next

然后使用翻转 [a, b->next)，再连起来

```
/**
 * struct ListNode {
 *	int val;
 *	struct ListNode *next;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param head ListNode类 
     * @param m int整型 
     * @param n int整型 
     * @return ListNode类
     */
    ListNode* reverseL(ListNode* a, ListNode* b){  // [a, b)
        ListNode* cur, *pre, *temp;
        cur = a; pre = nullptr;
        while(cur!=b){
//             printf("%d ", cur->val);
            temp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = temp;
        }
        return pre;
    }
    
    ListNode* reverseBetween(ListNode* head, int m, int n) {
        ListNode*a, *b, *pre, *nxt;
        int count = 0;
        ListNode* init = new ListNode(0);  init -> next = head;
        ListNode* cur = init;
        
        // 翻转[a, b] 要找到四个节点， a->pre, a, b, b->next
        // 然后使用翻转 [a, b->next)，再连起来
        while(cur){
            if(count==m-1){  // 
                a = cur->next;
                pre = cur;
            }
            if(count==n){
                b = cur;
                nxt = b->next;
                break;
            }
            count++;
            cur = cur->next;
        }
        pre->next = reverseL(a, nxt);
        a->next = nxt;
        return init->next;
    }
};
```





### <font color=purple>NC4 判断链表中是否有环</font>

链表找环路的问题，<font color=purple>快慢指针(Floyd 判圈法)</font>。

> 给定两个指针， 分别命名为 slow 和 fast，起始位置在链表的开头。每次<font color=red> fast 前进两步</font>，slow 前进一步。如果 fast 可以走到尽头，那么说明没有环路;如果 fast 可以无限走下去，那么说明一定有环路，且一定存 在一个时刻 slow 和 fast 相遇。当 slow 和 fast 第一次相遇时，我们将 fast 重新移动到链表开头，并 让 <font color=red>slow 和 fast 每次都前进一步</font>。当 slow 和 fast 第二次相遇时，相遇的节点即为环路的开始点。

注意一开始是do while 循环。

**被注释掉的部分是找到环的入口。**

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        if(head == nullptr)
            return false;
        ListNode* fast = head;
        ListNode* slow = head;
        
        do{  // 先进行一次
            if(fast==nullptr || fast->next==nullptr){  // 一次就走到头了
                return false;
            }
            fast = fast->next->next;
            slow = slow->next;
        }while(fast!=slow);
        
        return true;
        
//         // 执行到这里说明有环，让fast归零
//         fast = head;
//         while(fast!=slow){
//             fast = fast->next;
//             slow = slow->next;
//         }  // 循环结束后，fast就指向环的入口
        
//         return true;
    }
};
```



### <font color=purple>NC3 链表中环的入口结点</font>

见上面 NC4 的解析。

```
/*
struct ListNode {
    int val;
    struct ListNode *next;
    ListNode(int x) :
        val(x), next(NULL) {
    }
};
*/
class Solution {
public:
    ListNode* EntryNodeOfLoop(ListNode* pHead) {
        ListNode* fast = pHead, *slow = pHead;
        
        do{
            if(fast == nullptr || fast->next ==nullptr)
                return nullptr;
            fast = fast->next->next;
            slow = slow->next;
        }while(fast!=slow);
        
        // 执行到这里说明有环，让fast归零
        fast = pHead;
        while(fast != slow){
            fast = fast->next;
            slow = slow->next;
        }  // 循环结束后，fast就指向环的入口
        return fast;
    }
};
```



### NC53 删除链表的倒数第n个节点

先统计一遍个数，然后找到是正数第几个节点。

为了直观，先判断是否是删头节点，删头节点的话直接return head->next。

否则， 指向它前面一个节点，找到，修改。

```
/**
 * struct ListNode {
 *	int val;
 *	struct ListNode *next;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param head ListNode类 
     * @param n int整型 
     * @return ListNode类
     */
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        // write code here
        ListNode* cur = head;
        int count = 0;
        while(cur){
            count++;
            cur = cur->next;
        }
        if(count == n)// 删除的是头节点
            return head->next;
        cur = head;
        // 被删除的节点是正数第 count-n+1个节点，它前面的节点是第 count-n个
        // 从head开始，执行 count-n-1次循环到达
        int num = count-n-1;
        while(num--){
            cur = cur->next;
        }
        cur->next = cur->next->next;
        return head;
    }
};
```



### ⚠️<font color=purple>NC66 两个链表的第一个公共结点</font>

给定两个单链表，若含有公共结点，返回第一个公共结点的指针。

方法一：同一起跑线

如果有公共节点，那么后面部分应该是一样的，直接把较长的链表的前面切除，先保证一样长。

然后双指针同时走，如果为空或者相等了就返回。

是空，表示无公共。如果非空，则有公共。

```
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
    ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) {
        ListNode* cur1 = pHead1;
        ListNode* cur2 = pHead2;
        if(!cur1 || !cur2)  // 如果有空链表
            return nullptr;
        
        int count1 = 0;
        int count2 = 0;
        while(cur1){
            count1++;
            cur1 = cur1->next;
        }
        while(cur2){
            count2++;
            cur2 = cur2->next;
        }
        
        // 再次初始化
        cur1 = pHead1;
        cur2 = pHead2;
        if(count1>=count2){
            for(int i=0; i<count1-count2; i++)
                cur1 = cur1->next;
        }
        else{
            for(int i=0; i<count2-count1; i++)
                cur2 = cur2->next;
        }
        // 现在cur1和cur2在同一起跑线
        while(cur1 && cur2 && cur1!=cur2){
            cur1 = cur1->next;
            cur2 = cur2->next;
        }
        // 如果cur1是空，表示无公共。如果非空，则有公共。反正都是一样返回
        return cur1;
        
    }
};
```



方法二：题解中Dylan的回答（待更新）



### <font color=purple>NC45 分隔链表</font>

由于需要保留两个分区中每个节点的初始相对位置。

所以整个数组就只有两类，小于x的、大于等于x的。用level进行区分。

进行一个stable_sort，忽略值的大小，只对level排序

```
/**
 * struct ListNode {
 *	int val;
 *	struct ListNode *next;
 *	ListNode(int x) : val(x), next(nullptr) {}
 * };
 */
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param head ListNode类 
     * @param x int整型 
     * @return ListNode类
     */
    struct node{
        int val;
        int level;
        node(int v, int l): val(v), level(l){}
    };
    
    static bool cmp(node a, node b){
        return a.level<b.level;
    }

    ListNode* partition(ListNode* head, int x) {
        if(head==nullptr)
            return head;
        vector<node>vec;
        ListNode* cur = head;
        // 由于需要保留两个分区中每个节点的初始相对位置
        // 所以整个数组就只有两类，小于x的、大于等于x的。用level进行区分
        while(cur){
            if(cur->val<x)
                vec.push_back(node(cur->val, 0));
            else vec.push_back(node(cur->val, 1));
            cur = cur->next;
        }
        
        // 进行一个stable sort，忽略值的大小，只对level排序
        stable_sort(vec.begin(), vec.end(), cmp);
        
        cur = head;
        for(int i=0; i<vec.size(); i++){
            cur->val = vec[i].val;
            cur = cur->next;
        }
        return head;
    }
};
```



废弃方法：插入排序。 TLE！！！（但思路可以看一下！）

如果当前值大于等于x，不动。否则，不断向前换，直到前面的值小于x

```
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
        if(head==nullptr)
            return head;
        vector<int>vec;
        ListNode* cur = head;
        while(cur){
            vec.push_back(cur->val);
            cur = cur->next;
        }
        
        // 插入排序
        // 如果当前值大于等于x，不动。否则，不断向前换，直到前面的值小于x
        int tempI, tempV;
        for(int i=1; i<vec.size(); i++){
            tempI = i;
            tempV = vec[i];
            if(tempV>=x)
                continue;
            for(int j=i-1; j>=0; j--){
                if(vec[j]>=x){
                    tempI = j;
                    vec[j+1] = vec[j];  // 右移动
                }
            }
            vec[tempI] = tempV;  // 放到这个位置
        }
        
        cur = head;
        for(int i=0; i<vec.size(); i++){
            cur->val = vec[i];
            cur = cur->next;
        }
        return head;
    }
};
```



### ⚠️NC40 两个链表生成相加链表

方法一：

转为字符串处理。大数加法。

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */

class Solution {
public:
    /**
     * 
     * @param head1 ListNode类 
     * @param head2 ListNode类 
     * @return ListNode类
     */
    // 字符串大数加法
    string strAdd(string str1, string str2){
        // 长度对齐
        if(str1.length()>=str2.length())
            str2.insert(0, str1.length()-str2.length(),'0');
        else
            str1.insert(0, str2.length()-str1.length(),'0');
        
        int temp,add;
        add = 0;
        
        for(int i=str1.length()-1; i>=0; i--){
            temp = (str1[i]-'0') + (str2[i] -'0') + add;
            str1[i] = temp%10+'0';
            add = temp/10;
        }
        if(add)
            str1.insert(0, "1");
        return str1;
    }
    
    ListNode* addInList(ListNode* head1, ListNode* head2) {
        ListNode* cur1, *cur2;
        cur1 = head1;
        cur2 = head2;
        string s1, s2, res;
        
        // 转为字符串
        while(cur1){
            s1.push_back(cur1->val + '0');
            cur1 = cur1->next;
        }
        while(cur2){
            s2.push_back(cur2->val + '0');
            cur2 = cur2->next;
        }
        
        // 字符串大数加法
        res = strAdd(s1, s2);
        
        // 字符串生成链表，注意边界（头节点）
        cur1 = head1;
        head1->val = res[0]-'0';
        for(int i=1; i<res.length(); i++){
            ListNode* newptr = new ListNode(res[i]-'0');
            cur1->next = newptr;
            cur1 = newptr;
        }
        return head1;
        
    }
};
```



方法二：

辅助栈



### <font color=purple>NC54 三数之和</font>

从前到后固定第一个数num[i]，然后双指针。左指针从i+1开始，右指针从末尾开始。

temp_sum = num[i]+num[left]+num[right];

如果和小于0，左指针右移；大于0，右指针左移；等于0，保存结果。并且把左右指针向内移动到不一样的地方。

此外，注意第一个数的选择不能重复。

```
class Solution {
public:
    vector<vector<int> > threeSum(vector<int> &num) {
        vector<vector<int>>res;
        if(num.size()<3) return res;
        
        sort(num.begin(), num.end());
        int left,right;
        for(int i=0; i<num.size()-2; i++){  // -2是要至少留两个位置
            if(i!=0 && num[i]==num[i-1])  // 第一个数不能重复
                continue;
            left = i+1;
            right = num.size()-1;
            while(left<right){
                int temp_sum = num[i]+num[left]+num[right];
                if(temp_sum==0){
                    res.push_back({num[i], num[left], num[right]});
                    // left向右移动到不同的元素
                    while(left+1<right && num[left]==num[left+1]) left++;
                    left++;
                    // right向左移动到不同的元素
                    while(right-1>left && num[right]==num[right-1]) right--;
                    right--;
                }
                else if(temp_sum<0)
                    left++;
                else right--;
            }
        }
        return res;
    }
};
```



### <font color=dodgerblue>NC33 合并两个排序的链表</font>

我本来想的是固定res头指针指向pHead1，然后根据情况把链表2节点插入进来，但是不太行。因为头节点还需要比较大小，并且节点的插入涉及太多指针。

所以应该从头维护一个res链表，比较链表1和2的当前节点，把小的喂到res的后面。

```
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
    ListNode* Merge(ListNode* pHead1, ListNode* pHead2) {
        ListNode* cur1, *cur2;
        
        ListNode* vhead = new ListNode(0);  // 随机初始化一个头节点
        ListNode* cur = vhead;
        
        cur1 = pHead1; cur2 = pHead2;
        while(cur1 && cur2){
            if(cur1->val<=cur2->val){
                cur->next = cur1;
                cur1 = cur1->next;
            }
            else{
                cur->next = cur2;
                cur2 = cur2->next;
            }
            cur = cur->next;  // 前进一步
        }
        // 这时候可能还有剩余
        if(cur1)
            cur->next = cur1;
        else cur->next = cur2;
        
        return vhead->next;  // 去掉头部的初始化节点
    }
};
```





### <font color=purple>NC51 合并k个已排序的链表</font>

方法一：vector

投机取巧，都放到vector里。。排序

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *mergeKLists(vector<ListNode *> &lists) {
        vector<int>vec;
        if(lists.empty()) return nullptr;
        
        ListNode* cur;
        for(int i=0; i<lists.size(); i++){
            cur = lists[i];
            while(cur){
                vec.push_back(cur->val);
                cur = cur->next;
            }
        }
        sort(vec.begin(), vec.end());
        
        ListNode* pre = new ListNode(0);  // 随便定义一个非空的头节点
        ListNode* head = pre;
        for(int i=0; i<vec.size(); i++){
            cur = new ListNode(vec[i]);
            pre->next = cur;
            pre = cur;
        }
        head = head->next;  // 去掉开头的
        return head;
    }
};
```



方法二：分治合并

```
class Solution {
public:
    //对于两个链表的合并
    ListNode* mergeTwoLists(ListNode *a, ListNode *b) {
        if ((!a) || (!b)) return a ? a : b;
        ListNode head(0),*tail = &head, *aPtr = a, *bPtr = b;
        while (aPtr && bPtr) {
            if (aPtr->val < bPtr->val) {
                tail->next = aPtr; aPtr = aPtr->next;
            } else {
                tail->next = bPtr; bPtr = bPtr->next;
            }
            tail = tail->next;
        }
        tail->next = (aPtr ? aPtr : bPtr);
        return head.next;
    }
    //利用分治 对每一小组链表进行合并
    ListNode* merge(vector <ListNode*> &lists, int l, int r) {
        if (l == r) return lists[l];
        if (l > r) return nullptr;
        int mid = (l + r) >> 1;
        return mergeTwoLists(merge(lists, l, mid), merge(lists, mid + 1, r));
    }
    //对lists中每一
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        return merge(lists, 0, lists.size() - 1);
    }
};
```



### NC96 判断一个链表是否为回文结构

水题。放到vector里，双指针

```
/**
 * struct ListNode {
 *	int val;
 *	struct ListNode *next;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param head ListNode类 the head
     * @return bool布尔型
     */
    
    bool isPail(ListNode* head) {
        vector<int>vec;
        ListNode* cur = head;
        while(cur){
            vec.push_back(cur->val);
            cur = cur->next;
        }
        int l,r;
        for(l=0, r=vec.size()-1; l<r; l++, r--){
            if(vec[l]!=vec[r])
                return false;
        }
        return true;
    }
};
```



### NC134 买卖股票的最好时机(二)

双指针，注意边界！！！

<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gzhoy7qg6gj218w0p8wg3.jpg" alt="截屏2022-02-18 15.22.00" style="zoom: 33%;" />

只要两天之间是上涨的，那一定在两个端点买入卖出

```
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 计算最大收益
     * @param prices int整型vector 股票每一天的价格
     * @return int整型
     */
    int maxProfit(vector<int>& prices) {
        // 只要两天之间是上涨的，那一定要在i天买入
        int res = 0;
        int i, j;
        for(i=0; i<prices.size()-1; i++){
            int start = i;
            while(i+1<prices.size() && prices[i]<prices[i+1])
                i++;
            // 运行到这里，prices[i]>=prices[i+1]
            res += (prices[i] - prices[start]);

        }
        return res;
    }
};
```



### NC36 在两个长度相等的排序数组中找到上中位数

双指针，逐位移动。

两天没做题手生了！

```
class Solution {
public:
    /**
     * find median in two sorted array
     * @param arr1 int整型vector the array1
     * @param arr2 int整型vector the array2
     * @return int整型
     */
    int findMedianinTwoSortedAray(vector<int>& arr1, vector<int>& arr2) {
        if(arr1.size()==1)
            return min(arr1[0], arr2[0]);
        
        int index1, index2;
        int mid = (arr1.size()+arr2.size())/2;
        int count = 0;
        int res;
        for(index1 = 0, index2 = 0; index1<arr1.size() && index2<arr2.size() && count<mid; count++){
            if(arr1[index1]<arr2[index2]){
                res = arr1[index1];
                index1++;
            }
            else{
                res = arr2[index2];
                index2++;
            }
        }
        return res;
        
    }
};
```



### <font color=red>NC2 重排链表</font>

没思路的时候，画几个节点举个例子呗！

比如 1 2 3 4 5 6 7 8 9 10，重排后变成 1 <u>10</u> 2 <u>9</u> 3 <u>8</u> 4 <u>7</u> 5 <u>6</u>

奇数个时 1 2 3 4 5 6 7 8 9，重排后变成 1 <u>9</u> 2 <u>8</u> 3 <u>7</u> 4 <u>6</u> 5

这不就相当于，把链表切一半，后一半翻转，然后两个链表交替插入嘛？

找中点呗，在中点之后的翻转。比如上面 n=10时，mid=5；n=9时，mid=5。所以mid = (n+1)>>1

假设我们现在cur指向第mid个节点，先把链表切了，再翻转。（或者也可以直接 head2 = reverse(cur->next); cur->next = nullptr）

```
// 切断原链表的末尾
ListNode* ptr = cur->next;
cur->next = nullptr;
// 翻转mid+1到结尾的链表
ListNode* head2 = reverse(ptr);
```

翻转链表你会写吧，会吧会吧会吧？

不会写就去看 NC78，进阶的区间翻转在 NC21。这里用简单的NC78就行。

完整代码：

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverse(ListNode* head){  // 翻转以head为头的链表
        ListNode *cur, *pre, *nxt;
        cur = head; pre=nullptr;
        while(cur!=nullptr){
            nxt = cur->next;
            cur->next = pre;
            pre = cur;
            cur = nxt;
        }
        return pre;
    }
    
    void reorderList(ListNode *head) {
        if(head == nullptr) return;
        // 先计算结点个数n
        int count = 0;
        ListNode *cur = head;
        while(cur!=nullptr){
            count++;
            cur = cur->next;
        }
        // 指针指到第 (n+1)/2 个节点，设为mid
        int mid = (count+1)>>1;
        int temp = 1;
        cur = head;
        while(temp<mid){
            cur = cur->next;
            temp++;
        }// 此时cur指向第mid个节点

        // 切断原链表的末尾
        ListNode* ptr = cur->next;
        cur->next = nullptr;
        // 翻转mid+1到结尾的链表
        ListNode* head2 = reverse(ptr);
        
        // 两个列表交叉结合
        cur = head;
        ListNode* temp1, *temp2;
        while(head2!=nullptr){  // 将链表2的头节点插入到链表1
            // 保存状态
            temp1 = cur->next;
            temp2 = head2->next;
            // 插入
            cur->next = head2;
            head2->next = temp1;
            // 更新
            head2 = temp2;
            cur = temp1;
        }
    }
};
```



## 查找

### NC105 二分查找-II【美团】

从左到右第一个出现的target的下标

先判断小于和大于，最后的else再给等于。

找到目标值之后，向左查找，保证第一次出现。

```
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 如果目标值存在返回下标，否则返回 -1
     * @param nums int整型vector 
     * @param target int整型 
     * @return int整型
     */
    int search(vector<int>& nums, int target) {
        if(nums.size()==0 || nums[0]>target || nums[nums.size()-1] < target)
            return -1;
        int l = 0;
        int r = nums.size()-1;
        while(l<=r){
//             printf("%d %d\n", l, r);
            int mid = (l+r)/2;
            if(nums[mid]<target){
                l = mid+1;
            }
            else if(nums[mid]>target){
                r = mid-1;
            }
            else{  // 找到目标，继续向左
                while(mid>0 && nums[mid-1]==target){
                    mid--;
                }
                return mid;
            }
        }
        return -1;
    }
};
```



方法二：

直接lower_bound

```
int search(vector<int>& nums, int target) {
        if(nums.size()==0 || nums[0]>target || nums[nums.size()-1] < target)
            return -1;
        
        int index = lower_bound(nums.begin(), nums.end(), target) - nums.begin();
        if(index==0){  // index==0可能本来就是0，也可能是没找到
            if(nums[0]!=target)
                return -1;
        }
        return index;
    }
```



### NC32 求平方根

二分查找

```
class Solution {
public:
    /**
     * 
     * @param x int整型 
     * @return int整型
     */
    int sqrt(int x) {
        if(x==0) return 0;
        if(x<4) return 1;
        
        long long left, right, mid;
        left = 1; right = x;
        long long temp;
        while(left<=right){
            mid = (left+right)/2;
            temp = mid*mid;
            if(temp >x){
                right = mid-1;
            }
            else if(temp<x){
                left = mid+1;
            }
            else return mid;
        }
        return right;
        
    }
};
```



### <font color=purple>NC48 在旋转过的有序数组中寻找目标值</font>

方法一：

头尾相连。使用mod。（复杂度 O(n)）

在查找过程中肯定是一直沿着一个方向走，所以最多循环n次一定能找到。

如果中途出现了左右摇摆，说明不存在。提前退出。

```
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param nums int整型vector 
     * @param target int整型 
     * @return int整型
     */
    int search(vector<int>& nums, int target) {
        int len = nums.size();
        int n = len;  // 用来循环
        int i = 0;
        
        int left = 0;
        int right = 0;
        while(n--){
            if(left && right)  // 如果出现左右摇摆，提前终止
                return -1;
            if(nums[i%len]<target){  // 往右走
                i = (i+1)%len;
                right = 1;
            }
            else if(nums[i%len]>target){
                i = (i+len-1)%len;  // 往左走
                left = 1;
            }
            else return i;
        }
        // 遍历完了还没找到一定是不存在
        return -1;
    }
};
```



方法二：二分查找（复杂度 O(logn))

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gzehmas2n9j31880t2my1.jpg" alt="截屏2022-02-15 20.50.39" style="zoom: 25%;" />

mid = (left+right)/2。 [left, mid] 和 [mid, right] 总有一个区间是单调的。

哪个区间单调可以通过 nums[left], nums[mid] 的大小判断。

以在 [left, mid] 单调为例：

如果target不在 left到mid这段区间，则一定是 nums[mid]<target || nums[left]>target，此时就舍弃这个区间，left = mid+1。

如果在，就 right = mid-1

```
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param nums int整型vector 
     * @param target int整型 
     * @return int整型
     */
    int search(vector<int>& nums, int target) {
        int left, right, mid;
        left = 0; right = nums.size()-1;
        
        while(left<=right){
            mid = (left+right)>>1;
            if(nums[mid]==target)
                return mid;
            
            if(nums[mid]>=nums[left]){  // 左侧单调
                if(nums[mid]<target || nums[left]>target){  // target不在 [left, mid] 里
                    left = mid+1;
                }
                else right = mid-1;
            }
            else{  // 左侧非单调，则右侧一定单调
                if(nums[mid]>target || nums[right]<target){
                    right = mid-1;
                }
                else{
                    left = mid+1;
                }
            }
        }
        
        return -1;
    }
};
```





### <font color=purple>NC30 缺失的第一个正整数</font>

有多种解法。

先排序然后找（时间O(nlogn)，空间O(1)）、辅助map（时间O(n)，空间O(n)）、交换法（时间O(n)，空间(O(1))。

前面两个方法很显然，这里只写交换法。

```
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param nums int整型vector 
     * @return int整型
     */
    int minNumberDisappeared(vector<int>& nums) {

        int n = nums.size();
        for(int i=0; i<nums.size(); i++){
            // 如果在[1, n]之内且位置不对。 （默认位置对表示为 nums[i] = i+1）
            // 一直换，直到这个位置正确 或者 这个位置有负数
            while(nums[i]>=1 && nums[i]<=n && nums[i]!=i+1){
                swap(nums[i], nums[nums[i]-1]);
            }
        }
        for(int i=0; i<n; i++){
            if(nums[i]!=i+1){  // 如果还有错乱的，说明这个位置没有对应的正数
                return i+1;
            }
        }
        // 到这里说明都不错乱
        return  n+1;
    }
};
```



### NC95 数组中的最长连续子序列

题目要求空间O(n) 时间O(nlogn)，提示是并查集，但直接暴力排序+遍历似乎就行了。

方法一：暴力

```
class Solution {
public:
    /**
     * max increasing subsequence
     * @param arr int整型vector the array
     * @return int整型
     */
    int MLS(vector<int>& arr) {
        if(arr.size()==1) return arr[0];
        sort(arr.begin(), arr.end());
        
        int maxx = 1;
        int cur = 1;
        for(int i=1; i<arr.size(); i++){
            if(arr[i]==arr[i-1])
                continue;
            else if(arr[i]==arr[i-1]+1){
                cur++;
                maxx = max(maxx, cur);
            }
            else cur = 1;  // 重置
        }
        return maxx;
    }
};
```



方法二：并查集思想（因为顺手这里用的map，实际上应该用set更省空间）

```
class Solution {
public:
    /**
     * max increasing subsequence
     * @param arr int整型vector the array
     * @return int整型
     */
    map<int, int>exist;
    int MLS(vector<int>& arr) {
        if(arr.size()==1) return arr[0];
        exist.clear();
        
        for(int i=0; i<arr.size(); i++)
            exist[arr[i]] = 1;
        
        int maxx, cur, num;
        maxx = 1;
        for(int i=0; i<arr.size(); i++){
            if(exist[arr[i]-1]==1)  // 如果存在在它前面的，不能当作头
                continue;
            cur = 1;
            num = arr[i];
            while(exist[num+1]==1){  // 从头开始向后找
                cur++;
                maxx = max(cur, maxx);
                num++;
            }
        }
        
        return maxx;
    }
};
```



## 搜索

### NC109 岛屿数量

一次性的dfs，甚至不需要开辟visited

```
class Solution {
public:
    /**
     * 判断岛屿数量
     * @param grid char字符型vector<vector<>> 
     * @return int整型
     */
    int dir[4][2] = {{1, 0}, {-1,0}, {0,1}, {0,-1}};
    int count = 0;
    int m,n;
    
    void dfs(vector<vector<char> >& grid, int curx, int cury){
        int newx, newy;
        for(int i=0; i<4; i++){
            newx = curx+dir[i][0];
            newy = cury+dir[i][1];
            if(newx<0 || newx>=m || newy<0 || newy>=n)// 越界
                continue;
            if(grid[newx][newy]=='1'){
                grid[newx][newy] = '0';
                dfs(grid, newx, newy);
            }
        }
    }
        
    int solve(vector<vector<char> >& grid) {
        if(grid.empty()) return 0;
        m = grid.size(); n = grid[0].size();

        
        for(int i=0; i<m; i++){
            for(int j=0; j<n; j++){
                if(grid[i][j]=='1'){
                    grid[i][j] = '0';
                    dfs(grid, i, j);
                    count++;
                }
            }
        }
        return count;
    }
};
```





### <font color=red>NC86 矩阵元素查找</font>

### NC29 二维数组中的查找（与NC86完全相同）

**同 [lc]面试题 10.09. 排序矩阵查找**

2022.02.15 字节面试题

https://leetcode-cn.com/problems/sorted-matrix-search-lcci/

以前做过！！！但面试时突然懵逼了。

我就记得有序矩阵好像需要转换一下思路！！

从左下角开始搜索，那么只需要向上和向右搜索就行。最坏情况下的时间复杂度是O(m+n)

```
class Solution {
public:

    bool search(vector<vector<int>>& matrix, int curx, int cury, int target){
        if(matrix[curx][cury]==target)
            return true;
        
        int newx, newy;

        if(matrix[curx][cury]<target){  // 向右
            newx = curx;
            newy = cury+1;
        }
        else{  // 向上
            newx = curx-1;
            newy = cury;
        }

        if(newx<0 || newx >=matrix.size() || newy<0 || newy>=matrix[0].size()){
            // 什么都不干
        }
        else{
            if(search(matrix, newx, newy, target))
                return true;
        }

        return false;
    }

    bool searchMatrix(vector<vector<int>>& matrix, int target) {

        if(matrix.empty() || matrix[0].empty()){
            return false;
        }
            
        if(target<matrix[0][0] || target > matrix[matrix.size()-1][matrix[0].size()-1])
            return false;
        
        // 从左下角搜索！！！！
        return search(matrix, matrix.size()-1, 0, target);
    }
};
```



### NC26 括号生成

DFS 暴力搜索+剪枝。

水题。

```
class Solution {
public:
    /**
     * 
     * @param n int整型 
     * @return string字符串vector
     */
    vector<string>vec;
    
    void dfs(string cur, int n, int l, int r){
        if(l==n && r==n){
            vec.push_back(cur);
        }

        if(l+1<=n){
            dfs(cur+"(", n, l+1, r);
        }
        if(r+1<=n && r+1<=l){
            dfs(cur+")", n, l, r+1);
        }
    }
    
    vector<string> generateParenthesis(int n) {
        if(n==0) return vec;
        dfs("", n, 0, 0);
        return vec;
    }
};
```



### NC43 没有重复项数字的全排列

笑死，看题。没有重复数字。。。我还用了BKDR Hash，先放着吧。

简单DFS

```
class Solution {
public:
    
    vector<vector<int>> res;  // 结果
    vector<int>temp;  // 临时
    map<long long, bool>exist;  // vector 使用BKDR Hash
    bool visited[7];  // 原数组第i位是否visit
    
    // BKDR Hash
    int seed = 1331;
    bool existed(){
        long long res = 0;
        for(int i=0; i<temp.size(); i++){
            res = res*seed + temp[i];
        }
        res = res & 0x7fffffff;
        
        // 如果已经存在，返回重复。 不存在，就新增到map
        if(exist.find(res)!=exist.end())
            return true;
        else exist[res] = true;
        
        return false;
    }
    
    void dfs(vector<int> &num, int pos){
        if(pos==num.size()){
            if(!existed())
                res.push_back(temp);
            return ;
        }
        
        for(int i=0; i<num.size(); i++){
            if(!visited[i]){
                temp.push_back(num[i]);
                visited[i] = true;
                dfs(num, pos+1);
                temp.pop_back();
                visited[i] = false;
            }
        }
    }
    
    vector<vector<int> > permute(vector<int> &num) {
        if(num.empty()) return res;
        sort(num.begin(), num.end());
        memset(visited, false, sizeof(visited));
        dfs(num, 0);
        return res;
    }
};
```



### NC42 有重复项数字的全排列

和NC43 当时写的代码一样。。BKDR Hash

也可以while直接调用next_permutation(num.begin(), num.end())

```
class Solution {
public:
    
    vector<vector<int>> res;  // 结果
    vector<int>temp;  // 临时
    map<long long, bool>exist;  // vector 使用BKDR Hash
    bool visited[9];  // 原数组第i位是否visit
    
    // BKDR Hash
    int seed = 1331;
    bool existed(){
        long long res = 0;
        for(int i=0; i<temp.size(); i++){
            res = res*seed + temp[i];
        }
        res = res & 0x7fffffff;
        
        // 如果已经存在，返回重复。 不存在，就新增到map
        if(exist.find(res)!=exist.end())
            return true;
        else exist[res] = true;
        
        return false;
    }
    
    void dfs(vector<int> &num, int pos){
        if(pos==num.size()){
            if(!existed())
                res.push_back(temp);
            return ;
        }
        
        for(int i=0; i<num.size(); i++){
            if(!visited[i]){
                temp.push_back(num[i]);
                visited[i] = true;
                dfs(num, pos+1);
                temp.pop_back();
                visited[i] = false;
            }
        }
    }
    
    vector<vector<int> > permuteUnique(vector<int> &num) {
        if(num.empty()) return res;
        sort(num.begin(), num.end());
        memset(visited, false, sizeof(visited));
        dfs(num, 0);
        return res;
    }
};
```



### <font color=orange>NC46 加起来和为目标值的组合(二)</font>

DFS+剪枝。

你以前应该能很快做出来的！

两个关键剪枝：1. 遇到与前一位相同的（continue） 2. 加上当前位溢出了，那后面的也会溢出（break）

```
class Solution {
public:
    
    vector<vector<int>>res;
    vector<int>temp;
    unordered_map<long long, bool>exist;

    bool existed(){
        int seed = 1313;
        long long rt = 0;
        for(int i=0; i<temp.size(); i++){
            rt = rt*seed + temp[i];
        }
        rt = rt&0x7fffffff;
        if(exist.find(rt)==exist.end()){
            exist[rt] = true;
            return false;  // 不存在
        }
        return true; // 重复了
    }
    
    // pos表示当前temp里的元素位置，index是原数组num的当前元素下标
    bool dfs(vector<int> &num, int pos, int index, int target){
        if(target==0){
//             if(!existed())
            res.push_back(temp);
            return true;
        }
        
        for(int i=index; i<num.size(); i++){  // 不会往前搜索
            if(target-num[i]<0) break;  // 加上该位就超了，后面的也超。
            if(i-1>=index && num[i]==num[i-1])  // 如果第pos位的index遇到重复的，就跳过。
                continue;
            temp.push_back(num[i]);
            dfs(num, pos+1, i+1, target-num[i]);  // 找到符合条件的之后，就不用往后找了
            temp.pop_back();
        }
        return false;
    }
    
    vector<vector<int> > combinationSum2(vector<int> &num, int target) {
        if(num.empty()) return res;
        sort(num.begin(), num.end());
        dfs(num, 0, 0, target);
        return res;
    }
};
```





### NC20 数字字符串转化成IP地址

dfs+剪枝。

节省时间的剪枝：剩余的元素个数够不够

判断是否合法：转int后小于255，并且超过1位后不能用零开头。

```
class Solution {
public:
    /**
     * 
     * @param s string字符串 
     * @return string字符串vector
     */
    vector<vector<string>>res;
    vector<string>ans;
    string str;
    
    bool valid(string str){  // 判断str是否合法
//         if(str.length()<1 || str.length()>3) return false;
        if(str.length()>1 && str[0]=='0') return false;  // 超过1位后，不能用0开头
        if(stoi(str)<=255) return true;
        return false;
    }
    
    void dfs(string s, vector<string>cur, int pos, int start){  // pos表示当前第几段，start表示开始下标
        if(pos<4){
            // 剪枝，从start开始，至少还需要 4-pos个元素
            // 最后一个元素的坐标是 start+4-pos-1 要求 <= s.length()-1
            if(start-pos+4 >s.length()) return ;
        }
        else{  // pos>=4 或者说 ==4
            if(start!=s.length()) return ;  // 不能剩
            res.push_back(cur);
            return ;
        }
        
        for(int k=1; k<=3; k++){  // 每一段的长度。区间就是[start, start+k-1]
            if(start+k-1 < s.length()){
                str = s.substr(start, k);
                if(valid(str)){
                    cur.push_back(str);
                    dfs(s, cur, pos+1, start+k);
                    cur.pop_back();
                }
            }
        }
    }
    
    vector<string> restoreIpAddresses(string s) {
        vector<string>cur;
        dfs(s, cur, 0, 0);
        
        string temp;
        for(int i=0; i<res.size(); i++){
            temp = res[i][0];
            for(int j=1; j<res[i].size(); j++){
                temp.push_back('.');
                temp+=res[i][j];
            }
            ans.push_back(temp);
        }
        return ans;
        
    }
};
```



## 排序

### NC140 排序【美团】【字节】

快排。（这一版写的不好，参考 <font color=red>NC119 NC88</font> 的 partition）

```
void quickSort(int* a, int left, int right){
//    printf("%d, %d\n", left, right);
    if(left >= right)  // 这里要是大于等于！！！！
        return;
    if(left+1==right){  // 仅两个元素
        if(a[left]>a[right]){
            swap(a[left], a[right]);
        }
        return;
    }
    
    int tempV = a[left];  // 首元素
    int tempI = left;
    int index1 = left, index2 = right;

    while(index1<index2){
        while(index1 < index2 && a[index2]>=tempV)  // 从右边数直到有一个小于首元素的停止
            index2--;
        a[tempI] = a[index2];  // 用该元素填坑
        tempI = index2;
        
        while(index1 < index2 && a[index1]<=tempV)  // 从左边数知道有一个大雨首元素的停止
            index1++;
        a[tempI] = a[index1];  // 填刚才的坑
        tempI = index1;
    }  // 循环结束 index1 == index2
    a[index1] = tempV;
//    printArray(a);
    quickSort(a, left, index1);
    quickSort(a, index1+1, right);
}
```



### <font color=orange>NC119 最小的K个数</font>【美团】【字节】

https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=117&&tqId=37765&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking

1. 直接sort
2. **优先队列**：大顶堆，如果达到size后，判断新来的是否比队首小，如果小，则pop并放入新的。
3. 快排

对数组[l, r]一次快排partition过程可得到，[l, p), p, [p+1, r]三个区间

[l,p)为小于等于p的值，[p+1,r]为大于等于p的值。

然后再判断p，利用二分法



1. 如果[l,p), p，也就是p+1个元素（因为下标从0开始），如果p+1 == k, 找到答案
2. 如果p+1 < k, 说明答案在[p+1, r)区间内
3. 如果p+1 > k , 说明答案在[l, p)内

```
class Solution {
public:
    int partition(vector<int>& vec, int l, int r){  // [l, r]
        int randm = rand()%(r-l+1) + l;  // 随机取一个座位pivot
        swap(vec[randm], vec[r]);
        
        int pivot = vec[r];
        int i = l;
        for(int j=l; j<r; j++){
            if(vec[j]<pivot){
                swap(vec[i], vec[j]);
                i++;  // i永远指向第一个不小于pivot的元素
            }
        }
        swap(vec[i], vec[r]);
        return i;
    }
    
    vector<int> GetLeastNumbers_Solution(vector<int> input, int k) {
        vector<int>res;
        if(k==0 || k>input.size())
            return res;
        int left, right, index;
        left = 0;
        right = input.size()-1;
        while(left<=right){
            index = partition(input, left, right);
            if(index+1 < k){  // 答案在右半边
                left = index+1;
            }
            else if(index+1 > k){  // 答案在左半边
                right = index-1;
            }
            else{
                return vector<int>({input.begin(), input.begin()+k});
            }
        }
        return res;
    }
};
```



优先队列解法

```
class Solution {
public:
    priority_queue<int> q;  // 大顶堆
    vector<int> GetLeastNumbers_Solution(vector<int> input, int k) {
        while(!q.empty()) q.pop();
        
        vector<int>res;
        int count = 0;
        if(k==0 || k>input.size())
            return res;
        
        for(int i=0; i<input.size(); i++){
            if(count<k){
                q.push(input[i]);
                count++;
            }
            else{
                int temp = q.top();  // 堆顶元素
                if(temp>input[i]){  // 如果新来的更小，放入堆，替换掉堆顶
                    q.pop();
                    q.push(input[i]);
                }
            }
        }
        while(!q.empty()){
            res.push_back(q.top());
            q.pop();
        }
        return res;
    }
};
```



### NC88 寻找第K大【美团】【字节】

https://www.nowcoder.com/practice/e016ad9b7f0b45048c58a9f27ba618bf?tpId=117&&tqId=37791&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking

快排+二分

```
class Solution {
public:
    
    int partition(vector<int> &input, int l, int r) {  // [l, r]
        int randm = rand()%(r-l+1) + l;
        swap(input[randm], input[r]);
        
        int pivot = input[r];
        int i = l;
        for (int j=l; j<r; ++j) {
            if (input[j] < pivot) {
                swap(input[i++], input[j]);  // i每次更新后永远指向第一个大于等于pivot的数
            }
        }
        swap(input[i], input[r]);
        return i;
    }
    
    int findKth(vector<int> a, int n, int K) {
        // 第K大，就是从小到大排序后 索引为 n-K
        int l = 0;
        int r = n-1;
        int curI;
        while(l<r){
            curI = partition(a, l, r);
            
            if(curI > n-K){
                r--;
            }
            else if(curI<n-K){
                l++;
            }
            else{
                return a[curI];
            }
        }
        return a[curI];
        
        
    }
};
```



### NC22 合并两个有序的数组【美团】

https://www.nowcoder.com/practice/89865d4375634fc484f3a24b7fe65665?tpId=188&&tqId=38585&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking

双指针 从后往前归并排序

```
class Solution {
public:
    void merge(int A[], int m, int B[], int n) {
        int end = m+n-1;
        int i = m-1;
        int j = n-1;
        
        while(i>=0 && j>=0){
            if(A[i]>=B[j]){
                A[end--] = A[i--];
            }
            else{
                A[end--] = B[j--];
            }
        }

        while(j>=0){  // B还有元素
            A[end--] = B[j--];
        }

    }
};
```



### NC70 单链表的排序【美团】

https://www.nowcoder.com/practice/f23604257af94d939848729b1a5cda08?tpId=188&&tqId=38554&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking

单链表排序，放到vector里，排完再放回去。

```
/**
 * struct ListNode {
 *	int val;
 *	struct ListNode *next;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param head ListNode类 the head node
     * @return ListNode类
     */
    ListNode* sortInList(ListNode* head) {
        // write code here
        vector<int>vec;
        ListNode* cur = head;
        while(cur){
            vec.push_back(cur->val);
            cur = cur->next;
        }
        sort(vec.begin(), vec.end());
        cur = head;
        for(int i=0; i<vec.size(); i++){
            cur->val = vec[i];
            cur = cur->next;
        }
        return head;
    }
};
```



### ⚠️NC131 数据流中的中位数

找中位数。

方法一：插入排序

```
class Solution {
public:
    vector<int>vec;
    
    void Insert(int num) {
        if(vec.empty())
            vec.push_back(num);
        else{
            // 插入排序
            vector<int>::iterator it = lower_bound(vec.begin(), vec.end(), num);
            vec.insert(it, num);
        }
        
    }

    double GetMedian() { 
        int len = vec.size();
        if(len &1){
            return vec[len>>1];
        }
        else{
            return ((double)vec[len>>1] + (double)vec[(len-1)>>1])/2;
        }
    }

};
```



方法二：大小堆





### <font color=purple>NC73 数组中出现次数超过一半的数字</font>

技巧题。

出现次数超过一半说明什么？说明这个数字比剩下的所有数字都多。

那来一个抵消一个就是了。最极端情况下，其他数字均与这个数相抵，那这个数字仍然还剩着。

其他情况下，可能其他数字内部相抵消了，那剩的更多。

```
class Solution {
public:
    int MoreThanHalfNum_Solution(vector<int> numbers) {
        map<int, int>count;
        int cur;
        for(int i=0; i<numbers.size(); i++){
            if(count.empty()){  // 当前还没有数字
                count[numbers[i]]++;  // 放入map
                cur = numbers[i];  // cur表示当前数字
            }
            else{  // 当前有数字了
                if(cur==numbers[i])  // 增加自己
                    count[cur]++;
                else{  // 抵消1个
                    count[cur]--;
                    if(count[cur]==0)
                        count.erase(cur);
                }
            }
        }
        // 最后map一定只剩一个
        return count.begin()->first;
    }
};
```



哦其实可以不用map，直接维护一个count 就行了。

```
class Solution {
public:
    int MoreThanHalfNum_Solution(vector<int> numbers) {
        int count = 0;
        int cur = 0;
        for(int i=0; i<numbers.size(); i++){
            if(count==0){  // 当前还没有数字
                count++;
                cur = numbers[i];  // cur表示当前数字
            }
            else{  // 当前有数字了
                if(cur==numbers[i])  // 增加自己
                    count++;
                else count--;  // 抵消1个
            }
        }
        // 最后map一定只剩一个
        return cur;
    }
};
```



### <font color=fuchsia>NC118 数组中的逆序对</font>

容易理解，但很难想到。

评论区Dylan大佬的方法：

> 归并统计法，关键点在于合并环节，在合并数组的时候，当发现**右边的小于左边**的时候，此时可以直接求出当前产生的逆序对的个数
>
> 举个例子：
>
> 在合并 {4 ,5} {1 , 2} 的时候，首先我们判断 4 > 1，我们即可统计出逆序对为2，为什么呢？这利用了数组的部分有序性。因为我们知道 {4 ,5} 这个数组必然是有序的，因为是合并上来的。此时当 1比4小的时候，证明4以后的数也都比1大，此时就构成了从4开始到 {4,5}这个数组结束，这么多个逆序对（2个），此时利用一个临时数组，将1存放起来，接着比较2和4的大小，同样可以得到有2个逆序对，于是将2也放进临时数组中，此时右边数组已经完全没有元素了，则将左边剩余的元素全部放进临时元素中，最后将临时数组中的元素放进原数组对应的位置。
>
> 最后接着向上合并~

完整代码：

```
class Solution {
public:
    int temp[100001];
    long long res = 0;
    long long kmod = 1000000007;
    
    void merge(vector<int>& data, int l, int mid, int r){
        int cur = 0;
        int i, j;
        i = l; j=mid+1;  // 别初始化错了！！！！！！！！！
        while(i<=mid && j<=r){
            if(data[i]<=data[j]){
                temp[cur++] = data[i++];
            }
            else{  // data[i] > data[j] 既然左边数组第i个位置比data[j]大，那第i到末尾都比data[j]大
                res += (mid-i+1);
                res = res%kmod;
                temp[cur++] = data[j++];
            }
        }
        while(i<=mid) temp[cur++] = data[i++];
        while(j<=r) temp[cur++] = data[j++];
        
        for(cur = 0; cur<r-l+1; cur++){
            data[l+cur] = temp[cur];
        }
    }
    
    void mergeSort(vector<int>& data, int l, int r){  // [l, r]
        if(l>=r) return ;
        
        int mid = (l+r)>>1;
        mergeSort(data, l ,mid);
        mergeSort(data, mid+1, r);
        
        merge(data, l, mid, r);
    }
    
    int InversePairs(vector<int> data) {
        if(data.empty()) return 0;
        mergeSort(data, 0, data.size()-1);
        
        return (int)res;
    }
};
```







## 数据结构

### <font color=red>NC93 设计LRU缓存结构</font>【美团】【字节】

https://www.nowcoder.com/practice/e3769a5f49894d49b871c09cadd13a61?tpId=117&&tqId=37804&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking

我先自己写了一下。list用的是push_back和erase。其他答案也有用push_front和erase的。都一样， 只不过iterator是开始还是结尾的差别。

get操作：

根据map查询list的iter

​	如果有，根据iter去list取值。并把list当前位置的iter删除，重新添加。然后更新map

​	否则return -1

set操作：

list是否已满

​	满了，找到list里最不常使用的（在头/尾）iter，删除map里对应的key，删除list该指针

插入新的。

⚠️ xxx::iterator 不能用+1，-1运算。应该是先初始化，然后iter++或iter--。我的方法是list尾部是最新的，头部最旧的。所以每次插入尾部的iter时，需要先 iter = L.end(); iter-- 然后map里才可以插入iter

```
class Solution {
public:
    /**
     * lru design
     * @param operators int整型vector<vector<>> the ops
     * @param k int整型 the k
     * @return int整型vector
     */
    list<pair<int, int>>L;
    unordered_map<int, list<pair<int, int>>::iterator>pos;
    
    int get(int key){
        int target = -1;
        // 根据map查询iter
        // 如果有，根据iter去list取值；否则return -1
        if(pos.find(key)==pos.end())
            return target;
        else{
            list<pair<int, int>>::iterator iter = pos[key];
            target = iter->second;
            // 更新list和pos
            L.erase(iter);  // 删除
            L.push_back(make_pair(key, target));  // 重新放进去
            // 把末尾的指针放进去
            iter = L.end();
            iter--;
            pos[key] = iter;
            return target;
        }
    }
    
    void set(int key, int value, int k){
        if(L.size()>=k){  // 把list队头的拿掉
            pos.erase(L.begin()->first);
            L.erase(L.begin());
        }
        // 放入新的
        L.push_back(make_pair(key, value));
        list<pair<int, int>>::iterator iter = L.end();
        iter--;
        pos[key] = iter;
    }
    
    vector<int> LRU(vector<vector<int> >& operators, int k) {
        vector<int>res;
        if(operators.empty())
            return res;
        L.clear();
        pos.clear();
        
        int opt,key,value,target;
        for(int i=0; i<operators.size(); i++){
            opt = operators[i][0];
            key = operators[i][1];
            if(opt==1){  // set
                value = operators[i][2];
                set(key, value, k);
            }
            else{  // get
                target = get(key);
                res.push_back(target);

            }
        }
        return res;
    }
};
```



```
#include <unordered_map>
class Solution {
public:
    /**
     * lru design
     * @param operators int整型vector<vector<>> the ops
     * @param k int整型 the k
     * @return int整型vector
     */
    int capacity;
    list<pair<int, int>> lrulist;//双端队列模拟
    unordered_map<int, list<pair<int, int>>::iterator> lrumap;//map的value放的是引用
    vector<int> LRU(vector<vector<int> >& operators, int k) {
        // write code here
        vector<int> res;
        capacity = k;
        if(operators.empty())
            return res;
        for(auto it = operators.begin(); it != operators.end(); ++it){
            vector<int> temp = *it;
            if(temp[0] == 1)
                set(temp[1], temp[2]);
            else{
                res.push_back(get(temp[1]));
            }
                
        }
        return res;
    }
    
    void set(int key, int value){
        auto it = lrumap.find(key);
        if(it == lrumap.end()){//没找到
            if(lrumap.size() == capacity){//满了，删除最久未使用
                lrumap.erase(lrulist.back().first);  // back()函数返回一个引用，指向list的最后一个元素
                lrulist.pop_back();
            }
        }
        else//找到了 删除提前
            lrulist.erase(it->second);
        lrulist.push_front({key, value});
        lrumap[key] = lrulist.begin();//begin：返回一个迭代器 front：返回引用
    }
    
    int get(int key){
        auto it = lrumap.find(key);
        if(it == lrumap.end())
            return -1;
        int val = it->second->second;//找到了，记录值并把它提到最前面
        lrulist.erase(it->second);
        lrulist.push_front(*it->second);//*迭代器为其指向的元素
        return val; 
    }
    
};
```



### <font color=fuchsia>NC94 设计LFU缓存结构</font>

复杂结构小顶堆，**cache，record，LFU分别维护**！

cache只存储 key value映射，record存放key对应的 count和timestamp信息。

LFU根据record中的信息，找出count最小并且timestamp最早的dkey（所以使用小顶堆），进行删除。

双优先队列inq、deq实现插入和删除：

**inq用来记录插入，deq用来记录删除。每次删除时，向deq插入删除数据，假装删除。当必要时（需要调用LFU返回dkey）， inq和deq互相抵消堆顶来进行真正的删除。**

每次set和get都需要更新record！



轩神给我讲解后，我按照理解写的版本：

```
class Solution {
public:
    /**
     * lfu design
     * @param operators int整型vector<vector<>> ops
     * @param k int整型 the k
     * @return int整型vector
     */
    
    int timestamp = 0;
    map<int, int>cache;  // key -> value
    map<int, pair<int, int>>record;  // key -> (count, timestamp)
    // 小顶堆 ((count, timestamp), key)
    priority_queue<pair<pair<int, int>, int>, vector<pair<pair<int, int>, int>>, greater<pair<pair<int, int>, int>>> inq, deq;
    
    
    void update_record(int key){  // 更新key对应的count和timestamp信息
        ++timestamp;
        if(record.count(key)){
            deq.push(make_pair(make_pair(record[key].first, record[key].second), key));
            record[key].first++;
            record[key].second = timestamp;
            inq.push(make_pair(make_pair(record[key].first, record[key].second), key));
        }
        else{
            record[key] = make_pair(1, timestamp);
            inq.push(make_pair(make_pair(1, timestamp), key));
        }
    }
    
    int query_LFU(){
        while(!inq.empty() && !deq.empty()){
            if(inq.top() == deq.top()){
                inq.pop();
                deq.pop();
            }
            else break;
        }
        return inq.top().second;  // 返回要删除的元素的key
    }
    
    vector<int> LFU(vector<vector<int> >& operators, int k) {
        vector<int>ans;
        if(operators.empty())
            return ans;

        for(auto oper : operators){
            if(oper[0]==1){  // set
                if(cache.count(oper[1])){  // 有这个元素
                    cache[oper[1]] = oper[2];
                    update_record(oper[1]);
                }
                else{  // 没有这个元素
                    if(cache.size()<k){  // 不用删除其他的
                        cache[oper[1]] = oper[2];
                        update_record(oper[1]);
                    }
                    else{
                        // 通过LFU策略返回要删除的key，执行删除然后再插入
                        int dkey = query_LFU();
                        deq.push(make_pair(make_pair(record[dkey].first, record[dkey].second), dkey));
                        cache.erase(dkey);
                        record.erase(dkey);
                        // 插入
                        cache[oper[1]] = oper[2];
                        update_record(oper[1]);
                    }
                }
            }
            else if(oper[0]==2){  // get
                if(cache.count(oper[1])){
                    ans.push_back(cache[oper[1]]);
                    update_record(oper[1]);  // get也要更新！！！
                }
                else ans.push_back(-1);
            }
        }
        return ans;
    }
};
```



轩神源代码：（偷懒一下，虽然用的大顶堆，但每次插入时加个负号变成小顶堆）

```
class Solution {
public:
    /**
     * lfu design
     * @param operators int整型vector<vector<>> ops
     * @param k int整型 the k
     * @return int整型vector
     */
    
    map<int, int> cache;

    int timestamp = 0;
    map<int, pair<int,int> > record;  // key -> (count, timestamp)
    // inq用来记录插入，deq用来记录删除。每次删除时，向deq插入删除数据，假装删除。当必要时， inq和deq互相抵消堆顶来进行真正的删除。
    priority_queue<pair<pair<int,int>,int> > inq, deq;  // ((count, timestamp), key)
    
    void update_record(int key) {
        ++timestamp;
        if(record.count(key)) {  // 删除旧的，更新count和时间戳，再放进去
            deq.push(make_pair(make_pair(-record[key].first, -record[key].second), key));
            record[key].first++;
            record[key].second = timestamp;
            inq.push(make_pair(make_pair(-record[key].first, -record[key].second), key));
        } else {  // 放进去新的
            record[key] = make_pair(1, timestamp);
            inq.push(make_pair(make_pair(-1, -timestamp), key));
        }
    }
    int query_LFU() {  // LFU决策，返回应该被删除的key
        while(!inq.empty() && !deq.empty()) {
            if(inq.top() == deq.top()) {
                inq.pop();
                deq.pop();
            } else {  // 如果 inq.top()!= deq.top()，说明 inq.top()没有被删除
                break;
            }
        }
        return inq.top().second;
    }
    vector<int> LFU(vector<vector<int> >& operators, int k) {
        vector<int> ans;

        for(auto oper : operators) {
            if(oper[0] == 1) {  // set
                if(cache.count(oper[1])) {  // cache已有数据，简单的更新
                    cache[oper[1]] = oper[2];
                    update_record(oper[1]);
                } else {  // 插入新的元素
                    if(cache.size() < k) {
                        cache[oper[1]] = oper[2];
                        update_record(oper[1]);
                    } else {  // 缓存满了，需要根据LFU决策删除小次数和最早访问的元素，再插入
                        int dkey = query_LFU();
                        deq.push(make_pair(make_pair(-record[dkey].first, -record[dkey].second), dkey));
                        record.erase(dkey);
                        cache.erase(dkey);

                        cache[oper[1]] = oper[2];
                        update_record(oper[1]);
                    }
                }
            } else if(oper[0] == 2) {  // get
                if(cache.count(oper[1])) {
                    ans.push_back(cache[oper[1]]);
                    update_record(oper[1]);
                } else {
                    ans.push_back(-1);
                }
            }
        }
        
        return ans;
    }
};
```



### NC61 两数之和

哈希。

在数组中找出两个加起来等于目标值的数的下标。

```
class Solution {
public:
    /**
     * 
     * @param numbers int整型vector 
     * @param target int整型 
     * @return int整型vector
     */
    unordered_map<int, int>pos;
    vector<int> twoSum(vector<int>& numbers, int target) {
        // write code here
        pos.clear();
        vector<int>res;
        
        for(int i=0; i<numbers.size(); i++){
            if(pos.find(target-numbers[i])==pos.end()){  // map中没有该元素的互补元素
                if(pos.find(numbers[i])==pos.end()){
                    pos[numbers[i]] = i;
                }
            }
            else{
                res.push_back(pos[target-numbers[i]]+1);
                res.push_back(i+1);
            }
        }
        return res;
    }
};
```



### ⚠️NC41 最长无重复子数组

方法一：暴力（不推荐）

子数组一定是连续的，那就不断固定起始位置，往后找，直到遇到重复的。时间复杂度 O(n^2)。竟然没超时...

小的优化是把 for(int i=0; i<arr.size(); i++) 改成 for(int i=0; i<arr.size()-maxl; i++) 剪枝一下。

```
class Solution {
public:
    /**
     * 
     * @param arr int整型vector the array
     * @return int整型
     */
    unordered_map<int, bool>visited;
    int maxLength(vector<int>& arr) {
        if(arr.size()==0)
            return 0;
        
        visited.clear();
        int maxl = 1;
        
        for(int i=0; i<arr.size(); i++){
            visited[arr[i]] = true;
            int cur = 1;
            for(int j=i+1; j<arr.size(); j++){
                if(visited.find(arr[j])!=visited.end()){  // 已存在，打破循环
                    break;
                }
                else{
                    visited[arr[j]] = true;
                    cur++;
                }
            }
            maxl = max(maxl, cur);
            visited.clear();  // 清空所有
        }
        return maxl;
    }
};
```



方法二：队列

把元素不停的加入到队列中，如果有相同的元素，就把队首的元素移除，直到不包含相同元素。

```
class Solution {
public:
    /**
     * 
     * @param arr int整型vector the array
     * @return int整型
     */
    unordered_map<int, bool>visited;
    queue<int>q;
    int maxLength(vector<int>& arr) {
        if(arr.size()==0)
            return 0;
        
        visited.clear();
        while(!q.empty()) q.pop();
        
        int maxl = 0;
        
        for(int i=0; i<arr.size(); i++){
            // 如果队列有相同的元素了
            while(visited.find(arr[i])!= visited.end()){
                int temp = q.front();
                q.pop();
                visited.erase(temp);
            }
            // 这时候已经被清除了
            q.push(arr[i]);
            visited[arr[i]] = true;
            maxl = max(maxl, (int)q.size());
        }
        return maxl;
    }
};
```





方法三：双指针队列

思想相同，只不过用left和right当队头队尾。



方法四：

暂时搁置



### NC52 有效括号序列

简单的匹配括号。用栈。

注意判断栈空。

```
class Solution {
public:
    /**
     * 
     * @param s string字符串 
     * @return bool布尔型
     */
    bool isValid(string s) {
        // write code here
        stack<char>st;
        for(int i=0; i<s.length(); i++){
            if(s[i]=='(' || s[i]=='[' || s[i]=='{')
                st.push(s[i]);
            else{
                if(st.empty()) return false;  // 来了右半边但栈空，无匹配
                if(s[i]==')'){
                    if(st.top()=='(')
                        st.pop();
                    else return false;
                }
                else if(s[i]==']'){
                    if(st.top()=='[')
                        st.pop();
                    else return false;
                }
                else if(s[i]=='}'){
                    if(st.top()=='{')
                        st.pop();
                    else return false;
                }
            }
        }
        if(!st.empty())  // 栈不空，还有字符没匹配
            return false;
        else return true;
    }
};
```



### NC75 数组中只出现一次的两个数字

一个整型数组里除了两个数字只出现一次，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。

第一次出现时写入map，既然其他的数字都出现了两次，那第二次出现时把它从map里删了就是。

map的key默认是有序的。

```
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param array int整型vector 
     * @return int整型vector
     */
    map<int, bool>visited;  // map的key本身就是有序的
    vector<int> FindNumsAppearOnce(vector<int>& array) {
        vector<int>res;
        if(array.empty()) return res;
        
        visited.clear();
        for(int i=0; i<array.size(); i++){
            if(visited.find(array[i])==visited.end())
                visited[array[i]] = true;
            else visited.erase(array[i]);  // 既然其他的都出现两次，那直接第二次出现时把它删掉
        }
        map<int, bool>::iterator iter;
        for(iter = visited.begin(); iter!=visited.end(); iter++){
            res.push_back(iter->first);
        }
        return res;
    }
};
```





### <font color=red>NC90 包含min函数的栈</font>

使用辅助栈实现O(1)时间得到正常栈的最小值。

注意！minx在push和pop时都要更新。

```
class Solution {
public:
    
    stack<int>normal;
    stack<int>minimal;  // 辅助栈
    int minx = 10001;
    
    void push(int value) {
        if(minx >value)
            minx = value;
        normal.push(value);
        minimal.push(minx);
    }
    void pop() {
        normal.pop();
        minimal.pop();
        minx = minimal.top();  // 要更新！
    }
    int top() {
        return normal.top();
    }
    int min() {
        return minimal.top();
    }
};
```



### NC97 字符串出现次数的TopK问题

1. 用map统计次数
2. 用结构体表示(str, count) 放入到vector中进行排序
3. 排完序取前k个作为结果

记得int转string 是用 to_string函数

```
class Solution {
public:
    /**
     * return topK string
     * @param strings string字符串vector strings
     * @param k int整型 the k
     * @return string字符串vector<vector<>>
     */
    map<string, int>count;
    
    struct node{
        string str;
        int c;
        node(string str, int c): str(str), c(c){}
    };
    
    static bool cmp(node a, node b){
        if(a.c == b.c)
            return a.str < b.str;  // 频数一样时，字典序小的排前面
        else return a.c > b.c;  // 频数大的在前面
    }
    
    vector<vector<string> > topKstrings(vector<string>& strings, int k) {
        vector<vector<string>>res;
        
        for(int i=0; i<strings.size(); i++)  // 统计次数
            count[strings[i]]++;
        
        // 把map里的放到vec中准备排序
        map<string, int>::iterator it;
        vector<node>vec;
        for(it=count.begin(); it!=count.end(); it++){
            vec.push_back(node(it->first, it->second));
        }
        sort(vec.begin(), vec.end(), cmp);

        // 排完序后取前k个放到结果里
        for(int i=0; i<k; i++)
            res.push_back({vec[i].str, to_string(vec[i].c)});
        
        return res;
    }
};
```



### <font color=red>NC82 滑动窗口的最大值</font>

第一次使用双端队列deque。

维护一个单调的队列（这里为了记录每个元素的有效期，队列里放置的索引）

循环判断如果当前元素比队尾的大，那么删除队尾。否则当前元素放在队尾。

使用索引和size比较判断是否过期。

每次返回队头的元素，也就是最大值。注意，前几个元素还不组成窗口，不要输出。

```
class Solution {
public:
    vector<int> maxInWindows(const vector<int>& num, unsigned int size) {
        vector<int>res;
        if(num.empty() || size>num.size()) return res;
        if(size==1) return num;
        
        deque<int>dq;  // 由于需要判断元素是否过期，dq存储的是索引，不是值。
        for(int i=0; i<num.size(); i++){
            // 把比当前位置小的都踢出去，用不到了
            while(!dq.empty() && num[dq.back()]<num[i])
                dq.pop_back();
            dq.push_back(i);  // 放在队尾
            
            // 检查一下队头是否过期
            while(!dq.empty() && dq.front()+size <= i )
                dq.pop_front();
            if(i>=size-1)  // 前几个元素还组不成窗口，不能输出
                res.push_back(num[dq.front()]);  // 把队头的最大的放进去
        }
        
        return res;
    }
};
```





## 二叉树

### NC45 实现二叉树先序，中序和后序遍历【美团】【字节】

https://www.nowcoder.com/practice/a9fec6c46a684ad5a3abd4e365a9d362?tpId=117&&tqId=37819&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking

```
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 * };
 */
#include <vector>
class Solution {
public:
    /**
     * 
     * @param root TreeNode类 the root of binary tree
     * @return int整型vector<vector<>>
     */
    vector<vector<int>>res;
    vector<int>temp;
    
    void preOrder(TreeNode* root){
        if(root==nullptr)
            return;
        temp.push_back(root->val);
        preOrder(root->left);
        preOrder(root->right);
        return ;
    }
    void inOrder(TreeNode* root){
        if(root==nullptr)
            return;
        
        inOrder(root->left);
        temp.push_back(root->val);
        inOrder(root->right);
        return ;
    }
    void postOrder(TreeNode* root){
        if(root==nullptr)
            return;
        
        postOrder(root->left);
        postOrder(root->right);
        temp.push_back(root->val);
        return ;
    }
    
    
    vector<vector<int> > threeOrders(TreeNode* root) {
        res.clear();
        temp.clear();
        preOrder(root);
        res.push_back(temp);
        
        temp.clear();
        inOrder(root);
        res.push_back(temp);
        
        temp.clear();
        postOrder(root);
        res.push_back(temp);

        return res;
    }
};
```



### NC13 二叉树的最大深度

BFS。

注意自定义的结构体，关于节点存的是指针。

```
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param root TreeNode类 
     * @return int整型
     */
    struct node{
        int level;
        TreeNode* ptr;
        node(){}
        node(int l, TreeNode* ptr): level(l), ptr(ptr){}
    };
    
    int maxDepth(TreeNode* root) {
        if(root==nullptr) return 0;
        int maxD = 0;
        queue<node>q;
        q.push(node(1, root));
        
        node temp;
        while(!q.empty()){
            temp = q.front();
            q.pop();
            
            if(temp.ptr->left)
                q.push(node(temp.level+1, temp.ptr->left));
            if(temp.ptr->right)
                q.push(node(temp.level+1, temp.ptr->right));
        }
        return temp.level;  // 只要取最后一个节点的level就行
        
    }
};
```





### NC15 求二叉树的层序遍历【美团】【字节】

BFS队列

结构体 存储节点指针以及层数。

每次超过当前最大层，push该层结果，然后清空。

注意！队列为空时退出了while，但还有一层结果记得push

```
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param root TreeNode类 
     * @return int整型vector<vector<>>
     */
    struct node{
        TreeNode* ptr;
        int level;
        node(TreeNode* p, int l): ptr(p), level(l){}
    };
    
    vector<vector<int> > levelOrder(TreeNode* root) {
        vector<vector<int>>res;
        if(root==nullptr){
            return res;
        }
        vector<int>temp;  // 用来存储一层
        queue<node>q;
        q.push(node(root, 0));
        int maxLevel = 0;  // 当前最大层
        int val;
        int level;
        while(!q.empty()){
            node point = q.front();
            q.pop();
            
            val = point.ptr->val;
            level = point.level;
            
//             printf("%d %d\n", val, level);
            
            if(level>maxLevel){  // 保存上一层结果，清空
                maxLevel = level;
                res.push_back(temp);
                temp.clear();
            }
            temp.push_back(val);
            
            if(point.ptr->left!=nullptr){
                q.push(node(point.ptr->left, level+1));
            }
            if(point.ptr->right!=nullptr){
                q.push(node(point.ptr->right, level+1));
            }
        }
        res.push_back(temp);  // 由于最后队列空了，最后一个temp没存
        return res;
    
    }
};
```



### NC14 按之字形顺序打印二叉树

NC 15 的进阶。

注意在循环中每次 level > maxLevel 时，temp就变成了上一层的结果。

跳出循环后，temp表示最后一层的结果，即level层。

```
/*
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }
    
};
*/
class Solution {
public:
    struct node{
        TreeNode* ptr;
        int level;
        node(TreeNode* p, int l): ptr(p), level(l){}
    };
    vector<vector<int> > Print(TreeNode* pRoot) {
        vector<vector<int>>res;
        if(pRoot==nullptr)
            return res;
        
        vector<int>temp;  // 用来存储一层
        queue<node>q;
        q.push(node(pRoot, 0));
        int maxLevel = 0;  // 当前最大层
        int val;
        int level;
        while(!q.empty()){
            node point = q.front();
            q.pop();
            
            val = point.ptr->val;
            level = point.level;
            
            if(level>maxLevel){  // 保存上一层结果，清空
                maxLevel = level;
                if(level & 1)  // temp 是上一层结果！所以如果当前level是奇，则上一层不用翻转
                    res.push_back(temp);
                else{
                    reverse(temp.begin(), temp.end());
                    res.push_back(temp);
                }
                temp.clear();
            }
            temp.push_back(val);
            
            if(point.ptr->left!=nullptr){
                q.push(node(point.ptr->left, level+1));
            }
            if(point.ptr->right!=nullptr){
                q.push(node(point.ptr->right, level+1));
            }
        }
        // 最后一层还没有输出
        if((level+1) & 1)  // 这里temp就是当前层结果了。
            res.push_back(temp);
        else{
            reverse(temp.begin(), temp.end());
            res.push_back(temp);
        }
        return res;
    }
    
};
```



### <font color=orange>NC6 二叉树最大路径和</font>【美团】

https://www.nowcoder.com/practice/da785ea0f64b442488c125b441a4ba4a?tpId=196&tqId=37050&rp=1&ru=/exam/oj&qru=/exam/oj&sourceUrl=%2Fexam%2Foj%3Ftab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D196%26page%3D1&difficulty=undefined&judgeStatus=undefined&tags=&title=

https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/

```
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param root TreeNode类 
     * @return int整型
     */
    int MAX_SUM = -1001;  // 即使全是负数，最小也不会小于-1001
    
    int maxGain(TreeNode* node){
        if(node==nullptr){
            return 0;
        }
        // 左右子树能给该节点的贡献值
        // 与0比较是因为，如果子树反而提供负贡献，就直接抛弃
        int left_gain = max(maxGain(node->left), 0);
        int right_gain = max(maxGain(node->right), 0);
        
        int cur_sum = node->val + left_gain + right_gain;  // 当前路径和
        MAX_SUM = max(MAX_SUM, cur_sum);
        return node->val + max(left_gain, right_gain);  // 每次只能选择一颗子树
    }
    int maxPathSum(TreeNode* root) {
        // write code here
        maxGain(root);
        return MAX_SUM;
    }
};
```



### <font color=orange>NC102 在二叉树中找到两个节点的最近公共祖先</font>

方法一：递归

设问题为`LCA(root, o1, o2)`, 该问题有以下递归性质：

- 如果o1和o2都在root的左子树中，那么`LCA(root, o1, o2) = LCA(root->left, o1, o2)`.
- 如果o1和o2都在root的右子树中，那么`LCA(root, o1, o2) = LCA(root->right, o1, o2)`.
- 如果一个在左子树，一个在右子树，显然root就是答案！

```
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param root TreeNode类 
     * @param o1 int整型 
     * @param o2 int整型 
     * @return int整型
     */
    TreeNode* LCA(TreeNode* node, int o1, int o2){
        if(node==nullptr)
            return nullptr;
        // 如果至少包含一个节点，那么直接返回自己
        if(node->val == o1 || node->val == o2)
            return node;
        // 查找左右子树。注意lnode, rnode不代表左右节点。而是左右子树里的公共祖先
        TreeNode *lnode, *rnode;
        lnode = LCA(node->left, o1, o2);
        rnode = LCA(node->right, o1, o2);
        
        if(lnode==nullptr)  // 如果左子树里没找到，那两个节点肯定都在右子树里
            return rnode;
        if(rnode==nullptr)
            return lnode;
        // 如果左子树右子树都包含目标节点，那公共祖先就是自己
        return node;
        
    }
    
    int lowestCommonAncestor(TreeNode* root, int o1, int o2) {
        TreeNode* node = LCA(root, o1, o2);
        return node->val;
    }
};
```



方法二：dfs

把从根节点到o1, o2的路径打印出来。

逐个比较，如果出现不一样的，就是这个不一样的父节点

如果都一样，返回短的最后一个节点。

```
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param root TreeNode类 
     * @param o1 int整型 
     * @param o2 int整型 
     * @return int整型
     */
    vector<int>vec1;
    vector<int>vec2;
    
    bool dfs(TreeNode* node, vector<int>& vec, int target){
        if(node->val == target)
            return true;
        
        if(node->left!=nullptr){
            vec.push_back(node->left->val);
            if(dfs(node->left, vec, target))
                return true;
            vec.pop_back();
        }
        if(node->right!=nullptr){
            vec.push_back(node->right->val);
            if(dfs(node->right, vec, target))
                return true;
            vec.pop_back();
        }
        return false;
    }
    
    int lowestCommonAncestor(TreeNode* root, int o1, int o2) {
        vec1.clear();
        vec2.clear();
        vec1.push_back(root->val);
        vec2.push_back(root->val);
        dfs(root, vec1, o1);
        dfs(root, vec2, o2);
        
        int len = min(vec1.size(), vec2.size());
        for(int i=0; i<len; i++){
            if(vec1[i]==vec2[i])
                continue;
            else return vec1[i-1];  // 如果不相等，则是父节点
        }
        // 能执行到这里说明短的vec包含在长的里
        return vec1[len-1];
    }
};
```



### NC12 重建二叉树

平平无奇重建二叉树

```
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    
    TreeNode* createTree(vector<int>& pre, vector<int>& vin, int prel, int prer, int vinl, int vinr){
        if(prel>prer)
            return nullptr;
        if(prel==prer)  // 只有一个节点
            return new TreeNode(pre[prel]);
        
        TreeNode* root = new TreeNode(pre[prel]);
        // 在vin的 [vinl, vinr]中找到root所在的位置
        int index;
        for(int i=vinl; i<=vinr; i++){
            if(vin[i]==root->val){
                index = i;
                break;
            }
        }
        int left_num = index-vinl;
        int right_num = vinr-index;
        
        root->left = createTree(pre, vin, prel+1, prel+left_num, vinl, index-1);
        root->right = createTree(pre, vin, prer-right_num+1, prer, index+1, vinr);
        
        return root;
    }
    
    
    TreeNode* reConstructBinaryTree(vector<int> pre,vector<int> vin) {
        return createTree(pre, vin, 0, pre.size()-1, 0, vin.size()-1);
    }
};
```



### [lc]<font color=orange>二叉树求和路径</font>

给定一棵二叉树，其中每个节点都含有一个整数数值(该值或正或负)。设计一个算法，打印节点数值总和等于某个给定值的所有路径的数量。注意，路径不一定非得从二叉树的根节点或叶节点开始或结束，但是其方向必须向下(只能从父节点指向子节点方向)。

https://leetcode-cn.com/problems/paths-with-sum-lcci/

思路就是把所有节点都当作根节点，即每个节点都使用一次dfs函数

dfs函数这里不用额外一个参数维护从起始节点到当前节点的节点值总和，而是**直接修改sum**,也可以达到相同的效果,

如果sum==0，则是一个有效答案,ans++

而在主函数中递归调用自己,保证所有节点都能使用到dfs函数

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int ans;
    void dfs(TreeNode *root,int sum){
        if(root==NULL)
            return ;
        sum-=root->val;
        if(sum==0)
            ans++; // 不能直接return，因为可能有节点为0
            
        dfs(root->left,sum);
        dfs(root->right,sum);
        return;
    }
    int pathSum(TreeNode* root, int sum) {
        if(root==NULL)
            return 0;
        dfs(root,sum);
        pathSum(root->left,sum);
        pathSum(root->right,sum);
        return ans;
    }
};
```



### NC136 输出二叉树的右视图

根据前序+中序重建二叉树，层序遍历。

```
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 求二叉树的右视图
     * @param xianxu int整型vector 先序遍历
     * @param zhongxu int整型vector 中序遍历
     * @return int整型vector
     */
    struct node{
        int level;
        TreeNode* tn;
        node(){}
        node(int l, TreeNode* tn): level(l), tn(tn){}
    };
    
    TreeNode* createTree(vector<int>& pre, vector<int>& in, int prel, int prer, int inl, int inr){
//         printf("%d %d %d %d\n", prel, prer, inl, inr);
        if(prel>prer)
            return nullptr;
        if(prel==prer)
            return new TreeNode(pre[prel]);
        
        TreeNode* root = new TreeNode(pre[prel]);  // 必须这样初始化！！!
        // in 的 [inl, inr] 找到root->val
        int index;
        for(int i=inl; i<=inr; i++){
            if(in[i]==root->val)
                index = i;
        }
        int left_num = index - inl;
        int right_num = inr - index;
        
        root->left = createTree(pre, in, prel+1, prel+left_num, inl, index-1);
        root->right = createTree(pre, in, prer-right_num+1, prer, index+1, inr);
        
        return root;
    }

    
    vector<int> solve(vector<int>& xianxu, vector<int>& zhongxu) {
        int len = xianxu.size();
        TreeNode* root = createTree(xianxu, zhongxu, 0, len-1, 0, len-1);
        
        vector<int>vec;
        queue<node>q;
        q.push(node(1,root));
        
        node temp;
        node pre(1, nullptr);  // pre保持和root一样，防止pre被压进结果
        while(!q.empty()){
            temp = q.front();
            q.pop();
            if(temp.level != pre.level){
                vec.push_back(pre.tn->val);
            }
            pre = temp;
            
            if(temp.tn->left){
                q.push(node(temp.level+1, temp.tn->left));
            }
            if(temp.tn->right){
                q.push(node(temp.level+1, temp.tn->right));
            }
        }
        vec.push_back(temp.tn->val);  // 最后一个节点
        return vec;
    }
};
```



### <font color=purple>NC62 判断是不是平衡二叉树</font>

递归！！注意看题。

平衡二叉树（Balanced Binary Tree），具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，**并且左右两个子树都是一棵平衡二叉树**。

```
class Solution {
public:
    
    int dfs(TreeNode* node, int curL){
        if(node==nullptr)
            return curL;
        
        int ll = dfs(node->left, curL+1);
        int rl = dfs(node->right, curL+1);
        
        return max(ll, rl);
    }
    
    bool IsBalanced_Solution(TreeNode* pRoot) {
        if(pRoot==nullptr)
            return true;
        int leftL = dfs(pRoot->left, 0);
        int rightL = dfs(pRoot->right, 0);
        
//         printf("%d %d", leftL, rightL);
        
        if(abs(leftL - rightL)<=1 && IsBalanced_Solution(pRoot->left) && IsBalanced_Solution(pRoot->right))
            return true;
        else return false;
    }
};
```



### NC5 二叉树根节点到叶子节点的所有路径和

简单dfs。

但是注意，统计的时刻应该是到达叶子结点（left == nullptr && right == nullptr），而不是当前节点为空时。

```
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param root TreeNode类 
     * @return int整型
     */
    int sum = 0;
    
    void dfs(TreeNode* node, string cur){
        string temp = cur;  // 不可能有空节点进入dfs
        temp.push_back(node->val+'0');
        
        // 注意，只有左右子树都为空的时候才算叶子结点
        if(node->left == nullptr && node->right == nullptr){
            sum += stoi(temp);
            return ;
        }

        if(node->left){
            dfs(node->left, temp);
        }
        if(node->right){
            dfs(node->right, temp);
        }

    }
    
    int sumNumbers(TreeNode* root) {
        if(root==nullptr)
            return 0;
        else{
            dfs(root, "");
            return sum;
        }
    }
};
```



### NC8 二叉树中和为某一值的路径(二)

平平无奇DFS

```
/*
struct TreeNode {
	int val;
	struct TreeNode *left;
	struct TreeNode *right;
	TreeNode(int x) :
			val(x), left(NULL), right(NULL) {
	}
};*/
class Solution {
public:
    vector<vector<int>> res;
    vector<int>temp;
    
    
    void dfs(TreeNode* node, int expectNumber){
        if(expectNumber == node->val){
            if(!node->left && !node->right){  // 只有叶子结点才能retrun
                res.push_back(temp);
                return ;
            }
        }
        
        expectNumber -= node->val;
        
        if(node->left){
            temp.push_back(node->left->val);
            dfs(node->left, expectNumber);
            temp.pop_back();
        }
        if(node->right){
            temp.push_back(node->right->val);
            dfs(node->right, expectNumber);
            temp.pop_back();
        }
    }
    
    vector<vector<int>> FindPath(TreeNode* root,int expectNumber) {
        if(root==nullptr)
            return res;
        temp.push_back(root->val);
        dfs(root, expectNumber);
        
        return res;
    }
};
```



### NC9 二叉树中和为某一值的路径(一)

NC8 你都会，这比它更简略。

```
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param root TreeNode类 
     * @param sum int整型 
     * @return bool布尔型
     */
    bool dfs(TreeNode* node, int expectNumber){
        if(expectNumber == node->val){
            if(!node->left && !node->right){  // 只有叶子结点才能retrun
                return true;
            }
        }
        
        expectNumber -= node->val;
        
        if(node->left){
            if(dfs(node->left, expectNumber))
                return true;
        }
        if(node->right){
            if(dfs(node->right, expectNumber))
                return true;;
        }
        return false;
    }
    
    bool hasPathSum(TreeNode* root, int sum) {
        if(root==nullptr)
            return false;
        return dfs(root, sum);
    }
};
```



### NC98 判断t1树中是否有与t2树完全相同的子树

递归。

两个函数，一个isContains，一个isEqual

因为树中的值是两两不同的，所以在isContains里，如果root1->val不等于root2->val，就继续递归root1的左右子树，只要左右子树有一个contains就行，所以是return (isContains(root1->left, root2) || isContains(root1->right, root2));

在isContains的递归里，如果遇到root1->val == root2->val （此root1和上一行的root1意义不一定一样），则必须检查root1的所有结构和root2是否相同。此时该调用isEqual。return isEqual(node1->left, node2->left) && isEqual(node1->right, node2->right);

```
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param root1 TreeNode类 
     * @param root2 TreeNode类 
     * @return bool布尔型
     */
    
    bool isEqual(TreeNode* node1, TreeNode* node2){
        if(node1==nullptr && node2==nullptr) return true;
        if(node1==nullptr || node2==nullptr) return false;
        
        // 到这里说明node1和node2都有值
        if(node1->val != node2->val)
            return false;
        return isEqual(node1->left, node2->left) && isEqual(node1->right, node2->right);
    }
    
    bool isContains(TreeNode* root1, TreeNode* root2) {
        if(root1 == nullptr) return false;
        if(root1->val == root2->val){  // 如果相等了，必须左右子树全部相等
            return (isEqual(root1->left, root2->left) && isEqual(root1->right, root2->right));
        }
        
        return (isContains(root1->left, root2) || isContains(root1->right, root2));
    }
};
```



### <font color=dodgerblue>NC60 判断一棵二叉树是否为搜索二叉树和完全二叉树</font>

判断一棵二叉树是否为「二叉搜索树」的通用方法为：对该二叉树进行中序遍历，若遍历结果为「严格」单调递增的，则是一棵二叉搜索树，否则不是。

判断一棵树是否为「完全二叉树」的方式为：对其进行层次遍历，若遇到一个空结点，则其后面的结点必须全为空结点，否则不是完全二叉树。在这里改变了一下实现，**如果有缺少左儿子或者右儿子，但是该节点有儿子（不是叶子结点），返回false。 如果二叉树节点有右儿子但是没有左儿子，直接返回false）**

```
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param root TreeNode类 the root
     * @return bool布尔型vector
     */
    vector<int>vec;
    void inOrder(TreeNode* node){
        if(node==nullptr)
            return ;
        inOrder(node->left);
        vec.push_back(node->val);
        inOrder(node->right);
    }
    
    vector<bool> judgeIt(TreeNode* root) {
        bool res1, res2;
        inOrder(root);
        res1 = true;
        if(vec.size()<=1) res1 = true;
        else{
            for(int i=0; i<vec.size()-1; i++){
//                 printf("%d ", vec[i]);
                if(vec[i]>=vec[i+1]){
                    res1 = false;
                    break;
                }
            }
        }
        
        res2 = true;
        
        queue<TreeNode*>q;
        if(root)
            q.push(root);
        TreeNode* temp;
        int flag = 0;
        // 完全二叉树在遇到空节点之后剩余的应当全是空节点
        while(!q.empty()){
            temp = q.front();
            q.pop();
            
            // 如果flag为1，且存在节点左右子树不为空，则false
            if(flag && (temp->left || temp->right)){
                res2 = false;
                break;
            }
            // 左右子树有一个为空
            if(temp->left == nullptr || temp->right == nullptr){
                if(temp->right){  // 只有左子树为空，一定不是
                    res2 = false;
                    break;
                }
                else{
                    flag = 1;  // 只有右子树为空，或者两个子树都为空
                    if(temp->left) q.push(temp->left);
                    continue;
                }
            }
            
            // 到这里说明左右子树都不为空
            q.push(temp->left);
            q.push(temp->right);
            
        }
        return vector<bool>{res1, res2};
    }
};
```







## 动态规划

### NC68 跳台阶

简单斐波那契。

注意空间复杂度为 O(1)，所以要开常数空间。

dp[i%3] = dp[(i-1)%3] + dp[(i-2)%3]

```
class Solution {
public:
    int jumpFloor(int number) {
        int dp[3];
        
        dp[1] = 1;
        dp[2] = 2;
        if(number<3)
            return dp[number];
        
        for(int i=3; i<=number; i++){
            dp[i%3] = dp[(i-1)%3] + dp[(i-2)%3];
        }
        return dp[number%3];
    }
};
```



### NC65 斐波那契数列

O(n)解法和上一题一样。

```
class Solution {
public:
    int Fibonacci(int n) {
        if(n<=2) return 1;
        int dp[3];
        dp[1] = 1;
        dp[2] = 1;
        for(int i=3; i<=n; i++){
            dp[i%3] = dp[(i-1)%3] + dp[(i-2)%3];
        }
        return dp[n%3];
    }
};
```

O(logn)解法：

矩阵快速幂

https://www.cnblogs.com/simplc/p/6742928.html





### NC19 连续子数组的最大和

开常数空间。

dp[i%2] = max(dp[(i-1)%2], 0) + array[i]

```
class Solution {
public:
    int FindGreatestSumOfSubArray(vector<int> array) {
        int n = array.size();
        if(n==1){
            return array[0];
        }
        
        int dp[2];
        dp[0] = array[0];
        
        int max_sum = dp[0];
        for(int i=1; i<n; i++){
            dp[i%2] = max(dp[(i-1)%2], 0) + array[i];
            max_sum = max(max_sum, dp[i%2]);
        }
        return max_sum;
    }
};
```





### 最长公共子序列（LCS）【美团】

https://leetcode-cn.com/problems/longest-common-subsequence/

```
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int m = text1.length();
        int n = text2.length();
        int dp[m+1][n+1];
        memset(dp, 0, sizeof(dp));

        text1.insert(0, " ");
        text2.insert(0, " ");

        for(int i=1; i<=m; i++){
            for(int j=1; j<=n; j++){
                if(text1[i] == text2[j])
                    dp[i][j] = dp[i-1][j-1] + 1;
                else{
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
                }
            }
        }
        return dp[m][n];
    }
};
```



### NC92 最长公共子序列(二)

最长公共子序列+输出此序列。

复原时从后往前。

```
class Solution {
public:
    /**
     * longest common subsequence
     * @param s1 string字符串 the string
     * @param s2 string字符串 the string
     * @return string字符串
     */
    string LCS(string s1, string s2) {
        string res;
        s1.insert(0, " ");
        s2.insert(0, " ");
        
        int dp[s1.length()+1][s2.length()+1];
        
        for(int j=0; j<s2.length(); j++)
            dp[0][j] = 0;
        for(int i=0; i<s1.length(); i++)
            dp[i][0] = 0;
        
        int maxx = -1;
        for(int i=1; i<s1.length(); i++){
            for(int j=1; j<s2.length(); j++){
                if(s1[i]==s2[j]){
                    dp[i][j] = dp[i-1][j-1]+1;
                }
                else{
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
                }
                maxx = max(maxx, dp[i][j]);
            }
        }
        if(maxx<=0)
            return "-1";
        
        // 复原
        for(int i=s1.length()-1, j=s2.length()-1; i>=1 && j>=1; ){
            if(s1[i]==s2[j]){
                res.push_back(s1[i]);
                i--; j--;
            }
            else{
                if(dp[i][j]==dp[i-1][j]){
                    i--;
                }
                else j--;
            }
        }
        reverse(res.begin(), res.end());
        return res;
    }
};
```



### NC127 最长公共子串

```
class Solution {
public:
    /**
     * longest common substring
     * @param str1 string字符串 the string
     * @param str2 string字符串 the string
     * @return string字符串
     */
    string LCS(string str1, string str2) {
        // write code here
        int len1 = str1.length();
        int len2 = str2.length();
        
        
        int dp[len1+1][len2+1];
        memset(dp, 0, sizeof(dp));
        
        // 处理边界
        str1.insert(0, " ");
        str2.insert(0, " ");
        // dp[0][0] = 0;
        
        int maxC = 0;
        string res;
        for(int i=1; i<=len1; i++){
            for(int j=1; j<=len2; j++){
                if(str1[i]==str2[j]){
                    dp[i][j] = dp[i-1][j-1] +1;
                    if(maxC < dp[i][j]){
                        maxC = dp[i][j];
                        // 子串长度为dp[i][j]
                        res = str1.substr(i-dp[i][j]+1, dp[i][j]);
                    }
                }
                // else dp[i][j] = 0;
            }
        }
        return res;
    }
};
```





### <font color=red>NC 91 最长上升子序列(三)</font>

HDU 5748 的加工！https://vjudge.net/problem/HDU-5748

select 和 level 的数组求解方式一样，但是这一题最后还要逆序放入结果。

level以到自己为止最长上升子序列的长度作为元素。level[i]表示到自己为止的最长上升序列的长度。

select 并不是结果！

例如 输入 [2,1,5,3,6,4,8,9,7]，得到select [1, 3, 4, 7, 9], level [1, 1, 2, 2, 3, 3, 4, 5, 4]。select只是用来计算level用的，且select的长度就是最长上升子序列的长度。

得到level后，逆序放入。

```
class Solution {
public:
    /**
     * retrun the longest increasing subsequence
     * @param arr int整型vector the array
     * @return int整型vector
     */
    
    vector<int> LIS(vector<int>& arr) {
        vector<int>select;  // 最长临时序列，不是输出！！！
        vector<int>level(arr.size());  // level[i]表示到自己为止的最长上升序列的长度

        
        for(int i=0; i<arr.size(); i++){
            if(i==0 || arr[i]>select[select.size()-1]){
                select.push_back(arr[i]);
                level[i] = select.size();
            }
            else{
                // 找出第一个大于等于arr[i]的位置
                int index = lower_bound(select.begin(), select.end(), arr[i])-select.begin();
                select[index] = arr[i];
                level[i] = index+1;
            }
        }
        // select的长度就是最长上升子序列的长度
        vector<int>res(select.size());
        // 从原始数组中逆序放入
        for(int i=arr.size()-1, j=select.size(); i>=0; i--){
            if(level[i]==j){
                res[--j] = arr[i];
            }
        }
        return res;
    }
};
```



### <font color=purple>NC128 接雨水问题</font>

我觉得是上升（非严格）子序列和下降子序列问题。但我直接用的模拟。

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gzby76p3hzj30ky0eymxd.jpg" alt="截屏2022-02-13 16.08.36" style="zoom:33%;" />

例如，输入[3,1,2,<font color=red>5</font>,2,4]  

填满雨水后变成 [3, 3, 3, <font color=red>5</font>, 4, 4]

所以只要找到最大值，最大值左边都非下降，右边的非上升。

```
if(arr[i]<arr[i-1]){  // 左边
  res += (arr[i-1]-arr[i]);
  arr[i] = arr[i-1];
}

....

if(arr[i]<arr[i+1]){  // 右边
	res += (arr[i+1]-arr[i]);
	arr[i] = arr[i+1];
}
```

注意答案要用long long

完整代码：

```
class Solution {
public:
    /**
     * max water
     * @param arr int整型vector the array
     * @return long长整型
     */
    long long maxWater(vector<int>& arr) {
        if(arr.size()<=1) return 0;
        long long maxx, pos;
        maxx = -1; pos = -1;
        // 找最大值和所在的位置
        for(int i=0; i<arr.size(); i++){
            if(arr[i]>maxx){
                maxx = arr[i];
                pos = i;
            }
        }
        long long res = 0;
        // 在pos左边应该是上升子序列，右边是下降子序列
        for(int i=1; i<pos; i++){
            if(arr[i]<arr[i-1]){
                res += (arr[i-1]-arr[i]);
                arr[i] = arr[i-1];
            }
        }
        for(int i=arr.size()-2; i>pos; i--){
            if(arr[i]<arr[i+1]){
                res += (arr[i+1]-arr[i]);
                arr[i] = arr[i+1];
            }
        }
        return res;
    }
};
```



### NC7 买卖股票的最好时机(一)

其实用不着dp，直接暴力就行。。

方法一：dp

dp[i] 表示一定在i位置卖出。（如果前面没有买入，即dp[i]=0，可以当作在i买了又卖了）

例如，输入 [8,9,2,5,4,7,1]

计算得dp[1] = 1，说明在9时卖出可以得1。如果后面的数字大于9，那直接加上差值，没问题。

但如果后面的数字小于当前，比如9后面的2。先计算 dp[i-1] + prices[i] - prices[i-1]，看看仍然在原来的位置买入，在当前点卖出亏不亏。如果不亏，ok那还有利润可以留着；如果亏了，那不在原来的位置买入了，就在自己这里买。所以 dp[i] = max(0, dp[i-1] + prices[i] - prices[i-1]);

```
class Solution {
public:
    /**
     * 
     * @param prices int整型vector 
     * @return int整型
     */
    int maxProfit(vector<int>& prices) {
        if(prices.size()<2) return 0;
        
        int maxx = 0;
        int dp[prices.size()];
        memset(dp, 0, sizeof(dp));
        
        for(int i=1; i<prices.size(); i++){
            if(prices[i]>=prices[i-1]){
                dp[i] = dp[i-1] + prices[i] - prices[i-1];
            }
            else{
                dp[i] = max(0, dp[i-1] + prices[i] - prices[i-1]);
            }
            maxx = max(maxx, dp[i]);
        }
        return maxx;
    }
};
```



方法二：常规

```
class Solution {
public:
    /**
     * 
     * @param prices int整型vector 
     * @return int整型
     */
    int maxProfit(vector<int>& prices) {
        if(prices.size()<2) return 0;
        
        int minx = 0x3ffffff;
        int res = -1;
        
        for(int i=0; i<prices.size(); i++){
            minx = min(minx, prices[i]);
            res = max(res, prices[i]-minx);
        }
        return res;
    }
};
```





### <font color=fuchsia>NC35 编辑距离(二)</font>

最短编辑距离。

给定两个字符串str1和str2，再给定三个整数ic，dc和rc，分别代表插入、删除和替换一个字符的代价，请输出将str1编辑成str2的最小代价。

动态规划。dp\[i]\[j] 表示 原始串str1\[0:i-1] 编辑成 str2\[0: j-1] 的代价。这里我对str1和str2前面insert了一个空格，处理一下边界。

所以变成了 dp\[i]\[j] 表示 str1\[0:i] 编辑成 str2\[0: j] 的代价。 就是说，不管你怎么操作，操作完之后只剩下str1的 i+1之后的字符 和str2的 j+1之后的字符。不能把str1的i或str2的j留到后面。

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gzce5f7lx6j319m0rkjvj.jpg" alt="截屏2022-02-14 01.20.38" style="zoom:40%;" />

解释一下 str1[i] != str2[j] 时的情况：

- 插入str2[j]: （图中 <font color=deepskyblue>j</font> 的位置写错了，应该在i后面）
  - 既然插入一个j和str2的j位置对齐了，那i咋办？肯定是要放在前面和j-1对齐了。所以是 dp\[i]\[j-1] + ic
- 删除str1[i]：
  - 第i位对不齐是吧，爷不要了。让str2[j] 去和 i的前一位对齐去。就是 dp\[i-1]\[j] + dc
- 替换，显然。



```
class Solution {
public:
    /**
     * min edit cost
     * @param str1 string字符串 the string
     * @param str2 string字符串 the string
     * @param ic int整型 insert cost
     * @param dc int整型 delete cost
     * @param rc int整型 replace cost
     * @return int整型
     */
    int minEditCost(string str1, string str2, int ic, int dc, int rc) {
        int dp[str1.size()+1][str2.size()+1];  // dp[i][j] 表示str1[0:i] 变成 str2[0:j]的最小编辑距离
        memset(dp, 0, sizeof(dp));
        
        for(int i=0; i<str1.size()+1; i++) dp[i][0] = dc*i;  // 只能删除
        for(int j=0; j<str2.size()+1; j++) dp[0][j] = ic*j;  // 只能插入
        
        // 边界
        str1.insert(0, " ");
        str2.insert(0, " ");
        
        for(int i=1; i<str1.size(); i++){
            for(int j=1; j<str2.size(); j++){
                if(str1[i]==str2[j]){
                    dp[i][j] = dp[i-1][j-1];
                }
                else{
                    dp[i][j] = min(min(dp[i][j-1]+ic, dp[i-1][j]+dc), dp[i-1][j-1] + rc);
                }
            }
        }
        return dp[str1.size()-1][str2.size()-1];
    }
};
```



可以看到只利用了本层和上一层。

那再使用滚动数组优化。注意！dp\[i%2][0] 是不同的。所以需要放在循环里初始化。

```
class Solution {
public:
    /**
     * min edit cost
     * @param str1 string字符串 the string
     * @param str2 string字符串 the string
     * @param ic int整型 insert cost
     * @param dc int整型 delete cost
     * @param rc int整型 replace cost
     * @return int整型
     */
    int minEditCost(string str1, string str2, int ic, int dc, int rc) {
        int dp[2][str2.size()+1];  // dp[i%2][j] 表示str1[0:i] 变成 str2[0:j]的最小编辑距离
        memset(dp, 0, sizeof(dp));
        
        // dp[i][0]等会在循环里初始化
        for(int j=0; j<str2.size()+1; j++) dp[0][j] = ic*j;  // 只能插入
        
        // 边界
        str1.insert(0, " ");
        str2.insert(0, " ");
        
        for(int i=1; i<str1.size(); i++){
            dp[i%2][0] = dc*i;
            for(int j=1; j<str2.size(); j++){
                if(str1[i]==str2[j]){
                    dp[i%2][j] = dp[(i-1)%2][j-1];
                }
                else{
                    dp[i%2][j] = min(min(dp[i%2][j-1]+ic, dp[(i-1)%2][j]+dc), dp[(i-1)%2][j-1] + rc);
                }
            }
        }
        return dp[(str1.size()-1)%2][str2.size()-1];
    }
};
```



### NC59 矩阵的最小路径和

动态规划水题，滚动数组优化。

注意边界的初始化！

```
class Solution {
public:
    /**
     * 
     * @param matrix int整型vector<vector<>> the matrix
     * @return int整型
     */
    int minPathSum(vector<vector<int> >& matrix) {
        if(matrix.empty() || matrix[0].empty())
            return 0;
        vector<vector<int>>dp(2, vector<int>(matrix[0].size(), 0));
        
        dp[0][0] = matrix[0][0];
        for(int j=1; j<matrix[0].size(); j++){
            dp[0][j] = dp[0][j-1] + matrix[0][j];
        }
        
        for(int i=1; i<matrix.size(); i++){
            dp[i%2][0] = dp[(i-1)%2][0] + matrix[i][0];  // 只能从上边来
            for(int j=1; j<matrix[0].size(); j++){
                dp[i%2][j] = min(dp[(i-1)%2][j], dp[i%2][j-1]) + matrix[i][j];
            }
        }
        return dp[(matrix.size()-1)%2][matrix[0].size()-1];
    }
};
```



### NC34 求路径

水题动态规划。m*n方格

常规方法就不写全了，

```
dp[i%2][j] = dp[(i-1)%2][j] + dp[i%2][j-1];
```

时间复杂度O(mn)，空间复杂度O(mn)，滚动数组优化后也仍然有O(n)

组合数学法：

由于在矩阵中没有障碍物，从左上角移动到右下角一共要移动m+n-2次，其中有m-1次向下，n-1次向右，对这两种操作进行组合。因此最后就是求$C_{m+n-2}^{m-1}$

时间复杂度O(min(m, n))，空间复杂度O(1)

```
int uniquePaths(int m, int n) {
    long long ret = 1;
    for (int x = n, y = 1; y < m; ++x, ++y) {
        //组合公式的循环求解
        ret = ret * x / y;
    }
    return ret;
}
```



### <font color=red>NC83 连续子数组的最大乘积</font>

本来我一开始想的是和连续子数组的和差不多，但是乘法的话，有负数和0。

特别是负数。

参考了题解，当前位置的最大乘积，只来源于三种情况：只有自己、前一位的最大值与自己相乘（比如和前一位最大值同号时）、前一位的最小值与自己相乘（比如和前一位最小值同号，和最大值异号）。

然后因为只使用前一位的，就不用开数组了，直接用pre进行循环更新前一位的信息。

```
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param nums int整型vector 
     * @return int整型
     */
    int maxProduct(vector<int>& nums) {
        if(nums.size()==1) return nums[0];
        
        int cur_max, cur_min, pre_max, pre_min;
        pre_max = nums[0]; pre_min = nums[0];
        int res = nums[0];
        
        for(int i=1; i<nums.size(); i++){
            // 反正一共只有三个选择
            cur_max = max(nums[i], max(pre_max*nums[i], pre_min*nums[i]));
            cur_min = min(nums[i], min(pre_max*nums[i], pre_min*nums[i]));
            res = max(res, cur_max);
            pre_max = cur_max;
            pre_min = cur_min;
        }
        
        return res;
        
    }
};
```





## 字符串

### <font color=purple>NC55 最长公共前缀</font>【美团】

https://www.nowcoder.com/practice/28eb3175488f4434a4a6207f6f484f47?tpId=188&&tqId=38627&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking

纵向扫描

```
class Solution {
public:
    /**
     * 
     * @param strs string字符串vector 
     * @return string字符串
     */
    string longestCommonPrefix(vector<string>& strs) {
        if(strs.size()==0)
            return "";
        // 纵向扫描
        for(int j=0; j<strs[0].size(); j++){
            for(int i=0; i<strs.size(); i++){
                // 如果strs[i]的第j位越界 或 如果第j位不相等
                if(j==strs[i].size() || strs[0][j] != strs[i][j])
                    return strs[0].substr(0, j);
            }
        }
        return strs[0];
    }
};
```



### <font color=fuchsia>NC17 最长回文子串</font>【美团】

**Manacher**算法

暴力方法就是 对于每个位置，先设置延伸长度 p[i] = 1，然后看 s[i-p[i]] 是否等于 s[i+p[i]]，不断扩大p[i]。

Manacher方法就是偷懒，即p[i] 的初始化。重点是关于mx 和 id 的设置。

```
int mx = 0;  // 当前最右位置
int id = -1;  // 达到最右位置时的中心
// 设置mx和id，意思是可以保证 [2id-mx, mx] 是对称的

...

if(mx>i){  // 此时的排列顺序是  2id-mx, ..., 2id-i, ..., id, ..., i, ..., mx
    // 我们想看看 i关于 id 的对称点 2id-i 的对称情况
    // [i, mx]这段相当于 [2id-mx, 2id-i]这段关于 id 对称
    // 所以就看 2*id-i 这点的延伸长度 和 它到边界 2id-mx 的距离大小了，选小的
    p[i] = min(p[2*id-i], mx-i);
}
```

完整代码：

```
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param A string字符串 
     * @return int整型
     */
    const static int MAXN = 1001;
    int p[2*MAXN+3];
    
    
    int Manacher(string newStr){
        int maxL = -1;  // 最长回文子串长度
        int mx = 0;  // 当前最右位置
        int id = -1;  // 达到最右位置时的中心
        // 设置mx和id，意思是可以保证 [2id-mx, mx] 是对称的
        for(int i=1; i<newStr.length(); i++){
            if(mx>i){  // 此时的排列顺序是  2id-mx, ..., 2id-i, ..., id, ..., i, ..., mx
                // 我们想看看 i关于 id 的对称点 2id-i 的对称情况
                // [i, mx]这段相当于 [2id-mx, 2id-i]这段关于 id 对称
                // 所以就看 2*id-i 这点的延伸长度 和 它到边界 2id-mx 的距离大小了，选小的
                p[i] = min(p[2*id-i], mx-i);
            }
            else p[i] = 1;
            while(newStr[i-p[i]]==newStr[i+p[i]])
                p[i]++;
            if(mx< i+p[i]){
                id = i;
                mx = i+p[i];
            }
            maxL = max(maxL, p[i]-1);  // 减1的原因，自己画着看就知道了
        }
        return maxL;
    }
    
    int getLongestPalindrome(string A) {
        int len = A.length();
        // 初始化
        string newStr(2*len+3, '#');
        int newLen = newStr.length();
        newStr[0] = '$'; newStr[newLen-1] = '*';
        for(int i=0, j=2; i<A.length(); i++, j+=2){
            newStr[j] = A[i];
        }  // 例如 A = "abcbc"，则newStr = "$#a#b#c#b#c#*"
        fill(p, p+newLen, 1);
        
        // Manacher返回的是插入分隔符后的延伸长度，所以最终返回应该除以2
        return Manacher(newStr);
        
    }
};
```



（如果需要写整个程序的代码，用这个）

```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string.h>
#include <algorithm>
#include <vector>
#include <map>
#include <cmath>
#include <queue>
using namespace std;
const int MAXN = 110005;
int p[MAXN*2];
char s[MAXN*2];
string str;
string newStr;

/*
    newStr的构成不仅仅是加个# 应该给原串加完#后，再在首尾加上 不一样 的 两个 符号 比如 str = 12321
    newStr = $#1#2#3#2#1#* 如果首尾一样，会出错!!!!!
*/
void init(){
    fill(p, p+MAXN, 1);
    //在这里 newStr别手贱前面写个string，而且newStr的⻓度是2*str.length()+3
    newStr = string(2*str.length()+3, '#');
    newStr[0] = '$';
    newStr[newStr.length()-1] = '*'; //在str的每个字符后都加个“#”，得到新字符串newStr
    for(int i=0, j=2; i<str.length(); i++, j+=2){
        newStr[j] = str[i];
    }
}
int Manacher(){
    init();
    int maxL = -1; //最大回文⻓度
    int id = -1; //当前使mx达到尽可能右边时的回文中心
    int mx = 0;
    //末尾还有个#，不要放进来
    for(int i=1; i<newStr.length(); i++){
        if(mx>i){ //如果之前的中心id的最大延展位置超过了i，那么看看可不可以给p[i]赋 一个最小值，省去一些计算
            /*
            p[2*id-i]是i关于id的对称点的延伸半径。 mx-i是mx与i的距离，同时也是mx
            关于id的对称点到 i关于id的对称点的距离
            
            如果 p[2*id-i]>mx-i，说明i的对称点j的半径是大的，但是我们现在最多只能
            保证[mx对称点，mx]是对称的，所以只能先让p[i]等于mx-i
            如果 p[2*id-i]<mx-i，说明j的范围还没超过id的范围，那稍微一想就明白了，
            i的半径就是j的半径。 */
            p[i] = min(p[2*id-i], mx-i);
        }
        else p[i] = 1; //否则没有简便方法，半径只能从1开始搜了
        while(newStr[i-p[i]] == newStr[i+p[i]]){ //从上面已经预赋值的半径继续往两边寻找
            cout<<newStr[i]<<" "<<p[i]<<" "<<newStr[i-p[i]]<<" "<<newStr[i+p[i]]<<endl;
            p[i]++;
        }
        if(mx< i+p[i]){ //如果当前的最右范围超过了mx，那么更新mx。 因为mx尽可能的远 我们才能更容易偷懒。
            id = i;
            mx = i+p[i];
            
        }
        maxL = max(maxL, p[i]-1);
    }
    return maxL;
}

int main(){
    while(scanf("%s",s)!=EOF){ //用字符数组输入!!!!
        str = s;
        int maxL = -1;
        maxL = Manacher();
        cout<<maxL<<endl;
    }
}


```



动态规划算法

```
class Solution {
public:
    string longestPalindrome(string s) {
        if(s.length()<2)
            return s;
        
        int len = s.length();
        int maxLen = 1;  // 如果长度大于2，那么回文子串长度至少为1.
        int startIndex = 0;
        
        bool dp[len+1][len+1];  // dp[i][j] 表示 s[i]到s[j]是不是回文子串
        memset(dp, false, sizeof(dp));

        for(int i=0; i<len; i++)
            dp[i][i] = true;

        for(int l=2; l<=len; l++){  // 子串的长度从小到大
            for(int i=0; i<len; i++){  // 每次从最开头开始
                int j = i+l-1;  // 子串的末端
                if(j>=len)  // 越界
                    continue;
                if(s[i]!=s[j]){  // 子串 s[i]~s[j]肯定不是回文子串
                    dp[i][j] = false;
                }
                else{
                    if(l<=2)
                        dp[i][j] = true;
                    else{  // 因为s[i+1]~s[j-1]的长度更小，所以在之前就计算过了
                        dp[i][j] = dp[i+1][j-1];
                    }
                }
                if(dp[i][j] && l>maxLen){  // 记录长度和起始下标
                    maxLen = l;
                    startIndex = i;
                }
            }
        }

        return s.substr(startIndex, maxLen);
    }
};
```



### <font color=purple>NC121 字符串的排列</font>

方法一：投机取巧。用了`<algorithm>`中的 next_permutation()

```
class Solution {
public:
    
    // bool next_permutation( iterator start, iterator end);
    // next_permutation()函数功能是输出全部比当前排列大的排列。顺序是从小到大。
    vector<string> Permutation(string str) {
        vector<string>res;
        if(str.length()==0) return res;

        string first = str;
        do{
            next_permutation(str.begin(), str.end());
            res.push_back(str);
        }while(str!=first);
        
        
        return res;
    }
};
```



方法二：dfs+set

```
class Solution {
public:
    void perm(int pos, string s, set<string> &ret) {
        if (pos+1 == s.length()) {
            ret.insert(s);
            return;
        }
        // for循环和swap的含义：对于“ABC”，
        // 第一次'A' 与 'A'交换，字符串为"ABC", pos为0， 相当于固定'A'
        // 第二次'A' 与 'B'交换，字符串为"BAC", pos为0， 相当于固定'B'
        // 第三次'A' 与 'C'交换，字符串为"CBA", pos为0， 相当于固定'C'
        for (int i = pos; i < s.length(); ++i) {
            swap(s[pos], s[i]);
            perm(pos+1, s, ret);
            swap(s[pos], s[i]);
            // 回溯的原因：比如第二次交换后是"BAC"，需要回溯到"ABC"
            // 然后进行第三次交换，才能得到"CBA"
        }
    }
    vector<string> Permutation(string s) {
        if (s.empty()) return {};
        set<string> ret;
        perm(0, s, ret);
        return vector<string>({ret.begin(), ret.end()});
    }
};
```





### NC141 判断是否为回文字符串

水。直接判断原始串和reverse后相不相等。

如果不额外开辟空间的话，就直接双指针咯。

```
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 
     * @param str string字符串 待判断的字符串
     * @return bool布尔型
     */
    bool judge(string str) {
        string ori = str;
        reverse(str.begin(), str.end());
        return ori==str;
    }
};
```



### [lc]<font color=red>1910. 删除一个字符串中所有出现的给定子字符串</font>

https://leetcode-cn.com/problems/remove-all-occurrences-of-a-substring/

2022.02.15 字节面试第二题。

（面完才知道我写错了当时，我就觉得哪有问题，面试官也觉得有问题，但我俩都没看出来。。。）

模拟！其实过程很好想，但是删除之后指针应该停在哪是个问题！

所以引入了一个类似于栈/队列的思想。

一个一个压入，如果长度满足就判断一下最近压入的len长度的子串是否需要删。

```
class Solution {
public:
    string removeOccurrences(string s, string part) {
        int len = part.length();

        string res;
        for(int i=0; i<s.length(); i++){
            res.push_back(s[i]);
            if(res.length()>=len){
                if(res.substr(res.size()-len, len)==part){  // 删掉res末尾两个
                    res.erase(res.size()-len, len);
                }
            }
        }
        return res;
    }
};
```



### NC1 大数加法

```
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 计算两个数之和
     * @param s string字符串 表示第一个整数
     * @param t string字符串 表示第二个整数
     * @return string字符串
     */
    string solve(string s, string t) {
        // 对齐
        if(s.length() >= t.length()){
            t.insert(0, s.length()-t.length(), '0');
        }
        else{
            s.insert(0, t.length()-s.length(), '0');
        }
        int flag = 0;
        int temp;
        for(int i = s.length()-1; i>=0; i--){
            temp = (s[i]-'0') + (t[i]-'0') + flag;
            s[i] = temp%10 +'0';
            flag = temp/10;
        }
        if(flag) s.insert(0, "1");
        return s;
    }
};
```



## 数学

### NC112 进制转换

这个进制转换比较水，原数不是大数（字符串）

**不断进行求模和整除运算，便可依次求得被移动到最低数位的值；以此类推，便可得到所有数位上的值。**

记得最后翻转一下。

大数的任意进制转换参考`题目无关.md`

```
class Solution {
public:
    /**
     * 进制转换
     * @param M int整型 给定整数
     * @param N int整型 转换到的进制
     * @return string字符串
     */
    char int2char(int x){
        if(x>=0 && x<=9){
            return x+'0';
        }
        else return x-10+'A';
    }
    
    string solve(int M, int N) {
        string res;
        int flag = 0;
        if(M<0){
            M = -M;
            flag = 1;
        }
        
        while(M){
            // 每次作除法，得到余数
            int remain = M%N;
            M = M/N;
            res.push_back(int2char(remain));  // 记得最后要反过来
        }
        reverse(res.begin(), res.end());
        if(flag)  // 添加负号
            res.insert(0, "-");
        
        return res;
    }
};
```



### <font color=fuchsia>NC79 丑数</font>

**[lc]面试题 17.09. 第 k 个数**

https://leetcode-cn.com/problems/get-kth-magic-number-lcci/

2022.02.16 字节二面第一题



多指针。

我哭了啊，这一题在我的刷题列表里，但我没刷到这一题。当时没做出来。

这一题用的是2、3、5。面试时是2，3，5，7

**道理我不懂，但它就是这么写的。**

```
class Solution {
public:
    int GetUglyNumber_Solution(int index) {
        vector<int>dp;
        dp.push_back(1);  // dp[0] = 1;
        int p1, p2, p3;
        p1 = 0; p2 = 0; p3 = 0;
        int v1, v2, v3;
        for(int i=1; i<index; i++){
            v1 = dp[p1]*2;
            v2 = dp[p2]*3;
            v3 = dp[p3]*5;
            dp.push_back(min(v1, min(v2, v3)));
            // 防止重复，同步一下
            if(dp[i]==v1) p1++;
            if(dp[i]==v2) p2++;
            if(dp[i]==v3) p3++;
        }
        
        return dp[index-1];
    }
};
```



### <font color=dodgerblue>NC151 最大公约数</font>

$gcd(a,b) <=> gcd(b,a\%b)$

```
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 求出a、b的最大公约数。
     * @param a int 
     * @param b int 
     * @return int
     */
    int gcd(int a, int b) {
        if(a<b)
            swap(a, b);
        int temp;
        while(b!=0){
            temp = a;
            a = b;
            b = temp%b;
        }
        return a;
    }
};
```





## 其他

### 实现前缀树

https://leetcode-cn.com/problems/implement-trie-prefix-tree/

其实我没太搞懂它想让我用什么做。我直接暴力map实现

```
class Trie {
public:
    map<string, bool>str2bool;
    Trie() {
        str2bool.clear();
    }
    
    void insert(string word) {
        str2bool[word] = true;
    }
    
    bool search(string word) {
        if(str2bool.find(word)==str2bool.end())
            return false;
        return true;
    }
    
    bool startsWith(string prefix) {
        map<string, bool>::iterator it;
        int len = prefix.length();
        int flag = 0;  // 遇到第一个字母相等的，启动
        for(it=str2bool.begin(); it!=str2bool.end(); it++){
            if(!flag && it->first[0]!=prefix[0])
                continue;
            flag = 1;  // 运行到这里说明之前已经遇到了第一个字符匹配的
            //map是按字典排序的，如果第一个字符都不匹配，那后面不可能有匹配的了
            if(it->first[0]!=prefix[0]){
                return false;
            }
            if(it->first.substr(0,len) == prefix)
                return true;
        }
        return false;
    }
};

/**
 * Your Trie object will be instantiated and called as such:
 * Trie* obj = new Trie();
 * obj->insert(word);
 * bool param_2 = obj->search(word);
 * bool param_3 = obj->startsWith(prefix);
 */
```








## 没来得及做

