[TOC]

注：⚠️表示有更好的方法没有补充。 ⚡️表示需要加强记忆

<font color=fuchisa>粉色</font>：起码我一开始想不到/做不出来

<font color=red>红色</font>：较难

<font color=orange>橙色</font>：稍微难

<font color=purple>紫色</font>：技巧



## 模拟

### NC38 螺旋矩阵

简单模拟。注意别找重复了！

在底部，从右往左时注意top!=bottom

在左边，从下往上时注意left!=right

```
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int> > &matrix) {
        vector<int>res;
        if(matrix.empty()) return res;
        int left,right,top,bottom;
        left = 0; right = matrix[0].size()-1;
        top = 0; bottom = matrix.size()-1;
        
        while(left<=right && top<=bottom){
            // 从左往右
            for(int j=left; j<=right; j++){
                res.push_back(matrix[top][j]);
            }
            // 从上往下
            for(int i=top+1; i<=bottom; i++){
                res.push_back(matrix[i][right]);
            }
            // 从右往左（注意top!=bottom）
            for(int j=right-1; top!=bottom && j>=left; j--){
                res.push_back(matrix[bottom][j]);
            }
            // 从下往上（注意left!=right）
            for(int i=bottom-1; left!=right && i>top; i--){
                res.push_back(matrix[i][left]);
            }
            left++; right--; top++; bottom--;
        }
        return res;
        
    }
};
```







### <font color=dodgerblue>NC76 用两个栈实现队列</font>

未优化版本：

stack1用来进，stack2用来出。

push时，把stack2的元素压入stack1，再push进stack1

pop时，把stack1的元素压入stack2，再从stack2中pop

这样的策略，每次push或pop时，都要把全部元素转移一遍，执行完后，至少一个stack是空的。那么如果push和pop交替着来，光转移元素就浪费了大量的时间！可以优化！



优化版本：

首先已知stack1永远保持先来的在底部，stack2永远保持先来的在顶部。

如果说从stack2 pop肯定需要从stack1拿元素，这很显然，可我stack1进行push时和你stack2的元素有什么关系？

push时并不会改变stack1的内部顺序，那还管什么stack2？

同样的，pop时，stack2如果还有元素，直接pop就是了，反正stack2的顶部是最老的元素。只要stack2不空，就不用从stack1取。

```
class Solution
{
public:
    void push(int node) {
        stack1.push(node);
    }

    int pop() {
        if(stack2.empty()){  // 空了的时候再取
            while(!stack1.empty()){
                stack2.push(stack1.top());
                stack1.pop();
            }
        }
        
        int res = stack2.top();
        stack2.pop();
        return res;
    }

private:
    stack<int> stack1;
    stack<int> stack2;
};
```





### ⚡️<font color=fuchsia>NC137 表达式求值</font>

[简易计算器](http://t.cn/AiKoGS94)的改进，支持括号。

因为不涉及除法，所以全用的int。如果需要带上除法，记得修改pri和cal函数。

关于 '\#' 和 '\$' 分别是起始和结束符号，且 '\#' 的优先级低于 '\$'，这样的话结束符 '\$' 能正常入栈，索引移动到末尾退出循环。



关于符号栈：

- 如果新来的是左括号 或者 新来的优先级高，直接压进去
- 新来的没有栈顶的高，先计算里面的。注意，这时候新来的不要入栈，index也不更新
  - 如果当前符号是右括号，栈顶是左括号，表明括号内部的已经完成了。 弹出左括号，index++，并continue


**（这里没有给左右括号设置优先级，因为遇到左括号就直接压进去，并且右括号永不入栈。似乎有些不安全？）**

```
class Solution {
  public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 返回表达式的值
     * @param s string字符串 待计算的表达式
     * @return int整型
     */
    stack<char>ops;
    stack<int>nums;

    int pri(char ch) {
        int p = -1;
        if (ch == '#') return 0;
        if (ch == '$') return 1;
        if (ch == '+' || ch == '-') return 2;
        if (ch == '*') return 3;
        return p;
    }

    int getNumber(string s, int& index) { // 带地址！
        int res = 0;
        while (isdigit(s[index])) {
            res = 10 * res;
            res += (s[index] - '0');
            index++;
        }
        return res;
    }

    int cal(int x, int y, char ch) {
        int result = 0;
        if (ch == '+')
            result = x + y;
        else if (ch == '-')
            result = x - y;
        else if (ch == '*')
            result = x * y;
        return result;
    }

    int solve(string s) {
        s.push_back('$');  // 结束符
        ops.push('#');
        int index = 0;
        while (index < s.length()) {
            if (s[index] == ' ')
                index++;
            else if (isdigit(s[index])) {
                nums.push(getNumber(s, index));
            } else {
                // 新来的是左括号 或者 新来的优先级高，直接压进去
                if (s[index] == '(' || pri(s[index]) > pri(ops.top())) {
                    ops.push(s[index]);
                    index++;
                } else { // 新来的没有栈顶的高，先计算里面的。注意，这时候新来的不要入栈，index也不更新
                    if (s[index] == ')' && ops.top() == '(') { // 括号内的都计算完了，该滚蛋了
                        index++;
                        ops.pop();
                        continue;
                    }
                    int y = nums.top();
                    nums.pop();
                    int x = nums.top();
                    nums.pop();
                    char ch = ops.top();
                    ops.pop();
                    nums.push(cal(x, y, ch));
                }
            }
        }
        return nums.top();
    }
};
```



### NC100 把字符串转换成整数(atoi)

感觉题目没说清楚。。。提交错了好多次

还有关于边界问题。

甚至也可能超过long long的范围！

以及 INT_MAX 的绝对值 比 INT_MIN 的绝对值少1

以及 INT_MAX 不能加一，而是应该 res - 1 >INT_MAX 来判断

```
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param s string字符串 
     * @return int整型
     */
    long long getNumber(string s, int index){
        long long res = 0;
        while(isdigit(s[index])){
            res = 10*res + (s[index]-'0');
            if(res-1>INT_MAX)  // 这里没考虑符号，所以要考虑到INT_MIN的绝对值
                return res;  // 只要大于 INT_MIN的绝对值，那铁定越界，随便返回
            index++;
        }
        return res;
    }
    
    int StrToInt(string s) {
        int flag = 0;  // 默认为正数，如果遇到负号flag置为1
        int hold = 0;  // 如果遇到正负号，后面再遇到直接忽略
        // 先去除前导空格
       int index = 0;
        while(s[index]==' ')
            index++;
        s = s.substr(index);
        
        long long temp = 0;
        int res = 0;
        // 遍历
        for(int i=0; i<s.length(); i++){
            if(isdigit(s[i])){
                temp = getNumber(s, i);
                break;
            }
            else{
                if(s[i]=='+' || s[i]=='-'){
                    if(!hold){  // 之前没遇到过正负号
                        hold = 1;
                        flag = s[i]=='+'?0:1;
                    }
                    // 后面再遇到正负号直接算错误
                    else return 0;
                }
                else return 0;  // 如果先遇到的是字母，则失败
            }
        }
        
        
        temp = flag==0?temp:-temp;
        
        if(temp>INT_MAX)
            res = INT_MAX;
        else if(temp<INT_MIN)
            res = INT_MIN;
        else res = (int)temp;
        
        return res;
    }
};
```



### NC18 顺时针旋转矩阵

要达到顺时针旋转90°的效果，可以先根据左下——右上的对角线翻转，再上下翻转

<img src="https://uploadfiles.nowcoder.com/files/20210718/91789069_1626594947492/image-20210718152338350.png" alt="image-20210718152338350" style="zoom:50%;" />

```
class Solution {
public:
    vector<vector<int> > rotateMatrix(vector<vector<int> > mat, int n) {
        if(mat.empty()) return mat;
        
        for(int i=0; i<n; i++){
            for(int j=0; j<n-1-i; j++){
                swap(mat[i][j], mat[n-1-j][n-1-i]);  // 沿右上-左下对角线翻转
            }
        }
        for(int i=0; i<n/2; i++){  // 上下翻转
            swap(mat[i], mat[n-1-i]);
        }
        return mat;
        
    }
};
```



### <font color=red>[lc]149.直线上最多的点数</font>

https://leetcode-cn.com/problems/max-points-on-a-line/

（2022.02.28 字节电商NLP二面）

方法一：暴力枚举所有点

时间复杂度：$O(n^3)$

首先前两层循环确定一条直线，第三层循环寻找有没有点在这条直线上。

```
class Solution {
public:
    int maxPoints(vector<vector<int>>& points) {
        if(points.size() < 3) return points.size();

        int n = points.size();

        int x1, x2, x3, y1, y2, y3;
        int ans = 0;
        int cnt;
        for(int i=0; i<n; i++){  // 枚举第一个点
            x1 = points[i][0];
            y1 = points[i][1];
            for(int j=i+1; j<n; j++){  // 枚举第二个点
                x2 = points[j][0];
                y2 = points[j][1];
                cnt = 2;  // 到这里至少两个点了
                for(int k=j+1; k<n; k++){  // 枚举第三个点
                    x3 = points[k][0];
                    y3 = points[k][1];
                    if((y3-y2)*(x2-x1) == (y2-y1)*(x3-x2) )  // 斜率相等，对角乘积
                        cnt++;
                }
                ans = max(ans, cnt);
            }
        }
        return ans;
    }
};
```



方法二：枚举所有斜率

时间复杂度：$O(n^2 logm)$

1. 将斜率化为最简分数，并用字符串表示，用map存储（注意 gcd 函数不用比较 a 和 b 的大小）
2. count[str]表示有多少点能和当前点组成斜率为 str 的线，所以点的数目一共有 count[str] + 1

```
class Solution {
public:
    int gcd(int a, int b){
    	// 可以直接写成 return b ? gcd(b, a % b) : a;
        if(b==0) return a;
        else return gcd(b, a%b);
    }

    int maxPoints(vector<vector<int>>& points) {
        if(points.size() < 3) return points.size();
        int n = points.size();
        int x1, x2, y1, y2;
        int ans = 1;
        for(int i=0; i<n; i++){  // 枚举第一个点
            x1 = points[i][0];
            y1 = points[i][1];
            // 以第一个点为首的直线的斜率出现次数。 string为 a_b 表示 a/b
            // 这里 a 和 b 互质
            map<string, int>count;  
            for(int j=i+1; j<n; j++){  // 枚举第二个点
                x2 = points[j][0];
                y2 = points[j][1];
                
                int a = y2-y1;
                int b = x2-x1;
                // 斜率就是 a/b，但这里约分一下
                int k = gcd(a, b);
                string str = std::to_string(a/k) + '_' + std::to_string(b/k);
                count[str]++;

                ans = max(ans, count[str]+1);  // 斜率出现了 m 次， 则有m+1个点
            }
        }
        return ans;
    }
};
```





### <font color=red>[lc]135.分发糖果</font>

每个孩子至少分配到 1 个糖果。相邻两个孩子评分更高的孩子会获得更多的糖果。

遍历该数组两次，处理出每一个学生分别满足左规则或右规则时，最少需要被分得的糖果数量。每个人最终分得的糖果数量即为这两个数量的最大值。

对于从右向左遍历，相当于开一个right数组。right++  =>right[i] = right[i+1] + 1; 为了节省空间，直接用单个变量用完就扔了。 

时间复杂度：O(n)，空间复杂度：O(n)

```
class Solution {
public:
    int candy(vector<int>& ratings) {
        int n = ratings.size();
        int left[n];

        // 从左到右
        for(int i=0; i<n; i++){
            if(i>0 && ratings[i] > ratings[i-1])
                left[i] = left[i-1] + 1;
            else left[i] = 1;
        }

        int right = 0;
        int sum = 0;
        for(int i=n-1; i>=0; i--){
            if(i<n-1 && ratings[i]> ratings[i+1]){
                right++;  // 如果从右到左一直递增，则right也一直递增，否则right直接归1（即分配最小糖果即可）
            }
            else right = 1;
            sum+=max(left[i], right);
        }
        return sum;
    }
};
```



优化：时间复杂度 O(n)，空间复杂度 O(1)

https://leetcode.cn/problems/candy/solutions/533150/fen-fa-tang-guo-by-leetcode-solution-f01p/

我们从左到右枚举每一个同学，记前一个同学分得的糖果数量为 pre

- 如果当前同学比上一个同学评分高，说明我们就在最近的递增序列中，直接分配给该同学 pre+1 个糖果即可。
- 否则就在一个递减序列中，直接分配给当前同学一个糖果（即当前设为1，但res并不需要加当前的pre，在后面res+=dec会一起加），**并把该同学所在的递减序列中所有的同学都再多分配一个糖果**，以保证糖果数量还是满足条件。
  - **无需显式地额外分配糖果，只需要记录当前的递减序列长度，即可知道需要额外分配的糖果数量**。
  - 同时注意当当前的递减序列长度和上一个递增序列等长时，需要把最近的递增序列的最后一个同学也并进递减序列中。

这样，我们只要记录当前递减序列的长度 dec，最近的递增序列的长度 inc 和前一个同学分得的糖果数量 pre 即可。

```
class Solution {
public:
    int candy(vector<int>& ratings) {
        int n = ratings.size();;
        
        int res = 1;  // 第一个人是1
        // inc 和 dec 表示递增/减序列长度 
        int inc = 1, dec = 0, pre = 1;
        
        for(int i=1; i<n; i++){
            if(ratings[i]>=ratings[i-1]){
                dec = 0;
                if(ratings[i]==ratings[i-1])  // 相当于把递增序列重置
                    pre = 1;
                else
                    pre = pre+1;
                // 更新后 pre相当于当前位置的糖果数
                inc = pre;  // 递增序列的长度也和当前的糖果数一样
                res += pre;  // 总糖果数加上当前位置的糖果数
            }
            else{
                dec++;
                if(dec == inc)
                    dec++;
                // 这里的dec，记录的是递减序列的长度，相当于为序列中每个元素都追加1个糖果
                res += dec;
                pre = 1;
            }
        }
        return res;
    }
};
```



### N 字形变换（ZigZag）

https://leetcode.cn/problems/zigzag-conversion/description/

找规律，分组

```
class Solution {
public:
    string convert(string s, int numRows) {
        if(numRows ==1) return s;
        int n = s.length();
        string res;
        int len = numRows + numRows-2;  // 一组
        int num = n / len;
        if(n % len) num++;


        for(int i=0; i<numRows; i++){
            for(int j=0; j<num; j++){  // 组号
                if(i==0){
                    res.push_back(s[j*len + i]);
                }
                else{
                    if(j*len + i < n)
                        res.push_back(s[j*len + i]);
                    if(j*len + len - i < n && len - i != i)  // len - i 不要与 i重复
                        res.push_back(s[j*len + len-i]);    
                }
            }
        }
        return res;
    }
};
```



## 链表

### [lc]237.删除链表中的节点

https://leetcode.cn/problems/delete-node-in-a-linked-list/description/

给定当前节点的指针，要求在O(1) 删除这个节点。

思路：覆盖也是一种删除，直接让该节点的next节点的值覆盖当前，并删除next节点即可。

```
class Solution {
public:
    void deleteNode(ListNode* node) {
        if(node == NULL) return;
        if(node->next == NULL){
            node=NULL;
            return;
        }

        node->val = node->next->val;
        node->next = node->next->next;
    }
};
```



### <font color=dodgerblue>NC78 反转链表</font>

https://zhuanlan.zhihu.com/p/240694166

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* cur = head;
        ListNode* pre = nullptr;
        ListNode* temp = nullptr;
        while(cur){
            temp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = temp;  // 每轮末尾，cur和temp都会指向一个正常节点。结束时cur和temp都指向空
        }
        return pre;
    }
};
```



### <font color=orange>[lc]92.反转链表 II</font>

题目不难，但是需要注意的细节很多！边界问题，还有next 的判空问题。

```
class Solution {
public:

    ListNode* reverse(ListNode* l, ListNode* r){
        ListNode* pre, *cur, *nxt;
        cur = l;
        while(cur!=r){
            nxt = cur->next;
            cur->next = pre;
            pre = cur;
            cur = nxt;
        }
        return pre;
    }

    ListNode* reverseBetween(ListNode* head, int left, int right) {
        if(head == nullptr) return nullptr;
        ListNode* fast, *slow;

        fast = head; slow = head;
        for(int i=0; i<right-left; i++){  // 让fast先走
            if(fast) fast = fast->next;
            else return nullptr;
        }

        ListNode* pre, *nxt;
        ListNode* init = new ListNode(0);
        init->next = head;
        pre = init;

        for(int i=1; i<left; i++){
            // fast 不能为空是需要保证 fast->next 不会越界，fast->next 不能为空是right必须是个真实节点
            if(fast && fast->next){
                fast = fast->next;
                pre = slow;
                slow = slow->next;
            }
            else return nullptr;
        }
        nxt = fast->next;
        pre->next = reverse(slow, nxt);
        slow->next = nxt;


        return init->next;
    }
};
```





### <font color=red>NC50 链表中的节点每k个一组翻转</font>

https://www.nowcoder.com/practice/b49c3dc907814e9bbfa8437c251b028e?tpId=196&tqId=37080&rp=1&ru=/exam/oj&qru=/exam/oj&sourceUrl=%2Fexam%2Foj%3Ftab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D196%26page%3D1&difficulty=undefined&judgeStatus=undefined&tags=&title=

方法一：暴力模拟（用vector）

时间复杂度 O(n)，空间复杂度O(n)

```
/**
 * struct ListNode {
 *	int val;
 *	struct ListNode *next;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param head ListNode类 
     * @param k int整型 
     * @return ListNode类
     */
    ListNode* reverseKGroup(ListNode* head, int k) {
        vector<int>vec;
        vec.clear();
        ListNode* cur = head;
        while(cur){  // 放进vector里
            vec.push_back(cur->val);
            cur = cur->next;
        }
        // 翻转
        for(int i=0; i<vec.size(); i+=k){
            if(i+k <= vec.size()){
                reverse(vec.begin()+i, vec.begin()+i+k);
            }
            else break;
        }
        
        cur = head;
        for(int i=0; i<vec.size(); i++){
            cur->val = vec[i];
            cur = cur->next;
        }
        return head;
    }
};
```



方法二：递归

> 首先，我们要实现一个reverse函数反转一个区间之内的元素。
>
> 反转以a为头结点的链表其实就是反转a到null之间的结点，那么反转a到b之间的结点就只需要吧null改为b是不是就可以实现了？

reverseKGroup 递归的思路比较绕！！！

运行完这一行后，

```
ListNode* res = reverse(head, cur);
```

这一小段翻转后的链表，头指针就是res，尾指针是head！

完整代码：

```
/**
 * struct ListNode {
 *	int val;
 *	struct ListNode *next;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param head ListNode类 
     * @param k int整型 
     * @return ListNode类
     */
    // 翻转 [left, right) 的链表
    ListNode* reverse(ListNode* left, ListNode* right){
        ListNode* cur = left;
        ListNode* pre = nullptr;
        ListNode* nxt;
        
        while(cur!=right){
            nxt = cur->next;
            cur->next = pre;
            pre = cur;
            cur = nxt;
        }
        return pre;  // 翻转后的头节点
    }
    
    ListNode* reverseKGroup(ListNode* head, int k) {
        ListNode* cur = head;
        // 找到这一段的末节点
        for(int i=0; i<k; i++){
            if(cur==nullptr)  // 如果为空，说明不足k个，直接返回头指针
                return head;
            cur = cur->next;
        }
        // 现在就要翻转 [head, cur) 之间的链表
        ListNode* res = reverse(head, cur);  // 翻转后 head 是这一段最后一个元素
        // 此时head 指向这一小段的末节点
        head->next = reverseKGroup(cur, k);  // 注意这里函数传入的参数是 cur，而不是 head->next
        
        return res;
    }
};
```



### ⚡️NC21 链表内指定区间反转

利用NC50提到的区间翻转，连起来就行。

翻转[a, b] 要找到四个节点， a->pre, a, b, b->next

然后使用翻转 [a, b->next)，再连起来



在碰到链表重新连接时，如果需要讨论pre是否是头节点，可以考虑在头节点前插入一个新节点使问题简单化：

```
ListNode* init = new ListNode(0);  init -> next = head;
ListNode* pre = init;
```



```
/**
 * struct ListNode {
 *	int val;
 *	struct ListNode *next;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param head ListNode类 
     * @param m int整型 
     * @param n int整型 
     * @return ListNode类
     */
    ListNode* reverseL(ListNode* a, ListNode* b){  // [a, b)
        ListNode* cur, *pre, *temp;
        cur = a; pre = nullptr;
        while(cur!=b){
//             printf("%d ", cur->val);
            temp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = temp;
        }
        return pre;
    }
    
    ListNode* reverseBetween(ListNode* head, int m, int n) {
        ListNode*a, *b, *pre, *nxt;
        int count = 0;
        ListNode* init = new ListNode(0);  init -> next = head;
        ListNode* cur = init;
        
        // 翻转[a, b] 要找到四个节点， a->pre, a, b, b->next
        // 然后使用翻转 [a, b->next)，再连起来
        while(cur){
            if(count==m-1){  // 
                a = cur->next;
                pre = cur;
            }
            if(count==n){
                b = cur;
                nxt = b->next;
                break;
            }
            count++;
            cur = cur->next;
        }
        pre->next = reverseL(a, nxt);
        a->next = nxt;
        return init->next;
    }
};
```





### <font color=purple>NC4 判断链表中是否有环</font>

链表找环路的问题，<font color=purple>快慢指针(Floyd 判圈法)</font>。

> 给定两个指针， 分别命名为 slow 和 fast，起始位置在链表的开头。每次<font color=red> fast 前进两步</font>，slow 前进一步。如果 fast 可以走到尽头，那么说明没有环路;如果 fast 可以无限走下去，那么说明一定有环路，且一定存 在一个时刻 slow 和 fast 相遇。当 slow 和 fast 第一次相遇时，我们将 fast 重新移动到链表开头，并让 <font color=red>slow 和 fast 每次都前进一步</font>。当 slow 和 fast 第二次相遇时，相遇的节点即为环路的开始点。

合理性解释：

> 假设链表头到环路连接点的距离为 a，环路的长度为 b，慢指针相遇的位置距离连接点的距离为 x，那么快指针走过的距离是慢指针的两倍，即：a + nb + x = 2(a + mb + x)，其中 m 和 n 表示快指针在环上走了几个圈。
>
> 我们可以得到：a = (n - 2m - 1)b + (b - x)，这个式子表示从慢指针相遇点出发，**再走 a 步恰好到达连接点的位置**，通过这个式子可以发现，如果此时有另外一个指针从链表头出发，两个指针每次都只移动一个节点，它们一定会在连接点相遇。因此，我们可以通过两个指针，一个从慢指针相遇点出发，另一个从链表头出发，每次都只移动一个节点，最终会在连接点相遇。



注意一开始是do while 循环。

**被注释掉的部分是找到环的入口。**

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        if(head == nullptr)
            return false;
        ListNode* fast = head;
        ListNode* slow = head;
        
        do{  // 先进行一次
            if(fast==nullptr || fast->next==nullptr){  // 一次就走到头了
                return false;
            }
            fast = fast->next->next;
            slow = slow->next;
        }while(fast!=slow);
        
        return true;
        
//         // 执行到这里说明有环，让fast归零
//         fast = head;
//         while(fast!=slow){
//             fast = fast->next;
//             slow = slow->next;
//         }  // 循环结束后，fast就指向环的入口
        
//         return true;
    }
};
```



### <font color=purple>NC3 链表中环的入口结点</font>

见上面 NC4 的解析。

```
/*
struct ListNode {
    int val;
    struct ListNode *next;
    ListNode(int x) :
        val(x), next(NULL) {
    }
};
*/
class Solution {
public:
    ListNode* EntryNodeOfLoop(ListNode* pHead) {
        ListNode* fast = pHead, *slow = pHead;
        
        do{
            if(fast == nullptr || fast->next ==nullptr)
                return nullptr;
            fast = fast->next->next;
            slow = slow->next;
        }while(fast!=slow);
        
        // 执行到这里说明有环，让fast归零
        fast = pHead;
        while(fast != slow){
            fast = fast->next;
            slow = slow->next;
        }  // 循环结束后，fast就指向环的入口
        return fast;
    }
};
```



### NC53 删除链表的倒数第n个节点

方法一：暴力

先统计一遍个数，然后找到是正数第几个节点。

为了直观，先判断是否是删头节点，删头节点的话直接return head->next。

否则， 指向它前面一个节点，找到，修改。

```
/**
 * struct ListNode {
 *	int val;
 *	struct ListNode *next;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param head ListNode类 
     * @param n int整型 
     * @return ListNode类
     */
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        // write code here
        ListNode* cur = head;
        int count = 0;
        while(cur){
            count++;
            cur = cur->next;
        }
        if(count == n)// 删除的是头节点
            return head->next;
        cur = head;
        // 被删除的节点是正数第 count-n+1个节点，它前面的节点是第 count-n个
        // 从head开始，执行 count-n-1次循环到达
        int num = count-n-1;
        while(num--){
            cur = cur->next;
        }
        cur->next = cur->next->next;
        return head;
    }
};
```



方法二：双指针

fast 比 slow 超前 n 个节点。当 fast 遍历到链表的末尾（null）时，slow 就恰好处于倒数第 n 个节点。

```
/**
 * struct ListNode {
 *	int val;
 *	struct ListNode *next;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param head ListNode类 
     * @param n int整型 
     * @return ListNode类
     */
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        // write code here
        ListNode *fast, *slow;
        fast = head; slow = head;
        
        while(n--){  // 让 fast 先走n步
            if(fast==nullptr)  // 如果没有那么多节点
                return nullptr;
            fast = fast->next;
        }
        
        // 让fast 继续往前走，当 fast == nullptr 时，slow所在的位置就是需要删除的
        if(fast==nullptr) return head->next;  // 删除的是头节点
        
        ListNode *pre;
        while(fast!=nullptr){
            pre = slow;
            slow = slow->next;
            fast = fast->next;
        }
        pre->next = slow->next;
        return head;
    }
};
```





### <font color=purple>NC66 两个链表的第一个公共结点</font>

给定两个单链表，若含有公共结点，返回第一个公共结点的指针。

（推荐解法二）

方法一：同一起跑线

如果有公共节点，那么后面部分应该是一样的，直接把较长的链表的前面切除，先保证一样长。

然后双指针同时走，如果为空或者相等了就返回。

是空，表示无公共。如果非空，则有公共。

```
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
    ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) {
        ListNode* cur1 = pHead1;
        ListNode* cur2 = pHead2;
        if(!cur1 || !cur2)  // 如果有空链表
            return nullptr;
        
        int count1 = 0;
        int count2 = 0;
        while(cur1){
            count1++;
            cur1 = cur1->next;
        }
        while(cur2){
            count2++;
            cur2 = cur2->next;
        }
        
        // 再次初始化
        cur1 = pHead1;
        cur2 = pHead2;
        if(count1>=count2){
            for(int i=0; i<count1-count2; i++)
                cur1 = cur1->next;
        }
        else{
            for(int i=0; i<count2-count1; i++)
                cur2 = cur2->next;
        }
        // 现在cur1和cur2在同一起跑线
        while(cur1 && cur2 && cur1!=cur2){
            cur1 = cur1->next;
            cur2 = cur2->next;
        }
        // 如果cur1是空，表示无公共。如果非空，则有公共。反正都是一样返回
        return cur1;
        
    }
};
```



✅**方法二：题解中Dylan的回答**

使用两个指针N1,N2，一个从链表1的头节点开始遍历，我们记为N1，一个从链表2的头节点开始遍历，我们记为N2。

让N1和N2一起遍历，当N1先走完链表1的尽头（为null）的时候，则从链表2的头节点继续遍历，同样，如果N2先走完了链表2的尽头，则从链表1的头节点继续遍历，也就是说，N1和N2都会遍历链表1和链表2。

因为两个指针，同样的速度，走完同样长度（链表1+链表2），不管两条链表有无相同节点，都能够到达同时到达终点。

```
public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) {
        ListNode l1 = pHead1, l2 = pHead2;
        while(l1 != l2){
            l1 = (l1==null)?pHead2:l1.next;
            l2 = (l2==null)?pHead1:l2.next;
        }
        return l1;
    }
```

```
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
    ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) {
        ListNode* cur1 = pHead1;
        ListNode* cur2 = pHead2;
        
        while(cur1!=cur2){
            if(cur1 == nullptr)
                cur1 = pHead2;
            else cur1 = cur1->next;
            
            if(cur2 == nullptr)
                cur2 = pHead1;
            else cur2 = cur2->next;
        }
        
        return cur1;
        
    }
};
```



### <font color=purple>NC45 分隔链表</font>

https://leetcode.cn/problems/partition-list-lcci/solution/

方法一：暴力（不推荐）

由于需要保留两个分区中每个节点的初始相对位置。

所以整个数组就只有两类，小于x的、大于等于x的。用level进行区分。

进行一个stable_sort，忽略值的大小，只对level排序。

```
/**
 * struct ListNode {
 *	int val;
 *	struct ListNode *next;
 *	ListNode(int x) : val(x), next(nullptr) {}
 * };
 */
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param head ListNode类 
     * @param x int整型 
     * @return ListNode类
     */
    struct node{
        int val;
        int level;
        node(int v, int l): val(v), level(l){}
    };
    
    static bool cmp(node a, node b){
        return a.level<b.level;
    }

    ListNode* partition(ListNode* head, int x) {
        if(head==nullptr)
            return head;
        vector<node>vec;
        ListNode* cur = head;
        // 由于需要保留两个分区中每个节点的初始相对位置
        // 所以整个数组就只有两类，小于x的、大于等于x的。用level进行区分
        while(cur){
            if(cur->val<x)
                vec.push_back(node(cur->val, 0));
            else vec.push_back(node(cur->val, 1));
            cur = cur->next;
        }
        
        // 进行一个stable sort，忽略值的大小，只对level排序
        stable_sort(vec.begin(), vec.end(), cmp);
        
        cur = head;
        for(int i=0; i<vec.size(); i++){
            cur->val = vec[i].val;
            cur = cur->next;
        }
        return head;
    }
};
```



方法二：链表模拟

维护两个链表 small 和 large。small 链表按顺序存储所有小于 x 的节点，large 链表按顺序存储所有大于等于 x 的节点。

注意：1）尾部手动设置为 NULL，可能会有循环。2）返回时可能存在small为空，如果为空直接返回large

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
        ListNode* small, *large;
        small = new ListNode(0); large = new ListNode(0);  // 初始化

        ListNode *cur, *l1, *l2;
        cur = head; l1 = small; l2=large;
        while(cur){
            if(cur->val < x){
                l1->next = cur;
                l1 = cur;
            }
            else{
                l2->next = cur;
                l2 = cur;
            }
            cur = cur->next;
        }
        // 把 small 的末尾指向 large 的开头
        small = small->next; large = large->next;  // 去掉初始化时的0
        l1 -> next = large; l2->next = NULL;  // 注意尾部手动设置为 NULL，可能会有循环
        if(small != NULL) return small; else return large;  // small 可能为空
    }
};
```







### NC40 两个链表生成相加链表

不难，辅助栈更快。

方法一：

转为字符串处理。大数加法。

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */

class Solution {
public:
    /**
     * 
     * @param head1 ListNode类 
     * @param head2 ListNode类 
     * @return ListNode类
     */
    // 字符串大数加法
    string strAdd(string str1, string str2){
        // 长度对齐
        if(str1.length()>=str2.length())
            str2.insert(0, str1.length()-str2.length(),'0');
        else
            str1.insert(0, str2.length()-str1.length(),'0');
        
        int temp,add;
        add = 0;
        
        for(int i=str1.length()-1; i>=0; i--){
            temp = (str1[i]-'0') + (str2[i] -'0') + add;
            str1[i] = temp%10+'0';
            add = temp/10;
        }
        if(add)
            str1.insert(0, "1");
        return str1;
    }
    
    ListNode* addInList(ListNode* head1, ListNode* head2) {
        ListNode* cur1, *cur2;
        cur1 = head1;
        cur2 = head2;
        string s1, s2, res;
        
        // 转为字符串
        while(cur1){
            s1.push_back(cur1->val + '0');
            cur1 = cur1->next;
        }
        while(cur2){
            s2.push_back(cur2->val + '0');
            cur2 = cur2->next;
        }
        
        // 字符串大数加法
        res = strAdd(s1, s2);
        
        // 字符串生成链表，注意边界（头节点）
        cur1 = head1;
        head1->val = res[0]-'0';
        for(int i=1; i<res.length(); i++){
            ListNode* newptr = new ListNode(res[i]-'0');
            cur1->next = newptr;
            cur1 = newptr;
        }
        return head1;
        
    }
};
```



方法二：

辅助栈

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */

class Solution {
public:
    /**
     * 
     * @param head1 ListNode类 
     * @param head2 ListNode类 
     * @return ListNode类
     */
     
    ListNode* addInList(ListNode* head1, ListNode* head2) {
        ListNode* cur1, *cur2;
        cur1 = head1;
        cur2 = head2;
        
        // 辅助栈
        stack<int>st1;
        stack<int>st2;
        
        while(cur1){
            st1.push(cur1->val);
            cur1 = cur1->next;
        }
        while(cur2){
            st2.push(cur2->val);
            cur2 = cur2->next;
        }
        
        int temp, add;
        ListNode* head = nullptr;
        add = 0;
        
        // 栈顶相加。每次的结果生成新节点，不断作为列表的头部
        while(!st1.empty() && !st2.empty()){
            temp = st1.top() + st2.top() + add;
            add = temp/10;
            ListNode* node = new ListNode(temp%10);
            node->next =  head;
            head = node;
            
            st1.pop(); st2.pop();
        }
        
        // 长度更长的列表会剩余，注意这里仍然要取模
        while(!st1.empty()){
            temp = st1.top() + add;
            ListNode* node = new ListNode(temp%10);
            add = temp/10;
            
            node->next =  head;
            head = node;
            st1.pop();
        }
        while(!st2.empty()){
            temp = st2.top() + add;
            ListNode* node = new ListNode(temp%10);
            add = temp/10;
            
            node->next =  head;
            head = node;
            st2.pop();
        }
        
        // 如果最后一位有剩余
        if(add!=0){
            ListNode* node = new ListNode(add);
            node->next =  head;
            head = node;
        }
        
        return head;
        
    }
};
```





### <font color=dodgerblue>NC33 合并两个排序的链表</font>

我本来想的是固定res头指针指向pHead1，然后根据情况把链表2节点插入进来，但是不太行。因为头节点还需要比较大小，并且节点的插入涉及太多指针。

所以应该从头维护一个res链表，比较链表1和2的当前节点，把小的喂到res的后面。

```
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
    ListNode* Merge(ListNode* pHead1, ListNode* pHead2) {
        ListNode* cur1, *cur2;
        
        ListNode* vhead = new ListNode(0);  // 随机初始化一个头节点
        ListNode* cur = vhead;
        
        cur1 = pHead1; cur2 = pHead2;
        while(cur1 && cur2){
            if(cur1->val<=cur2->val){
                cur->next = cur1;
                cur1 = cur1->next;
            }
            else{
                cur->next = cur2;
                cur2 = cur2->next;
            }
            cur = cur->next;  // 前进一步
        }
        // 这时候可能还有剩余
        if(cur1)
            cur->next = cur1;
        else cur->next = cur2;
        
        return vhead->next;  // 去掉头部的初始化节点
    }
};
```





### ⚡️<font color=purple>NC51 合并k个已排序的链表</font>

方法一：vector

投机取巧，都放到vector里。。排序

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *mergeKLists(vector<ListNode *> &lists) {
        vector<int>vec;
        if(lists.empty()) return nullptr;
        
        ListNode* cur;
        for(int i=0; i<lists.size(); i++){
            cur = lists[i];
            while(cur){
                vec.push_back(cur->val);
                cur = cur->next;
            }
        }
        sort(vec.begin(), vec.end());
        
        ListNode* pre = new ListNode(0);  // 随便定义一个非空的头节点
        ListNode* head = pre;
        for(int i=0; i<vec.size(); i++){
            cur = new ListNode(vec[i]);
            pre->next = cur;
            pre = cur;
        }
        head = head->next;  // 去掉开头的
        return head;
    }
};
```



方法二：分治合并

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode *a, ListNode *b){
        ListNode* head = new ListNode(0);
        ListNode* cur = head;
        if ((!a) || (!b)) return a == nullptr? b : a;
        while(a && b){
            if(a->val < b->val){
                cur->next = a; a = a->next;
            }
            else{
                cur ->next = b; b = b->next;
            }
            cur = cur->next;
        }
        if(a || b) cur->next = a? a : b;
        return head->next;
    }

    ListNode* merge(vector<ListNode*>& lists, int l, int r){
        if(l>r) return nullptr;
        if(l==r) return lists[l];
        int mid = (l+r) >> 1;
        return mergeTwoLists(merge(lists, l, mid), merge(lists, mid+1, r));
    }

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        return merge(lists, 0, lists.size()-1);
    }
};
```





### NC96 判断一个链表是否为回文结构

水题。

方法一：放到vector里，双指针

```
/**
 * struct ListNode {
 *	int val;
 *	struct ListNode *next;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param head ListNode类 the head
     * @return bool布尔型
     */
    
    bool isPail(ListNode* head) {
        vector<int>vec;
        ListNode* cur = head;
        while(cur){
            vec.push_back(cur->val);
            cur = cur->next;
        }
        int l,r;
        for(l=0, r=vec.size()-1; l<r; l++, r--){
            if(vec[l]!=vec[r])
                return false;
        }
        return true;
    }
};
```



方法二：快慢指针先找到中间位置，然后翻转后半部，然后逐个比较。

比较完成后我们应该将链表恢复原样。虽然不需要恢复也能通过测试用例，但是使用该函数的人通常不希望链表结构被更改。

空间复杂度O(1)

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:

    ListNode* reverse(ListNode* left, ListNode* right){
        ListNode *pre, *cur, *nxt;
        cur = left; pre=nullptr;
        while(cur!=right){
            nxt = cur->next;
            cur->next = pre;
            pre = cur;
            cur = nxt;
        }
        return pre;
    }

    bool isPalindrome(ListNode* head) {
        ListNode *tail, *fast, *slow;
        fast = head; slow = head;

        while(fast->next && fast->next->next){
            fast = fast->next->next;
            slow = slow->next;
        }
        // 这时候 [head, slow]一定是比较长的半边，当原链表为奇数时，落单的一定在左半边的末尾
        // 翻转slow后面的列表
        tail = reverse(slow->next, nullptr);
        slow->next = nullptr;

        ListNode* temp1, *temp2;
        temp1 = head; temp2 = tail;
        while(temp1 && temp2){
            if(temp1->val != temp2->val)
                return false;
            temp1 = temp1->next;
            temp2 = temp2->next;
        }
        // 到这里为true，但可以先恢复一下。
        slow->next = reverse(tail, nullptr);
        return true;
    }
};
```





### ⚡️<font color=red>NC2 重排链表</font>

没思路的时候，画几个节点举个例子呗！

比如 1 2 3 4 5 6 7 8 9 10，重排后变成 1 <u>10</u> 2 <u>9</u> 3 <u>8</u> 4 <u>7</u> 5 <u>6</u>

奇数个时 1 2 3 4 5 6 7 8 9，重排后变成 1 <u>9</u> 2 <u>8</u> 3 <u>7</u> 4 <u>6</u> 5

这不就相当于，把链表切一半，后一半翻转，然后两个链表交替插入嘛？

找中点呗，在中点之后的翻转。比如上面 n=10时，mid=5；n=9时，mid=5。所以mid = (n+1)>>1

假设我们现在cur指向第mid个节点，先把链表切了，再翻转。（或者也可以直接 head2 = reverse(cur->next); cur->next = nullptr）

```
// 切断原链表的末尾
ListNode* ptr = cur->next;
cur->next = nullptr;
// 翻转mid+1到结尾的链表
ListNode* head2 = reverse(ptr);
```

翻转链表你会写吧，会吧会吧会吧？不会写就去看 NC78或 NC21。



原始方法：遍历一遍数个数，再遍历到一半，切割。（2022.11.17 已删除）

**优化：切割链表的时候用快慢指针，就不用遍历两遍了**

注意 快指针的判断条件是 **while(fast->next!=nullptr && fast->next->next!=nullptr)**

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:

    ListNode* reverse(ListNode* left, ListNode* right){  // [left, right)
        ListNode *pre, *cur, *nxt;
        cur = left;
        pre = nullptr;

        while(cur!=right){
            nxt = cur->next;
            cur->next = pre;
            pre = cur;
            cur = nxt;
        }
        return pre;  // 翻转后的头节点
    }

    void reorderList(ListNode* head) {
        if(head==nullptr) return ;

        ListNode *fast, *slow;
        fast = head; slow = head;

        while(fast->next!=nullptr && fast->next->next!=nullptr){
            fast = fast->next->next;
            slow = slow->next;
        }  // 循环结束后，切断slow后面的，并翻转以slow->next开头的链表
        // [0, slow], [slow->next, end]

        ListNode *ptr = slow->next;
        slow->next = nullptr;
        ListNode* head2 = reverse(ptr, nullptr);

        ListNode *cur1, *cur2, *temp1, *temp2;
        cur1 = head; cur2 = head2;

        while(cur1!=nullptr && cur2!=nullptr){
            // 保存状态
            temp1 = cur1->next;
            temp2 = cur2->next;
            // 插入
            cur1->next = cur2;
            cur2->next = temp1;
            // 更新状态
            cur1 = temp1;
            cur2 = temp2;
        }
        return ;
    }
};
```

关于两端链表合并的部分，如果感觉上面的太乱，可以新开个结点，然后把两段交叉放进去，参考 NC33

```
head = new ListNode(0);  // 新建一个初始节点，然后把两段链表交叉放进去

bool flag = true;
ListNode *cur = head;

while(head1 || head2){  // 这里用 或运算 是因为，链表1要么和链表2长度相等，要么多一个。所以先取链表1的元素，最后两个都空了才算取完
    if(flag){  // 放第一段
        cur->next = head1;
        head1 = head1->next;
    }
    else{
        cur->next = head2;
        head2= head2->next;
    }
    cur = cur->next;
    flag = !flag;
}

head = head->next;  // 去掉开头的初始节点
```



### <font color=dodgerblue>NC25 删除有序链表中重复的元素-I</font>

递归删除。

记得要判断nullptr

```
/**
 * struct ListNode {
 *	int val;
 *	struct ListNode *next;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param head ListNode类 
     * @return ListNode类
     */
    ListNode* deleteDuplicates(ListNode* head) {
        if(head == nullptr) return nullptr;
        ListNode* cur = head;
        
        while(cur->next && cur->val == cur->next->val){
            cur->next = cur->next->next;
        }
        
        head->next = deleteDuplicates(cur->next);  // 这里 cur 和 head 可以随意替换
        
        return head;
    }
};
```



### ⚡️<font color=purple>NC24 删除有序链表中重复的元素-II</font>

与 NC25 相比，重复的元素要一个不留，所以需要设置一个 flag 来判断是否要删除当前节点。

如果要删除当前节点：

```
head = deleteDuplicates(cur->next);
```

否则，和以前一样

```
head->next = deleteDuplicates(cur->next);
```



方法一：vector（不推荐，2022.11.30 已删除本段代码）

空间复杂度 O(n)，时间复杂度 O(n)



方法二：原地删除

空间复杂度 O(1)，时间复杂度 O(n)

（我的方法比较啰嗦，2022.06.08 已删除）。

放题解的代码：递归删除。

```
/*
struct ListNode {
    int val;
    struct ListNode *next;
    ListNode(int x) :
        val(x), next(NULL) {
    }
};
*/
class Solution {
public:
    ListNode* deleteDuplication(ListNode* pHead) {
        if(pHead==nullptr) return nullptr;
        
        ListNode* cur = pHead;
        ListNode* head = pHead;
        
        int flag = 0;
        while(cur->next && cur->val == cur->next->val){
            // 删除cur后面的，并在最后删除头节点
            cur->next = cur->next->next;
            flag = 1;
        }
        if(flag){  // 删除头节点
            head = deleteDuplication(cur->next);
        }
        else{
            head->next = deleteDuplication(cur->next);
        }
        return head;
    }
};
```





### NC133 链表的奇偶重排

开两个新的链表头，然后把原链表的元素交替喂给新的链表。

像是NC33的反过来。

```
/**
 * struct ListNode {
 *	int val;
 *	struct ListNode *next;
 *	ListNode(int x) : val(x), next(nullptr) {}
 * };
 */
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param head ListNode类 
     * @return ListNode类
     */
    ListNode* oddEvenList(ListNode* head) {
        if(head==nullptr) return head;
        ListNode* head1 = new ListNode(0);
        ListNode* head2 = new ListNode(0);
        ListNode* cur, *cur1, *cur2;
        cur1 = head1; cur2 = head2;
        cur = head;
        
        int flag = 1;
        while(cur){
            if(flag){  // 放到链表1的末尾
                cur1->next = cur;
                cur1 = cur;
            }
            else{
                cur2->next = cur;
                cur2 = cur;
            }
            cur = cur->next;
            flag = !flag;
        }
        // 拼接
        cur2->next = nullptr;  // 记得清零，如果是原链表是奇数个，不清零会产生循环
        cur1->next = head2->next;
        return head1->next;
    }
};
```





## 查找

⚠️如果二分查找  int = mid = l + ((r-l) >> 1) 一定要加括号！！！！！

**对于二分查找，我主张的是在循环内就解决，而不是等while条件不满足之后返回 left or right。所以通常在 if < 和 if > 之后，再加一个 if ==。并没有增加耗时，反而容易进行边界处理。**



### NC105 二分查找-II

从左到右第一个出现的target的下标

先判断小于和大于，最后的else再给等于。

找到目标值之后，向左查找，保证第一次出现。

```
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 如果目标值存在返回下标，否则返回 -1
     * @param nums int整型vector 
     * @param target int整型 
     * @return int整型
     */
    int search(vector<int>& nums, int target) {
        if(nums.size()==0 || nums[0]>target || nums[nums.size()-1] < target)
            return -1;
        int l = 0;
        int r = nums.size()-1;
        while(l<=r){
//             printf("%d %d\n", l, r);
            int mid = (l+r)/2;
            if(nums[mid]<target){
                l = mid+1;
            }
            else if(nums[mid]>target){
                r = mid-1;
            }
            else{  // 找到目标，继续向左
                while(mid>0 && nums[mid-1]==target)
                    mid--;
                
                return mid;
            }
        }
        return -1;
    }
};
```



方法二：

直接lower_bound

```
int search(vector<int>& nums, int target) {
        if(nums.size()==0 || nums[0]>target || nums[nums.size()-1] < target)
            return -1;
        
        int index = lower_bound(nums.begin(), nums.end(), target) - nums.begin();
        if(index==0){  // index==0可能本来就是0，也可能是没找到
            if(nums[0]!=target)
                return -1;
        }
        return index;
    }
```



### <font color=dodgerblue>NC32 求平方根</font>

二分查找

```
class Solution {
public:
    /**
     * 
     * @param x int整型 
     * @return int整型
     */
    int sqrt(int x) {
        if(x==0) return 0;
        
        long long left, right, mid;
        left = 1; right = x;
        long long temp;
        while(left<=right){
            mid = (left+right)/2;
            temp = mid*mid;
            if(temp >x){
                right = mid-1;
            }
            else if(temp<x){
                left = mid+1;
            }
            else return mid;
        }
        return right;
        
    }
};
```



牛顿法

https://www.cnblogs.com/Allen-rg/p/13602550.html

<img src="https://cdn.jsdelivr.net/gh/Lenvia/md-pic@master/uPic/1344012-20181105091934676-1885017107-20230216144353289.png" alt="img" style="zoom:50%;" />

int版本

```
class Solution {
public:
    /**
     * 
     * @param x int整型 
     * @return int整型
     */
    int sqrt(int x) {
        long long root = x;
        while(root*root-x>0){
            root = (root+x/root)/2;
        }
        return (int)root;
    }
};
```



考虑精度

```
double NtSqrt(const double num){
    if (num < 0)
        return -1;
    else{
        double root = num;
        // 如果原值减去近似根的平方大于误差，继续循环
        while (abs(num - root * root) >= err){
            // 得到下一个近似根
            root = (num / root + root) / 2.0;
        }
        return root;
    }
}
```



### ⚡️<font color=purple>NC48 在旋转过的有序数组中寻找目标值</font>

方法一：

头尾相连。使用mod。（复杂度 O(n)）

在查找过程中肯定是一直沿着一个方向走，所以最多循环n次一定能找到。

如果中途出现了左右摇摆，说明不存在。提前退出。

```
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param nums int整型vector 
     * @param target int整型 
     * @return int整型
     */
    int search(vector<int>& nums, int target) {
        int len = nums.size();
        int n = len;  // 用来循环
        int i = 0;
        
        int left = 0;
        int right = 0;
        while(n--){
            if(left && right)  // 如果出现左右摇摆，提前终止
                return -1;
            if(nums[i%len]<target){  // 往右走
                i = (i+1)%len;
                right = 1;
            }
            else if(nums[i%len]>target){
                i = (i+len-1)%len;  // 往左走
                left = 1;
            }
            else return i;
        }
        // 遍历完了还没找到一定是不存在
        return -1;
    }
};
```



方法二：二分查找（复杂度 O(logn))

<img src="https://cdn.jsdelivr.net/gh/Lenvia/md-pic@master/uPic/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f3030386933736b4e6c7931677a65686d6173326e396a333138383074326d79312e6a7067.jpeg" alt="img" style="zoom: 33%;" />

mid = (left+right)/2。 [left, mid] 和 [mid, right] 总有一个区间是单调的。

哪个区间单调可以通过 nums[left], nums[mid] 的大小判断。

以在 [left, mid] 单调为例：

如果target不在 left到mid这段区间，则一定是 nums[mid]<target || nums[left]>target，此时就舍弃这个区间，left = mid+1。

如果在，就 right = mid-1

```
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param nums int整型vector 
     * @param target int整型 
     * @return int整型
     */
    int search(vector<int>& nums, int target) {
        int left, right, mid;
        left = 0; right = nums.size()-1;
        
        while(left<=right){
            mid = (left+right)>>1;
            if(nums[mid]==target)
                return mid;
            
            if(nums[mid]>=nums[left]){  // 左侧单调
                if(nums[mid]<target || nums[left]>target){  // target不在 [left, mid] 里
                    left = mid+1;
                }
                else right = mid-1;
            }
            else{  // 左侧非单调，则右侧一定单调
                if(nums[mid]>target || nums[right]<target){
                    right = mid-1;
                }
                else{
                    left = mid+1;
                }
            }
        }
        
        return -1;
    }
};
```



### <font color=purple>剑指 Offer 11. 旋转数组的最小数字</font>

上一题的进阶，可能存在重复数字。

既然找<u>最小数字</u>，这里最好让 mid 每次和 r比较，<font color=red>尽量不要轻易把 l 向右移动</font>。

要分三种情况：

```
if(numbers[mid] < numbers[r]){  // 右边严格升序
	r = mid;
}
else if(numbers[mid] > numbers[r]){  // 在 (mid, r]
	l = mid+1;
}
else{  // 不能确定在 mid 的左侧还是右侧，但是可以把右边界缩小
	r--;
}
```

完整代码：

```
class Solution {
public:
    int minArray(vector<int>& numbers) {
        if(numbers.size() == 0) return 0;

        int l, r;
        l = 0;
        r = numbers.size()-1;

        while(l<r){
            // cout<<l<<" "<<r<<endl;
            int mid = l + ((r-l)>>1);
            if(numbers[mid] < numbers[r]){  // 右边严格升序
                r = mid;
            }
            else if(numbers[mid] > numbers[r]){  // 在 (mid, r]
                l = mid+1;
            }
            else{  // 不能确定在 mid 的左侧还是右侧，但是可以把右边界缩小
                r--;
            }
        }
        return numbers[l]; 
    }
};
```





### <font color=purple>NC30 缺失的第一个正整数</font>

有多种解法。

先排序然后找（时间O(nlogn)，空间O(1)）、辅助map（时间O(n)，空间O(n)）、交换法（时间O(n)，空间(O(1))。

前面两个方法很显然，这里只写交换法。

```
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param nums int整型vector 
     * @return int整型
     */
    int minNumberDisappeared(vector<int>& nums) {
        int n = nums.size();
        
        for(int i=0; i<n; i++){
            // 如果在[1, n]之内且位置不对。 （默认位置对表示为 nums[i] = i+1）
            // 一直换，直到这个位置正确 或者 这个位置有负数 
            // 或者 这两个位置的数相同，会造成死循环
            while(nums[i]>=1 && nums[i]<=n && nums[i]!=i+1 && nums[i]!=nums[nums[i]-1]){
                swap(nums[i], nums[nums[i]-1]);
            }
        }
        for(int i=0; i<n; i++){
            if(nums[i]!=i+1)  // 如果还有错乱的，说明这个位置没有对应的正数
                return i+1;
        }
        // 不缺
        return n+1; 
    }
};
```



### ⚡️<font color=purple>NC95 数组中的最长连续子序列</font>

题目要求空间O(n) 时间O(nlogn)，提示是并查集，但直接暴力排序+遍历似乎就行了。

方法一：暴力

```
class Solution {
public:
    /**
     * max increasing subsequence
     * @param arr int整型vector the array
     * @return int整型
     */
    int MLS(vector<int>& arr) {
        if(arr.size()==1) return arr[0];
        sort(arr.begin(), arr.end());
        
        int maxx = 1;
        int cur = 1;
        for(int i=1; i<arr.size(); i++){
            if(arr[i]==arr[i-1])
                continue;
            else if(arr[i]==arr[i-1]+1){
                cur++;
                maxx = max(maxx, cur);
            }
            else cur = 1;  // 重置
        }
        return maxx;
    }
};
```



方法二：并查集思想

第一次遍历放入map，第二次遍历仅对序列的开头向后查找。

```
class Solution {
public:
    /**
     * max increasing subsequence
     * @param arr int整型vector the array
     * @return int整型
     */
    map<int, bool>exist;
    int MLS(vector<int>& arr) {
        if(arr.size()==1) return arr[0];
        exist.clear();
        
        for(int i=0; i<arr.size(); i++)  // 全放进去
            exist[arr[i]] = true;
        
        int maxx, cur, num;
        maxx = 1;
        for(int i=0; i<arr.size(); i++){
            if(exist[arr[i]-1])  // 如果存在在它前面的，不能当作头
                continue;
            cur = 1;
            num = arr[i];
            while(exist[num+1]){  // 从头开始向后找
                cur++;
                maxx = max(cur, maxx);
                num++;
            }
        }
        
        return maxx;
    }
};
```



### <font color=orange>NC107 寻找峰值</font>

找出任意一个局部极大值的位置。

二分法

- nums[mid] < nums[mid + 1]说明在“上坡”，则可以使left = mid + 1（因为mid肯定不是峰值），向“峰”处压缩
- nums[mid] > nums[mid + 1]说明在“下坡”，则应该使right = mid（mid可能是峰值），往“峰”处压缩

虽然开始left和right之间可能有多个峰值，但是随着left和right不断逼近，最后两者之间一定会压缩到一个峰值上，因为两者都是向“峰”不断靠近的，但是不会超过最终的“峰”。

我理解了，但没完全理解。

```
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param nums int整型vector 
     * @return int整型
     */
    int findPeakElement(vector<int>& nums) {
        if(nums.size()<=1) return 0;
        
        int left = 0;
        int right = nums.size()-1;
        int mid;
        while(left<right){
            mid = left+ (right-left)/2;
            if(nums[mid]<= nums[mid+1]){  // 往右上坡
                left = mid+1;
            }
            else right = mid;
        }
        return left;
    }
};
```



### ⚡️<font color=fuchsia>NC36 在两个长度相等的排序数组中找到上中位数</font>

暴力：双指针，逐位移动。

```
class Solution {
public:
    /**
     * find median in two sorted array
     * @param arr1 int整型vector the array1
     * @param arr2 int整型vector the array2
     * @return int整型
     */
    int findMedianinTwoSortedAray(vector<int>& arr1, vector<int>& arr2) {
        if(arr1.size()==1)
            return min(arr1[0], arr2[0]);
        
        int index1, index2;
        int mid = (arr1.size()+arr2.size())/2;
        int count = 0;
        int res;
        for(index1 = 0, index2 = 0; index1<arr1.size() && index2<arr2.size() && count<mid; count++){
            if(arr1[index1]<arr2[index2]){
                res = arr1[index1];
                index1++;
            }
            else{
                res = arr2[index2];
                index2++;
            }
        }
        return res;
        
    }
};
```





**进阶：二分查找**

```

class Solution {
public:
    /**
     * find median in two sorted array
     * @param arr1 int整型vector the array1
     * @param arr2 int整型vector the array2
     * @return int整型
     */
    int findMedianinTwoSortedAray(vector<int>& arr1, vector<int>& arr2) {
        int n = arr1.size();

        int left, right;
        left = 0; right = n;

        int i, j;
        int vi, vim1, vj, vjm1;

        int left_max, right_min;

        // 找到最大的 i 使得 arr1[i-1] <= arr2[j]
        while(left <= right){
            i = (left + right) / 2;
            j = (2*n + 1) /2 - i;

            vim1 = i==0 ? INT_MIN: arr1[i-1];
            vi = i==n? INT_MAX : arr1[i];
            vjm1 = j==0 ? INT_MIN: arr2[j-1];
            vj = j==n? INT_MAX : arr2[j];

            if(vim1 <= vj){
                left_max = max(vim1, vjm1);
                right_min = min(vi, vj);
                left = i+1;
            }
            else{
                right = i-1;
            }
        }

        return left_max;

    }
};
```



[lc] 寻找两个有序数组的中位数

https://leetcode.cn/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/

https://blog.csdn.net/mynameisJW/article/details/105884061

首先，让较短的数组放在第一个。

将两个数组各自划分成两部分，注意，这里的 i 共有 m+1 个位置！你可以理解为 i 表示分割线的位置。

```
      left_part          |        right_part
A[0], A[1], ..., A[i-1]  |  A[i], A[i+1], ..., A[m-1]
B[0], B[1], ..., B[j-1]  |  B[j], B[j+1], ..., B[n-1]
```

两个左半部分放在一起，两个右半部分放在一起。

我们想把中位数限定在分割线附近的元素，即 A\[i-1\], A\[i\], B\[j-1\], B\[j\]。

这样的话就要保证 两边元素个数必须始终保持稳定（ 总数为偶数时 len(left_part)=len(right_part)， 奇数时 len(left_part)=len(right_part) +1）。 

等价于 i + j = m − i + n − j（或 i + j = m - i + n - j + 1， m+n为奇数时），于是 **j = (m + n + 1) / 2 - i**

**此外，为了考虑边界问题！把 -1 和 m或n 位置设置为 负无穷和正无穷**

```
// 由于下面需要频繁判断边界，所以这里直接赋予边界变量
int vim1, vi, vjm1, vj;  // 分别表示 nums1[i-1], nums1[i], nums2[j-1], nums2[j]
vim1 = (i==0? INT_MIN:nums1[i-1]);
vi = (i==m? INT_MAX:nums1[i]);
vjm1 = (j==0? INT_MIN:nums2[j-1]);
vj = (j==n? INT_MAX:nums2[j]);
```

循环终止条件，也可以表示成

```
i + j = m − i + n − j（或 i + j = m - i + n - j + 1， m+n为奇数时）
B[j − 1] <= A[i]  &&  A[i − 1] <= B[j]
```



等价于：

![截屏2023-02-08 21.21.05](/Users/yy/Library/Application Support/typora-user-images/截屏2023-02-08 21.21.05.png)

因为随着 i递增，A\[i-1\] 递增，B\[j\] 递减。如果i最大了，说明 i+1 一定不满足，于是 A\[i+1-1\] > B\[j-1\]，即 B\[j-1\] ≤ A\[i\]）



然后就是二分了。

结果，如果总数为奇数，那就是左边的最大值。 否则，是左边的最大值和右边最小值的平均。

```
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        if(nums1.size() > nums2.size()) // 让短的当nums1 
            nums1.swap(nums2);

        int m = nums1.size();
        int n = nums2.size();

        int left, right;
        left = 0; right = m;  // 右边是到m！！！因为分割线有m+1种画法

        int i,j;
        // 由于下面需要频繁判断边界，所以这里直接赋予边界变量
        int vim1, vi, vjm1, vj;  // 分别表示 nums1[i-1], nums1[i], nums2[j-1], nums2[j]

        int left_max, right_min;  // 左半部分最大值和右半部分最小值
        while(left<=right){
            
            i = (left+right)/2;
            j = (m + n +1)/ 2 - i;
            vim1 = (i==0? INT_MIN:nums1[i-1]);
            vi = (i==m? INT_MAX:nums1[i]);
            vjm1 = (j==0? INT_MIN:nums2[j-1]);
            vj = (j==n? INT_MAX:nums2[j]);

            // 开始计算中位数
            // 满足nums[i-1]<nums2[j] 且 nums[j-1]<nums1[i] 等价于 最大的 nums1[i-1] <= nums2[j]
            if(vim1 <= vj){
                left_max = max(vim1, vjm1);
                right_min = min(vi, vj);
                left = i+1;
            }
            else{
                right = i-1;
            }
        }

        return (m+n)&1 ? (double)left_max : (double)(left_max+right_min)/2.0;
    }
};
```





## 搜索

### NC109 岛屿数量

一次性的dfs，甚至不需要开辟visited

```
class Solution {
public:
    /**
     * 判断岛屿数量
     * @param grid char字符型vector<vector<>> 
     * @return int整型
     */
    int dir[4][2] = {{1, 0}, {-1,0}, {0,1}, {0,-1}};
    int count = 0;
    int m,n;
    
    void dfs(vector<vector<char> >& grid, int curx, int cury){
    	grid[curx][cury] = '0';
        int newx, newy;
        for(int i=0; i<4; i++){
            newx = curx+dir[i][0];
            newy = cury+dir[i][1];
            if(newx<0 || newx>=m || newy<0 || newy>=n)// 越界
                continue;
            if(grid[newx][newy]=='1'){
                dfs(grid, newx, newy);
            }
        }
    }
        
    int solve(vector<vector<char> >& grid) {
        if(grid.empty()) return 0;
        m = grid.size(); n = grid[0].size();

        
        for(int i=0; i<m; i++){
            for(int j=0; j<n; j++){
                if(grid[i][j]=='1'){
                    dfs(grid, i, j);
                    count++;
                }
            }
        }
        return count;
    }
};
```





### <font color=dodgerblue>NC29 二维数组中的查找</font>（与NC86完全相同）

**同 [lc]面试题 10.09. 排序矩阵查找**

> 2022.02.15 字节面试题

https://leetcode-cn.com/problems/sorted-matrix-search-lcci/

以前做过，但面试时突然懵逼了。

我就记得有序矩阵好像需要转换一下思路。

从左下角开始搜索，那么只需要向上和向右搜索就行。最坏情况下的时间复杂度是O(m+n)

```
class Solution {
public:
    bool Find(int target, vector<vector<int> > array) {
        if(array.empty() || array[0].empty()) return false;
        
        int m,n;
        m = array.size(); n = array[0].size();
        
        if(array[0][0]> target || array[m-1][n-1]<target) return false;
        
        int i,j;
        i = m-1; j = 0;
        while(true){
            if(array[i][j]<target)  // 向右
                j++;
            else if(array[i][j]>target)  // 向上
                i--;
            else return true;

            if(i<0 || j>=n) return false;  // 到边界之外了，没找到
        }
    }
};
```



### NC86 矩阵元素查找

```
class Solution {
public:

    vector<int> findElement(vector<vector<int> > mat, int n, int m, int x) {
        if(n==0 || m==0) 
            return vector<int>{-1, -1};
        if(x<mat[0][0] || x>mat[n-1][m-1])
            return vector<int>{-1, -1};
        
        int i,j;
        i = n-1; j = 0;
        while(true){
            if(mat[i][j]<x)
                j++;
            else if(mat[i][j]>x)
                i--;
            else return vector<int>{i, j};
            
            if(i<0 || j>=m) return vector<int>{-1, -1};
        }
    }
};
```





### NC26 括号生成

DFS 暴力搜索+剪枝。

水题。

```
class Solution {
public:
    /**
     * 
     * @param n int整型 
     * @return string字符串vector
     */
    vector<string>vec;
    
    void dfs(string cur, int n, int l, int r){
        if(l==n && r==n)
            vec.push_back(cur);
        if(l+1<=n)
            dfs(cur+"(", n, l+1, r);
        if(r+1<=l)
            dfs(cur+")", n, l, r+1);
    }
    
    vector<string> generateParenthesis(int n) {
        if(n==0) return vec;
        dfs("", n, 0, 0);
        return vec;
    }
};
```



### ⚠️NC43 没有重复项数字的全排列

看题，没有重复数字。

简单DFS

```
class Solution {
public:
    
    vector<vector<int>> res;  // 结果
    vector<int>temp;  // 临时
    bool visited[7];  // 原数组第i位是否visit
    
    
    
    void dfs(vector<int> &num, int pos){
        if(pos==num.size()){
            res.push_back(temp);
            return ;
        }
        
        for(int i=0; i<num.size(); i++){
            if(!visited[i]){
                temp.push_back(num[i]);
                visited[i] = true;
                dfs(num, pos+1);
                temp.pop_back();
                visited[i] = false;
            }
        }
    }
    
    vector<vector<int> > permute(vector<int> &num) {
        if(num.empty()) return res;
        sort(num.begin(), num.end());
        memset(visited, false, sizeof(visited));
        dfs(num, 0);
        return res;
    }
};
```



法二：swap（同样适用于NC 42）

见NC121

```
class Solution {
public:
    void perm(int pos, string s, set<string> &ret) {
        if (pos+1 == s.length()) {
            ret.insert(s);
            return;
        }
        // for循环和swap的含义：对于“ABC”，
        // 第一次'A' 与 'A'交换，字符串为"ABC", pos为0， 相当于固定'A'
        // 第二次'A' 与 'B'交换，字符串为"BAC", pos为0， 相当于固定'B'
        // 第三次'A' 与 'C'交换，字符串为"CBA", pos为0， 相当于固定'C'
        for (int i = pos; i < s.length(); ++i) {
            swap(s[pos], s[i]);
            perm(pos+1, s, ret);
            swap(s[pos], s[i]);
            // 回溯的原因：比如第二次交换后是"BAC"，需要回溯到"ABC"
            // 然后进行第三次交换，才能得到"CBA"
        }
    }
    vector<string> Permutation(string s) {
        if (s.empty()) return {};
        set<string> ret;
        perm(0, s, ret);
        return vector<string>({ret.begin(), ret.end()});
    }
};
```





### ⚡️<font color=orange>NC42 有重复项数字的全排列</font>

方法一：DFS + BKDR_Hash

有重复数字，BKDR Hash（字符串哈希）。

在临时vector放到结果之前，开个map检查一下哈希值是否已经存在。

2022.08.20 增加了剪枝

```
if (visited[i] || (i > 0 && nums[i] == nums[i - 1] && !visited[i - 1]))
	continue;
```

同一个pos下，如果该位置的元素和前一位相同，并且前一位没访问，那这一位就不能访问。

```
class Solution {
  public:

    vector<vector<int>> res;  // 结果
    vector<int>temp;  // 临时
    map<long long, bool>exist;  // vector 使用BKDR Hash
    bool visited[9];  // 原数组第i位是否visit

    // BKDR Hash
    int seed = 1331;
    bool existed() {
        long long res = 0;
        for (int i = 0; i < temp.size(); i++) {
            res = res * seed + temp[i];
        }
        res = res & 0x7fffffff;

        // 如果已经存在，返回重复。 不存在，就新增到map
        if (exist.find(res) != exist.end())
            return true;
        else exist[res] = true;

        return false;
    }

    void dfs(vector<int>& num, int pos) {
        if (pos == num.size()) {
            if (!existed())
                res.push_back(temp);
            return ;
        }

        for (int i = 0; i < num.size(); i++) {
            if (!visited[i]) {
                // 关键剪枝：同一个pos下，如果该位置的元素和前一位相同，并且前一位没访问，那这一位就不能访问。
                if (i > 0 && num[i] == num[i - 1] && !visited[i - 1])
                    continue;
                temp.push_back(num[i]);
                visited[i] = true;
                dfs(num, pos + 1);
                temp.pop_back();
                visited[i] = false;
            }
        }
    }

    vector<vector<int> > permuteUnique(vector<int>& num) {
        if (num.empty()) return res;
        sort(num.begin(), num.end());
        memset(visited, false, sizeof(visited));
        dfs(num, 0);
        return res;
    }
};
```



方法二：while 直接调用 next_permutation(num.begin(), num.end())

next_permutation()会取得[first,last)所标示之序列的下一个排列组合，如果没有下一个排列组合，便返回false；否则返回true。（会自动去重！）

```
class Solution {
public:
    
    vector<vector<int>> res;
    
    vector<vector<int> > permuteUnique(vector<int> &num) {
        if(num.empty()) return res;
        sort(num.begin(), num.end());
        
        res.push_back(num);
        while(next_permutation(num.begin(), num.end())){
            res.push_back(num);
        }
        return res;
    }
};
```





### ⚡️<font color=purple>NC46 加起来和为目标值的组合(二)</font>

DFS+剪枝。（不必用BKDR Hash）

你以前应该能很快做出来的！

两个关键剪枝：1. 遇到与前一位相同的（continue） 2. 加上当前位溢出了，那后面的也会溢出（break）

```
class Solution {
public:
    
    vector<vector<int>>res;
    vector<int>temp;

    
    // pos表示当前temp里的元素位置，index是原数组num的当前元素下标
    bool dfs(vector<int> &num, int pos, int index, int target){
        if(target==0){
            res.push_back(temp);
            return true;
        }
        
        // 同一个pos
        for(int i=index; i<num.size(); i++){  // 不会往前搜索
            if(target-num[i]<0) break;  // 加上该位就超了，后面的也超。
            
            if(i-1>=index && num[i]==num[i-1])  // 如果对于同一个pos，num[i] == num[i-1]，肯定重复了
                continue;
            temp.push_back(num[i]);
            dfs(num, pos+1, i+1, target-num[i]);  // 找到符合条件的之后，就不用往后找了
            temp.pop_back();
        }
        return false;
    }
    
    vector<vector<int> > combinationSum2(vector<int> &num, int target) {
        if(num.empty()) return res;
        sort(num.begin(), num.end());
        dfs(num, 0, 0, target);
        return res;
    }
};
```





### NC20 数字字符串转化成IP地址

dfs+剪枝。

节省时间的剪枝：剩余的元素个数够不够

判断是否合法：转int后小于255，并且超过1位后不能用零开头。

```
class Solution {
public:
    /**
     * 
     * @param s string字符串 
     * @return string字符串vector
     */
    vector<vector<string>>res;
    vector<string>ans;
    string str;
    
    bool valid(string str){  // 判断str是否合法
//         if(str.length()<1 || str.length()>3) return false;
        if(str.length()>1 && str[0]=='0') return false;  // 超过1位后，不能用0开头
        if(stoi(str)<=255) return true;
        return false;
    }
    
    void dfs(string s, vector<string>cur, int pos, int start){  // pos表示当前第几段，start表示开始下标
        if(pos<4){
            // 剪枝，从start开始，至少还需要 4-pos个元素
            // 最后一个元素的坐标是 start+4-pos-1 要求 <= s.length()-1
            if(start+4-pos >s.length()) return ;
        }
        else{  // pos>=4 或者说 ==4
            if(start!=s.length()) return ;  // 不能剩
            res.push_back(cur);
            return ;
        }
        
        for(int k=1; k<=3; k++){  // 每一段的长度。区间就是[start, start+k-1]
            if(start+k-1 < s.length()){
                str = s.substr(start, k);
                if(valid(str)){
                    cur.push_back(str);
                    dfs(s, cur, pos+1, start+k);
                    cur.pop_back();
                }
            }
        }
    }
    
    vector<string> restoreIpAddresses(string s) {
        vector<string>cur;
        dfs(s, cur, 0, 0);
        
        string temp;
        for(int i=0; i<res.size(); i++){
            temp = res[i][0];
            for(int j=1; j<res[i].size(); j++){
                temp.push_back('.');
                temp+=res[i][j];
            }
            ans.push_back(temp);
        }
        return ans;
        
    }
};
```



### [lc]78 subsets II

递归+回溯。

应该在dfs的第一行添加结果，而不是等cur==size时添加。

```
class Solution {
public:

    vector<vector<int>>res;
    vector<int>temp;

    void dfs(vector<int>& nums, int cur){
        res.push_back(temp);
        if(cur >= nums.size()){
            return;
        }

        for(int i=cur; i<nums.size(); i++){
            temp.push_back(nums[i]);  // 取
            dfs(nums, i+1);
            temp.pop_back();  // 不取
        }
    }

    vector<vector<int>> subsets(vector<int>& nums) {
        res.clear();
        temp.clear();
        dfs(nums, 0);
        return res;
    }
};
```





## 双指针

### <font color=purple>NC54 三数之和</font>

从前到后固定第一个数num[i]，然后双指针。左指针从i+1开始，右指针从末尾开始。

temp_sum = num[i]+num[left]+num[right];

如果和小于0，左指针右移；大于0，右指针左移；等于0，保存结果。并且把左右指针向内移动到不一样的地方。

此外，注意第一个数的选择不能重复。

```
class Solution {
public:
    vector<vector<int> > threeSum(vector<int> &num) {
        vector<vector<int>>res;
        if(num.size()<3) return res;
        
        sort(num.begin(), num.end());
        int left,right;
        for(int i=0; i<num.size()-2; i++){  // -2是要至少留两个位置
            if(i!=0 && num[i]==num[i-1])  // 第一个数不能重复
                continue;
            left = i+1;
            right = num.size()-1;
            while(left<right){
                int temp_sum = num[i]+num[left]+num[right];
                if(temp_sum==0){
                    res.push_back({num[i], num[left], num[right]});
                    // left向右移动到不同的元素
                    while(left+1<right && num[left]==num[left+1]) left++;
                    left++;
                    // right向左移动到不同的元素
                    while(right-1>left && num[right]==num[right-1]) right--;
                    right--;
                }
                else if(temp_sum<0)
                    left++;
                else right--;
            }
        }
        return res;
    }
};
```



### NC134 买卖股票的最好时机(二)

> 你可以多次买卖该只股票，但是再次购买前必须卖出之前的股票

双指针，注意边界！！！

<img src="https://cdn.jsdelivr.net/gh/Lenvia/md-pic@master/uPic/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f65366339643234656c7931677a686f7937716736676a323138773070387767332e6a7067.jpeg" alt="截屏2022-02-18 15.22.00" style="zoom:33%;" />

只要两天之间是上涨的，那一定在两个端点买入卖出。

记录start，然后从start找非递减。

```
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 计算最大收益
     * @param prices int整型vector 股票每一天的价格
     * @return int整型
     */
    int maxProfit(vector<int>& prices) {
        // 只要两天之间是上涨的，那一定要在i天买入
        int res = 0;
        int i, start;
        for(i=0; i<prices.size()-1; i++){
            int start = i;
            while(i+1<prices.size() && prices[i]<prices[i+1])
                i++;
            // 运行到这里，prices[i]>=prices[i+1]
            res += (prices[i] - prices[start]);
        }
        return res;
    }
};
```



### <font color=red>[lc]31. 下一个排列</font>

参考[这篇题解](https://leetcode.cn/problems/next-permutation/solutions/80560/xia-yi-ge-pai-lie-suan-fa-xiang-jie-si-lu-tui-dao-/)

1. 从后向前 查找第一个 相邻升序 的元素对 (i,j)，满足 A[i] < A[j]。此时 [j,end) 必然是降序
2. 在 [j,end) 从后向前 查找第一个满足 A[i] < A[k] 的 k。A[i]、A[k] 分别就是上文所说的「小数」、「大数」
3. 将 A[i] 与 A[k] 交换
4. 可以断定这时 [j,end) 必然是降序，逆置 [j,end)，使其升序
5. 如果在步骤 1 找不到符合的相邻元素对，说明当前 [begin,end) 为一个降序顺序，则直接跳到步骤 4



```
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        if(nums.size() <=1) return ;

        int i = nums.size()-2;
        int j = nums.size()-1;
        int k = j;

        for(; i>=0 && nums[i] >= nums[j]; ){  // 从后往前遇到第一个升序对
            i--; j--;
        }

        if(i<0){  // 全是降序
            reverse(nums.begin(), nums.end());
            return ;
        }
        
        // 在[j, end) 从后向前找第一个大于 nums[i] 的数
        for(; k>=j && nums[k] <= nums[i] ;){
            k--;
        }

        swap(nums[i], nums[k]);
        sort(nums.begin()+ j, nums.end());
    }
};
```





### <font color=red>[lc]和大于等于target的最短子数组</font>

（2022.06.09 字节 ailab 一面）

**注意：这里并不要求数组有序！**

方法一：暴力，前缀和数组，我就不说了

方法二：双指针

思路不难，我之所以给它红色，是因为代码不好写。我之前在外层for循环，内部两个串行的while循环，写麻了还没过。

本来right 和 left的移动就有顺序 内外，所以就把right放在外面就是了！

```
class Solution {
public:

    int maxx = 0x7ffff;
    int minSubArrayLen(int target, vector<int>& nums) {
        if(nums.empty()) return 0;

        int left, right;
        int cur = 0;
        left = 0; right = 0;
        int minL = maxx;
        while(right<nums.size()){
            // printf("%d %d\n", left, right);
            // 若小于target，不断向右移动
            cur+=nums[right];
            // left向右收缩
            while(cur>=target && left <= right){
                minL = min(minL, right-left+1);  // 这里应该放在开头！因为减去后并不能保证还满足target
                cur-=nums[left];
                left++;
            }
            
            // 到这里，[left, right] 区间的和 一定不满足 target，回到上面
            // 在这个地方，left 是可以大于 right的 ！
            right++;
        }
        return minL == maxx ? 0 : minL;
    }
};
```









### 🔥⚡️<font color=orange>NC125 和为K的连续子数组</font>

（2023.05 腾讯一面）前缀和数组

原题所述「原数组区间和」转变为「preSum数组某两个数之差」

哈希表具有「空间换时间」的作用，因此先定义哈希表hash，并做如下映射：

hash[preSum[i]] = i（即做”前缀和“到”下标“之间的映射）**在构建哈希表过程中，仅当「preSum[i]未出现在哈希表中时，才将其添加到哈希表中」，目的是：记录「第一次出现该前缀和的位置」。**

在构建完hash后，从后到前遍历preSum数组，其中 target = preSum[i] - k 即为在哈希表中要查找的数，若找到，更新res，否则继续向前遍历。

```
class Solution {
public:
    /**
     * max length of the subarray sum = k
     * @param arr int整型vector the array
     * @param k int整型 target
     * @return int整型
     */
    int maxlenEqualK(vector<int>& arr, int k) {
        if(arr.empty()) return 0;
        
        // 把第0位空出来是因为，如果arr[0] 为0的时候会少统计一个长度
        int preSum[arr.size()+1];  
        map<int, int>pos;
        preSum[0] = 0;
        pos[0] = 0;
        
        // 比如输入 [0,1,2,3] 时
        // k = preSum[i] - preSum[i]-k，所以索引范围应该是 (i- pos[preSum[i]-k], i]，左开右闭
        // 这就导致如果不在前面插入0，会出现问题：preSum = [0, 1, 3, 6]，这时候最大长度应该是索引0～2的闭区间，即长度为3
        // 如果插入0，则 preSum = [0, 0, 1, 3, 6]，索引范围(0, 3] 正好
        for(int i=0; i<arr.size(); i++){
            preSum[i+1] = preSum[i] + arr[i];
            if(!pos.count(preSum[i+1])){
                pos[preSum[i+1]] = i+1;
            }
        }
        
        int maxL = 0;
        for(int i=arr.size(); i>=0; i--){
            if(pos.count(preSum[i]-k)){
                maxL = max(maxL, i- pos[preSum[i]-k]);
            }
        }
        return maxL;
    }
};
```







## 排序

### NC140 排序

快排。区别于 <font color=red>NC119 NC88</font> 的 partition，partition 只需要划分 不要求完全有序，这里是递归达到完全有序。

```

class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 将给定数组排序
     * @param arr int整型vector 待排序的数组
     * @return int整型vector
     */

    void quickSort(vector<int>& arr, int l, int r){  // [left, right]
        if (l>=r) return ;
        if (l+1 == r){  // 只有两个位置
            if(arr[l] > arr[r]) swap(arr[l], arr[r]);
            return;
        }

        int randn = l + (rand()%(r-l+1));
        swap(arr[randn], arr[r]);

        int pivot = arr[r];
        int i = l;
        for(int j=l; j<r; j++){
            if(arr[j] < pivot){
                swap(arr[i], arr[j]);
                i++;  // i 永远指向第一个不小于pivot的位置
            }
        }
        swap(arr[i], arr[r]);

        quickSort(arr, l, i-1);
        quickSort(arr, i+1, r);
    }

    vector<int> MySort(vector<int>& arr) {
        quickSort(arr, 0, arr.size()-1);

        return arr;
    }
};
```



### <font color=red>[lc]912. 排序数组（进阶快排）</font>

三指针，把等于pivot元素的所有元素放在分割区间的中间，很多元素相等的情况下，递归区间大大减少。

案例给了含有 5W 个 2 的数组，即大量的重复元素，普通快排超时。

设置三个指针

```
int i = l; int j = l; int k = r;
```

于是划分成这样的区域：

- 小于 pivot 区间：[left, i)
- 等于 pivot 区间：[i + 1, j]
- 大于 pivot 区间：[k, right]

注意，与普通快排不同，在最后我们需要把第一个大于pivot的数与哨兵（最后一个位置）交换，所以必须保证 k 指向大于 pivot的位置。

所以 k 初始化为 r，并且每次先 自减，再交换。

```
class Solution {
public:
    void quickSort(vector<int>& nums, int l, int r){
        if(l>=r) return;
        if(l+1 == r){
            if(nums[l]>nums[r])
                swap(nums[l], nums[r]);
            return;
        }

        int index = l + rand()%(r-l);
        swap(nums[index], nums[r]);

        int pivot = nums[r];
        int i = l; int j = l; int k = r;

        // 在接下来的规则里，i保持和原有快排一样的规则，即i始终指向第一个不小于 pivot 的位置
        // j 是游动指针。 k 始终指向大于 pivot 的位置
        while(j < k){
            if(nums[j] < pivot)
                swap(nums[i++], nums[j++]);
            else if(nums[j] == pivot)
                j++;
            else{
                // 注意不能让k初始化为r-1并且这里写成 nums[k--]，因为这样做的话循环结束时，k并不指向大于pivot的位置
                // 那么循环结束后，j==k，将k位置与pivot位置互换时就会出问题。
                k--;
                swap(nums[j], nums[k]);  // 这里 j 不能加，因为不能保证刚交换后 nums[j]是 大于等于 pivot的
            }
        }
        swap(nums[j], nums[r]);


        quickSort(nums, l, i-1);
        quickSort(nums, k+1, r);
    }


    vector<int> sortArray(vector<int>& nums) {
        quickSort(nums, 0, nums.size()-1);
        return nums;
    }
};
```



### [lc]75. 颜色分类

我们使用整数 `0`、 `1` 和 `2` 分别表示红色、白色和蓝色。

排序，一边扫描，且常数空间。

受三指针快排的影响，我一开始写好了结构，但是有个问题，随机到的 pivot 必须得是1才行。总不能先遍历找到1然后再快排吧，那舍本逐末了。

but... 刚才说什么？ pivot 得是1才行，那我直接 令 pivot 为1不就得了，不要随机生成位置了。

但是这里 k 要为 n。为什么？因为以前的快排，最后需要 swap(nums[j], nums[r])。这里因为没有严格哨兵，所以不用swap，不会越界。并且比较的时候，需要把 n-1位置上的元素考虑进去。

```
class Solution {
public:
    void sortColors(vector<int>& nums) {
        if(nums.size() <= 1) return;

        if(nums.size() == 2){
            if(nums[0] > nums[1]) 
                swap(nums[0], nums[1]);
            return;
        }
        int n = nums.size();

        int i = 0; int j = 0; int k = n;
        while(j<k){
            if(nums[j] == 0){
                swap(nums[i++], nums[j++]);
            }
            else if(nums[j] == 2){
                k--;
                swap(nums[j], nums[k]);
            }
            else j++;
        }

        return;
    }
};
```



### ⭐️⚡️<font color=orange>NC119 最小的K个数</font>

https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=117&&tqId=37765&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking

1. 直接sort
2. **优先队列**：大顶堆，如果达到size后，判断新来的是否比队首小，如果小，则pop并放入新的。
3. 快排

对数组[l, r]一次快排partition过程可得到，[l, p), p, [p+1, r]三个区间

[l,p)为小于等于p的值，[p+1,r]为大于等于p的值。

然后再判断p，利用二分法



1. 如果[l,p), p，也就是p+1个元素（因为下标从0开始），如果p+1 == k, 找到答案
2. 如果p+1 < k, 说明答案在[p+1, r)区间内
3. 如果p+1 > k , 说明答案在[l, p)内

```
class Solution {
public:
    int partition(vector<int>& vec, int l, int r){  // [l, r]
        int randm = l + rand()%(r-l+1);  // 随机取一个座位pivot。 （注意是 r-l+1 别写反了！！错好几次了）
        swap(vec[randm], vec[r]);
        
        int pivot = vec[r];
        int i = l;
        for(int j=l; j<r; j++){
            if(vec[j]<pivot){
                swap(vec[i], vec[j]);
                i++;  // i永远指向第一个不小于pivot的元素
            }
        }
        swap(vec[i], vec[r]);
        return i;
    }
    
    vector<int> GetLeastNumbers_Solution(vector<int> input, int k) {
        vector<int>res;
        if(k==0 || k>input.size())
            return res;
        int left, right, index;
        left = 0;
        right = input.size()-1;
        while(left<=right){
            index = partition(input, left, right);  // [0, index] 和 [index, right]，左区间小于右区间
            if(index+1 < k){  // 答案在右半边
                left = index+1;
            }
            else if(index+1 > k){  // 答案在左半边
                right = index-1;
            }
            else{  // 答案就是 [0, index]
                return vector<int>({input.begin(), input.begin()+k});
            }
        }
        return res;
    }
};
```



优先队列解法

```
class Solution {
public:
    priority_queue<int> q;  // 大顶堆
    vector<int> GetLeastNumbers_Solution(vector<int> input, int k) {
        while(!q.empty()) q.pop();
        
        vector<int>res;
        int count = 0;
        if(k==0 || k>input.size())
            return res;
        
        for(int i=0; i<input.size(); i++){
            if(count<k){
                q.push(input[i]);
                count++;
            }
            else{
                int temp = q.top();  // 堆顶元素
                if(temp>input[i]){  // 如果新来的更小，放入堆，替换掉堆顶
                    q.pop();
                    q.push(input[i]);
                }
            }
        }
        while(!q.empty()){
            res.push_back(q.top());
            q.pop();
        }
        return res;
    }
};
```



### NC88 寻找第K大

https://www.nowcoder.com/practice/e016ad9b7f0b45048c58a9f27ba618bf?tpId=117&&tqId=37791&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking

快排+二分

```
class Solution {
public:
    int partition(vector<int> &input, int l, int r) {  // [l, r]
        int randm = rand()%(r-l+1) + l;
        swap(input[randm], input[r]);
        
        int pivot = input[r];
        int i = l;
        for (int j=l; j<r; ++j) {
            if (input[j] < pivot) {
                swap(input[i++], input[j]);  // i每次更新后永远指向第一个大于等于pivot的数
            }
        }
        swap(input[i], input[r]);
        return i;
    }
    
    int findKth(vector<int> a, int n, int K) {
        // 第K大，就是从小到大排序后 索引为 n-K
        int l = 0;
        int r = n-1;
        int curI;
        while(l<r){
            curI = partition(a, l, r);
            
            if(curI > n-K){
                r--;
            }
            else if(curI<n-K){
                l++;
            }
            else{
                return a[curI];
            }
        }
        return a[curI];
        
        
    }
};
```





### 剑指 Offer 21. 调整数组顺序使奇数位于偶数前面

快排变种。这里就是令i指向第一个不是偶数的位置。

```
class Solution {
public:
 
    vector<int> exchange(vector<int>& nums) {
        if(nums.size() == 0) return nums;
        int i, j;
        i = 0; j=0;
        while(j<nums.size()){
            if(nums[j]&1){
                swap(nums[i++], nums[j++]);
            }
            else{
                j++;
            }
        }
        return nums;
        
    }
};
```





### NC22 合并两个有序的数组

水题

双指针 从后往前归并排序

```
class Solution {
public:
    void merge(int A[], int m, int B[], int n) {
        int end = m+n-1;
        int i = m-1;
        int j = n-1;
        
        while(i>=0 && j>=0){
            if(A[i]>=B[j]){
                A[end--] = A[i--];
            }
            else{
                A[end--] = B[j--];
            }
        }

        while(j>=0){  // B还有元素
            A[end--] = B[j--];
        }

    }
};
```



### NC70 单链表的排序

单链表排序，放到vector里，排完再放回去。

```
/**
 * struct ListNode {
 *	int val;
 *	struct ListNode *next;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param head ListNode类 the head node
     * @return ListNode类
     */
    ListNode* sortInList(ListNode* head) {
        // write code here
        vector<int>vec;
        ListNode* cur = head;
        while(cur){
            vec.push_back(cur->val);
            cur = cur->next;
        }
        sort(vec.begin(), vec.end());
        cur = head;
        for(int i=0; i<vec.size(); i++){
            cur->val = vec[i];
            cur = cur->next;
        }
        return head;
    }
};
```



方法二：归并排序

需要用到 <u>NC51 合并k个已排序的链表</u>  的合并两个有序序列。

步骤：

1. 快慢指针切分成两段
2. 对两段调用排序（主函数）
3. 合并两段有序的

边界是 `head==nullptr || head->next == nullptr`

```
/**
 * struct ListNode {
 *	int val;
 *	struct ListNode *next;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param head ListNode类 the head node
     * @return ListNode类
     */

    ListNode* mergeTwoLists(ListNode* a, ListNode* b){
        ListNode* h = new ListNode(0);
        ListNode* cur = h;

        while(a && b){
            if(a->val < b->val){
                cur->next = a;
                a = a->next;
            }
            else{
                cur->next = b;
                b = b->next;
            }
            cur = cur->next;
        }
        if(a||b) cur->next = a? a : b;
        return h->next;
    }

    ListNode* sortInList(ListNode* head) {
        if(head==nullptr || head->next == nullptr)  // 当前段只有一个节点了
            return head;

        // 切分成两段
        ListNode * fast, *slow;
        fast = head; slow = head;
        while(fast->next && fast ->next->next){
            fast = fast->next->next;
            slow = slow->next;
        }
        // 对两段排序
        ListNode* head2 = slow->next;
        slow->next = nullptr;
        head = sortInList(head);
        head2 = sortInList(head2);

        // 调用mergeTwoLists合并
        head = mergeTwoLists(head, head2);
        return head;
    }
};
```





### <font color=purple>NC131 数据流中的中位数</font>

找中位数。

方法一：插入排序

```
class Solution {
public:
    vector<int>vec;
    
    void Insert(int num) {
        if(vec.empty())
            vec.push_back(num);
        else{
            // 插入排序
            vector<int>::iterator it = lower_bound(vec.begin(), vec.end(), num);
            vec.insert(it, num);
        }
        
    }

    double GetMedian() { 
        int len = vec.size();
        if(len &1){
            return vec[len>>1];
        }
        else{
            return ((double)vec[len>>1] + (double)vec[(len-1)>>1])/2;
        }
    }

};
```



方法二：大小堆

中位数是指：有序数组中中间的那个数。则根据中位数可以把数组分为如下三段:
`[0 ... median - 1], [median], [median ... arr.size() - 1]`，即`[中位数的左边，中位数，中位数的右边]`

所以重要的有两个数，一个是左边的最大值，一个是右边的最小值。所以使用大顶堆和小顶堆来维护。

每次插入时，判断当前数字num和左边最大值的大小。

插入后，需要平衡一下两个堆的数目。

```
class Solution {
public:
    
    priority_queue<int, vector<int>, less<int> > left_pq;  // 大顶堆
    priority_queue<int, vector<int>, greater<int> > right_pq;  // 小顶堆
    
    void Insert(int num) {
        if(left_pq.empty() || left_pq.top() > num)
            left_pq.push(num);
        else
            right_pq.push(num);
        
//         printf("%d %d\n", left_pq.size(), right_pq.size());
        // 奇怪，这里必须用 a 和 b 赋值，不能直接拿 size()，会答案错误？？
        int a = left_pq.size();
        int b = right_pq.size();
        
        // 平衡一下数目
        if(a - b > 1){  // 左边多（2个），就把左边的最大值移入右边
            right_pq.push(left_pq.top());
            left_pq.pop();
        }
        else if(b > a){  // 右边的不准多于左边
            // 因为我们想保证总数为奇数时，中位数在左边
            left_pq.push(right_pq.top());
            right_pq.pop();
        }
    }

    double GetMedian() { 
        if((left_pq.size() + right_pq.size()) & 1){  // 奇数
            return (double)left_pq.top();
        }
        else{
            return (double)((left_pq.top() + right_pq.top())/2.0);
        }
    }

};
```



### <font color=purple>NC73 数组中出现次数超过一半的数字</font>

技巧题。

出现次数超过一半说明什么？说明这个数字比剩下的所有数字都多。

那来一个抵消一个就是了。最极端情况下，其他数字均与这个数相抵，那这个数字仍然还剩着。

其他情况下，可能其他数字内部相抵消了，那剩的更多。

```
class Solution {
public:
    int MoreThanHalfNum_Solution(vector<int> numbers) {
        map<int, int>count;
        int cur;
        for(int i=0; i<numbers.size(); i++){
            if(count.empty()){  // 当前还没有数字
                count[numbers[i]]++;  // 放入map
                cur = numbers[i];  // cur表示当前数字
            }
            else{  // 当前有数字了
                if(cur==numbers[i])  // 增加自己
                    count[cur]++;
                else{  // 抵消1个
                    count[cur]--;
                    if(count[cur]==0)
                        count.erase(cur);
                }
            }
        }
        // 最后map一定只剩一个
        return count.begin()->first;
    }
};
```



哦其实可以不用map，直接维护一个count 就行了。

```
class Solution {
public:
    int MoreThanHalfNum_Solution(vector<int> numbers) {
        int count = 0;
        int cur = 0;
        for(int i=0; i<numbers.size(); i++){
            if(count==0){  // 当前还没有数字
                count++;
                cur = numbers[i];  // cur表示当前数字
            }
            else{  // 当前有数字了
                if(cur==numbers[i])  // 增加自己
                    count++;
                else count--;  // 抵消1个
            }
        }
        // 最后map一定只剩一个
        return cur;
    }
};
```



### ⚡️<font color=fuchsia>NC118 数组中的逆序对</font>

容易理解，但很难想到。

评论区Dylan大佬的方法：

> 归并统计法，关键点在于合并环节，在合并数组的时候，当发现**右边的小于左边**的时候，此时可以直接求出当前产生的逆序对的个数
>
> 举个例子：
>
> 在合并 {4 ,5} {1 , 2} 的时候，首先我们判断 4 > 1，我们即可统计出当前逆序对为2，为什么呢？这利用了数组的部分有序性。因为我们知道 {4 ,5} 这个数组必然是有序的，因为是合并上来的。此时当 1比4小的时候，证明4以后的数也都比1大，此时就构成了从4开始到 {4,5}这个数组结束，这么多个逆序对（2个），此时利用一个临时数组，将1存放起来，接着比较2和4的大小，同样可以得到有2个逆序对，于是将2也放进临时数组中，此时右边数组已经完全没有元素了，则将左边剩余的元素全部放进临时元素中，最后将临时数组中的元素放进原数组对应的位置。
>
> 最后接着向上合并~

完整代码：

```
class Solution {
public:
    int temp[100001];
    long long res = 0;
    long long kmod = 1000000007;
    
    void merge(vector<int>& data, int l, int mid, int r){
        int cur = 0;
        int i, j;
        i = l; j=mid+1;  // 别初始化错了！！！！！！！！！
        while(i<=mid && j<=r){
            if(data[i]<=data[j]){
                temp[cur++] = data[i++];
            }
            else{  // data[i] > data[j] 既然左边数组第i个位置比data[j]大，那第i到末尾都比data[j]大
                res += (mid-i+1);
                res = res%kmod;
                temp[cur++] = data[j++];
            }
        }
        while(i<=mid) temp[cur++] = data[i++];
        while(j<=r) temp[cur++] = data[j++];
        
        for(cur = 0; cur<r-l+1; cur++){
            data[l+cur] = temp[cur];
        }
    }
    
    void mergeSort(vector<int>& data, int l, int r){  // [l, r]
        if(l>=r) return ;
        
        int mid = (l+r)>>1;
        mergeSort(data, l ,mid);
        mergeSort(data, mid+1, r);
        
        merge(data, l, mid, r);
    }
    
    int InversePairs(vector<int> data) {
        if(data.empty()) return 0;
        mergeSort(data, 0, data.size()-1);
        
        return (int)res;
    }
};
```



### <font color=purple>NC37 合并区间</font>

不难，但是容易超时。

双指针。 \[a, b], \[c, d] 可以合并的条件是 a≤c≤b

先按start进行排序，遍历的时候左边界就可以定下来，即a≤c一定满足，然后不断向右扩充。判断条件是 b和c的大小，合并后的右边界是两个右边界的最大值。

```
while(i+1<intervals.size() && intervals[i+1].start<=right){
```

此外，不能在原有的vector上进行erase，会超时。。。还是直接开新的vector进行push吧。

完整代码：

```
/**
 * Definition for an interval.
 * struct Interval {
 *     int start;
 *     int end;
 *     Interval() : start(0), end(0) {}
 *     Interval(int s, int e) : start(s), end(e) {}
 * };
 */
class Solution {
public:
    
    static bool cmp(Interval a, Interval b){
        if(a.start == b.start){
            return a.end<b.end;
        }
        else return a.start<b.start;
    }
    
    vector<Interval> merge(vector<Interval> &intervals) {
        if(intervals.empty()) return intervals;
        sort(intervals.begin(), intervals.end(), cmp);
        
        vector<Interval>res;
        int left, right;
        for(int i=0; i<intervals.size(); i++){
            left = intervals[i].start;
            right = intervals[i].end;
            
            while(i+1<intervals.size() && intervals[i+1].start<=right){
                right = max(right, intervals[i+1].end);
                i++;
            }
            res.push_back(Interval(left, right));
        }
        return res;
    }
};
```



### NC77 调整数组顺序使奇数位于偶数前面(一)

水题。



法一：vector

拼接两个vector：

```
vec1.insert(vec1.end(), vec2.begin(), vec2.end());
```



```
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param array int整型vector 
     * @return int整型vector
     */
    vector<int> reOrderArray(vector<int>& array) {
        vector<int>vec1, vec2;
        for(int i=0; i<array.size(); i++){
            if(array[i] & 1)
                vec1.push_back(array[i]);
            else vec2.push_back(array[i]);
        }
        // 在vec1后面插入vec2
        vec1.insert(vec1.end(), vec2.begin(), vec2.end());
        return vec1;
    }
};
```







## 数据结构

### ⭐️<font color=red>NC93 设计LRU缓存结构</font>

https://www.nowcoder.com/practice/e3769a5f49894d49b871c09cadd13a61?tpId=117&&tqId=37804&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking

✅已根据NC94更新本题的第二种解法。



方法一：

list用push_front和erase的。 **约定 list 的头部是最新的，末尾是最旧的。**

```
get操作：
根据map查询list的iter
	如果有，根据iter去list取值。并把list当前位置的iter删除，重新添加到列表头部。然后更新map
	否则return -1

set操作：
list是否已满
	满了，找到list里最不常使用的（尾）iter，删除map里对应的key，删除list该指针
插入新的。
更新map。
```



⚠️map<int, list<pair<int, int>>::iterator>的这种写法有局限性！这一题由于始终在队尾插入，不会影响链表（list）中其他元素的地址，所以才能通过。如果在中间插入的话，不行！尽量把cache和LRU分开。（参考NC94）

```
class Solution {
public:

     typedef pair<int, int> pii;
     
     list<pii> lru_list;  // list(key, value)
     unordered_map<int, list<pii>::iterator> mmap;  // key -> lru_list指针
     
     list<pii>::iterator it;  // lru_list 指针

     int cap;
     Solution(int capacity){
          cap = capacity;
     }
    
     int get(int key) {
          if(mmap.find(key) != mmap.end()){
               // 取值
               int value = mmap[key]->second;
               // 刷新缓存
               lru_list.erase(mmap[key]);
               lru_list.push_front({key, value});
               return value;
          }
          else return -1;
     }

     void set(int key, int value){
          // 查询有没有
          if(mmap.find(key) != mmap.end()){
               // 刷新缓存
               lru_list.erase(mmap[key]);
          }
          else{
               if(lru_list.size() >= cap){
                    // 删除列表末尾
                    int dkey = lru_list.back().first;   // back()函数返回一个引用，指向list的最后一个元素
                    mmap.erase(dkey);
                    lru_list.pop_back();
               }
          }
          lru_list.push_front({key, value});
          // 记得更新map  
          mmap[key] = lru_list.begin();//begin：返回一个迭代器 front：返回引用
     }
};

```



方法二：

```
class Solution {
  public:

    typedef pair<int, int> pii;
    
    unordered_map<int, int> cache;  // key -> value
    unordered_map<int, int> record;  // key -> (timestamp)
    priority_queue<pii, vector<pii>, greater<pii>> inq;  // 入堆（小顶堆），存放 (timestamp, key)
    priority_queue<pii, vector<pii>, greater<pii>> deq;  // 出堆
    
    int timestamp = 0;  // 全局时间

    int cap;
    Solution(int capacity) {
        cap = capacity;
    }

     void update_record(int key) { // 更新key对应的record和timestamp信息
          ++timestamp;
          if (record.count(key)) {
               deq.push(make_pair(record[key], key));  // 删除旧的记录
          }
          record[key] = timestamp;
          inq.push(make_pair(record[key], key));  // 插入新的记录
     }

     int queryLRU(){
          while(!inq.empty() && !deq.empty()){
               if(inq.top() == deq.top()){
                    inq.pop();
                    deq.pop();
               }
               else break;
          }
          return inq.top().second;  // 表示最久远的key
     }

     int get(int key) {
          if (cache.find(key) != cache.end()) {
               // 刷新缓存
               update_record(key);
               // 返回结果
               return cache[key];
          }
          return -1;
     }

    void set(int key, int value) {
         // 如果已有这个元素
        if(cache.count(key)){
             cache[key] = value;
             update_record(key);
        }
        else{  // 添加元素
          if(cache.size() >= cap){  // 通过LRU策略返回要删除的key，执行删除然后再插入
              // 删除记录
              int dkey = queryLRU();
              deq.push(make_pair(record[dkey], dkey));  // 注意是 dkey
              cache.erase(dkey);
              record.erase(dkey);
          }
          // 插入新的
          cache[key] = value;
          update_record(key);
        }
    }
};
```



### ⚡️<font color=fuchsia>NC94 设计LFU缓存结构</font>

<font color=red>时间复杂度 O(logn)</font>

复杂结构小顶堆，**cache，record，LFU分别维护**！

cache只存储 key value映射，record存放key对应的 count和timestamp信息。

LFU根据record中的信息，找出count最小并且timestamp最早的dkey（所以使用小顶堆），进行删除。

双优先队列inq、deq实现插入和删除：

**inq用来记录插入，deq用来记录删除。每次删除时，向deq插入删除数据，假装删除。当必要时（需要调用LFU返回dkey）， inq和deq互相抵消堆顶来进行真正的删除。**

每次set和get都需要更新record！



轩神给我讲解后，我按照理解写的版本：

```
class Solution {
public:
    /**
     * lfu design
     * @param operators int整型vector<vector<>> ops
     * @param k int整型 the k
     * @return int整型vector
     */
    
    int timestamp = 0;
    map<int, int>cache;  // key -> value
    map<int, pair<int, int>>record;  // key -> (count, timestamp)
    // 小顶堆 ((count, timestamp), key)
    priority_queue<pair<pair<int, int>, int>, vector<pair<pair<int, int>, int>>, greater<pair<pair<int, int>, int>>> inq, deq;
    
    
    void update_record(int key){  // 更新key对应的count和timestamp信息
        ++timestamp;
        if(record.count(key)){  // 注意这里是 record ！！而不能用cache.count。因为对于set操作，在更新record前已经更新/插入了cache！
            deq.push(make_pair(make_pair(record[key].first, record[key].second), key));
            record[key].first++;
            record[key].second = timestamp;
            inq.push(make_pair(make_pair(record[key].first, record[key].second), key));
        }
        else{
            record[key] = make_pair(1, timestamp);
            inq.push(make_pair(make_pair(1, timestamp), key));
        }
    }
    
    int query_LFU(){
        while(!inq.empty() && !deq.empty()){
            if(inq.top() == deq.top()){
                inq.pop();
                deq.pop();
            }
            else break;
        }
        return inq.top().second;  // 返回要删除的元素的key
    }
    
    vector<int> LFU(vector<vector<int> >& operators, int k) {
        vector<int>ans;
        if(operators.empty())
            return ans;

        for(auto oper : operators){
            if(oper[0]==1){  // set
                if(cache.count(oper[1])){  // 有这个元素
                    cache[oper[1]] = oper[2];
                    update_record(oper[1]);
                }
                else{  // 没有这个元素
                    if(cache.size()<k){  // 不用删除其他的
                        cache[oper[1]] = oper[2];
                        update_record(oper[1]);
                    }
                    else{
                        // 通过LFU策略返回要删除的key，执行删除然后再插入
                        int dkey = query_LFU();
                        deq.push(make_pair(make_pair(record[dkey].first, record[dkey].second), dkey));
                        cache.erase(dkey);
                        record.erase(dkey);
                        // 插入
                        cache[oper[1]] = oper[2];
                        update_record(oper[1]);
                    }
                }
            }
            else if(oper[0]==2){  // get
                if(cache.count(oper[1])){
                    ans.push_back(cache[oper[1]]);
                    update_record(oper[1]);  // get也要更新！！！
                }
                else ans.push_back(-1);
            }
        }
        return ans;
    }
};
```



轩神源代码：（偷懒一下，虽然用的大顶堆，但每次插入时加个负号变成小顶堆）

```
class Solution {
public:
    /**
     * lfu design
     * @param operators int整型vector<vector<>> ops
     * @param k int整型 the k
     * @return int整型vector
     */
    
    map<int, int> cache;

    int timestamp = 0;
    map<int, pair<int,int> > record;  // key -> (count, timestamp)
    // inq用来记录插入，deq用来记录删除。每次删除时，向deq插入删除数据，假装删除。当必要时， inq和deq互相抵消堆顶来进行真正的删除。
    priority_queue<pair<pair<int,int>,int> > inq, deq;  // ((count, timestamp), key)
    
    void update_record(int key) {
        ++timestamp;
        if(record.count(key)) {  // 删除旧的，更新count和时间戳，再放进去
            deq.push(make_pair(make_pair(-record[key].first, -record[key].second), key));
            record[key].first++;
            record[key].second = timestamp;
            inq.push(make_pair(make_pair(-record[key].first, -record[key].second), key));
        } else {  // 放进去新的
            record[key] = make_pair(1, timestamp);
            inq.push(make_pair(make_pair(-1, -timestamp), key));
        }
    }
    int query_LFU() {  // LFU决策，返回应该被删除的key
        while(!inq.empty() && !deq.empty()) {
            if(inq.top() == deq.top()) {
                inq.pop();
                deq.pop();
            } else {  // 如果 inq.top()!= deq.top()，说明 inq.top()没有被删除
                break;
            }
        }
        return inq.top().second;
    }
    vector<int> LFU(vector<vector<int> >& operators, int k) {
        vector<int> ans;

        for(auto oper : operators) {
            if(oper[0] == 1) {  // set
                if(cache.count(oper[1])) {  // cache已有数据，简单的更新
                    cache[oper[1]] = oper[2];
                    update_record(oper[1]);
                } else {  // 插入新的元素
                    if(cache.size() < k) {
                        cache[oper[1]] = oper[2];
                        update_record(oper[1]);
                    } else {  // 缓存满了，需要根据LFU决策删除小次数和最早访问的元素，再插入
                        int dkey = query_LFU();
                        deq.push(make_pair(make_pair(-record[dkey].first, -record[dkey].second), dkey));
                        record.erase(dkey);
                        cache.erase(dkey);

                        cache[oper[1]] = oper[2];
                        update_record(oper[1]);
                    }
                }
            } else if(oper[0] == 2) {  // get
                if(cache.count(oper[1])) {
                    ans.push_back(cache[oper[1]]);
                    update_record(oper[1]);
                } else {
                    ans.push_back(-1);
                }
            }
        }
        
        return ans;
    }
};
```



### NC61 两数之和

map。

在数组中找出两个加起来等于目标值的数的下标。

```
class Solution {
public:
    /**
     * 
     * @param numbers int整型vector 
     * @param target int整型 
     * @return int整型vector
     */
    unordered_map<int, int>pos;
    vector<int> twoSum(vector<int>& numbers, int target) {
        // write code here
        pos.clear();
        vector<int>res;
        
        for(int i=0; i<numbers.size(); i++){
            if(pos.find(target-numbers[i])==pos.end()){  // map中没有该元素的互补元素
                if(pos.find(numbers[i])==pos.end()){  // 没有该元素
                    pos[numbers[i]] = i;
                }
            }
            else{
                res.push_back(pos[target-numbers[i]]+1);
                res.push_back(i+1);
            }
        }
        return res;
    }
};
```



### <font color=purple>[lc]454. 四数相加 II</font>

哈希。我们可以将四个数组分成两部分，A和B一组，C和D一组

```
class Solution {
public:
    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
        if(nums1.size() == 0) return 0;
        int n = nums1.size();

        unordered_map<int, int>cnt1;
        unordered_map<int, int>cnt2;


        for(int i=0; i<n; i++){
            for(int j=0; j<n; j++){
                cnt1[nums1[i] + nums2[j]]++;
            }
        }

        for(int i=0; i<n; i++){
            for(int j=0; j<n; j++){
                cnt2[-(nums3[i] + nums4[j])]++;
            }
        }

        auto it = cnt1.begin();
        int res =0;
        while(it!=cnt1.end()){
            res += it->second * cnt2[it->first];
            it++;
        }
        return res;
    }
};
```

优化，不用再遍历map了，直接在循环 nums3和nums4的过程中，找 cnt1[-(nums3[i] + nums4[j])]，每次都加上这个数目。还能省去 一个map

```
class Solution {
public:
    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
        if(nums1.size() == 0) return 0;
        int n = nums1.size();

        unordered_map<int, int>cnt1;

        for(int i=0; i<n; i++){
            for(int j=0; j<n; j++){
                cnt1[nums1[i] + nums2[j]]++;
            }
        }

        int res =0;
        for(int i=0; i<n; i++){
            for(int j=0; j<n; j++){
                res+=cnt1[-(nums3[i] + nums4[j])];
            }
        }
        return res;
    }
};
```







### <font color=dodgerblue>NC41 最长无重复子数组</font>

方法一：暴力（不推荐）

子数组一定是连续的，那就不断固定起始位置，往后找，直到遇到重复的。时间复杂度 O(n^2)。竟然没超时...

这里不写了。



方法二：队列

把元素不停的加入到队列中，如果有相同的元素，就不断把队首的元素移除，直到不包含相同元素。

```
class Solution {
public:
    /**
     * 
     * @param arr int整型vector the array
     * @return int整型
     */
    unordered_map<int, bool>visited;
    queue<int>q;
    int maxLength(vector<int>& arr) {
        if(arr.size()==0)
            return 0;
        
        visited.clear();
        while(!q.empty()) q.pop();
        
        int maxl = 0;
        
        for(int i=0; i<arr.size(); i++){
            // 如果队列有相同的元素了
            while(visited.find(arr[i])!= visited.end()){
                int temp = q.front();
                q.pop();
                visited.erase(temp);
            }
            // 这时候已经被清除了
            q.push(arr[i]);
            visited[arr[i]] = true;
            maxl = max(maxl, (int)q.size());
        }
        return maxl;
    }
};
```



方法三：双指针队列

思想相同，只不过用left和right当队头队尾。

（这里采用了和 <u>[lc]和大于等于target的最短子数组</u> 双指针循环的写法，即两层while，而不是以前常用的for）

```

class Solution {
public:
    /**
     * 
     * @param arr int整型vector the array
     * @return int整型
     */
    unordered_map<int, int> visited;


    int maxLength(vector<int>& arr) {
        int l, r;
        l = 0; r = 0;

        int maxl = 0;

        while(r<arr.size()){
            // 检查之前arr[r]有没有被访问
            while(visited.find(arr[r])!= visited.end()){  // 不断右移动左指针，直到 arr[r] 被删除
                visited.erase(arr[l]);
                l++;
            }
            visited[arr[r]] = 1;  // 当前右位置放入
            maxl = max(maxl, r-l+1);
            r++;
        }

        return maxl;
    }
};
```

**改进：map里存放key上次最近一次出现的位置。**

```

#include <unordered_map>
class Solution {
public:
    /**
     * 
     * @param arr int整型vector the array
     * @return int整型
     */

    unordered_map<int, int> exist;

    int maxLength(vector<int>& arr) {
        int l, r;
        l = 0; r = 0;
        int maxx = 0;
        while(r<arr.size()){
            while(exist.find(arr[r]) != exist.end() && exist[arr[r]] >= l )
                l++;
            exist[arr[r]] = r;
            maxx = max(maxx, r-l+1);
            r++;
        }
        return maxx;
    }
};
```



方法四：

暂时搁置



### NC52 有效括号序列

简单的匹配括号。用栈。

注意判断栈空。

```
class Solution {
public:
    /**
     * 
     * @param s string字符串 
     * @return bool布尔型
     */
    bool isValid(string s) {
        // write code here
        stack<char>st;
        for(int i=0; i<s.length(); i++){
            if(s[i]=='(' || s[i]=='[' || s[i]=='{')
                st.push(s[i]);
            else{
                if(st.empty()) return false;  // 来了右半边但栈空，无匹配
                if(s[i]==')'){
                    if(st.top()=='(')
                        st.pop();
                    else return false;
                }
                else if(s[i]==']'){
                    if(st.top()=='[')
                        st.pop();
                    else return false;
                }
                else if(s[i]=='}'){
                    if(st.top()=='{')
                        st.pop();
                    else return false;
                }
            }
        }
        if(!st.empty())  // 栈不空，还有字符没匹配
            return false;
        else return true;
    }
};
```



### NC75 数组中只出现一次的两个数字

一个整型数组里除了两个数字只出现一次，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。

第一次出现时写入map，既然其他的数字都出现了两次，那第二次出现时把它从map里删了就是。

map的key默认是有序的。

```
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param array int整型vector 
     * @return int整型vector
     */
    map<int, bool>visited;  // map的key本身就是有序的
    vector<int> FindNumsAppearOnce(vector<int>& array) {
        vector<int>res;
        if(array.empty()) return res;
        
        visited.clear();
        for(int i=0; i<array.size(); i++){
            if(visited.find(array[i])==visited.end())
                visited[array[i]] = true;
            else visited.erase(array[i]);  // 既然其他的都出现两次，那直接第二次出现时把它删掉
        }
        map<int, bool>::iterator iter;
        for(iter = visited.begin(); iter!=visited.end(); iter++){
            res.push_back(iter->first);
        }
        return res;
    }
};
```





### ⚡️<font color=red>NC90 包含min函数的栈</font>

使用辅助栈实现O(1)时间得到正常栈的最小值。

注意！minx在push和pop时都要更新。

```
class Solution {
public:
    
    stack<int>normal;
    stack<int>minimal;  // 辅助栈
    int minx = 10001;
    
    void push(int value) {
        if(minx >value)
            minx = value;
        normal.push(value);
        minimal.push(minx);
    }
    void pop() {
        normal.pop();
        minimal.pop();
        minx = minimal.top();  // 要更新！
    }
    int top() {
        return normal.top();
    }
    int min() {
        return minimal.top();
    }
};
```



### NC97 字符串出现次数的TopK问题

1. 用map统计次数
2. 用结构体表示(str, count) 放入到vector中进行排序
3. 排完序取前k个作为结果

记得int转string 是用 to_string函数

```
class Solution {
public:
    /**
     * return topK string
     * @param strings string字符串vector strings
     * @param k int整型 the k
     * @return string字符串vector<vector<>>
     */
    map<string, int>count;
    
    struct node{
        string str;
        int c;
        node(string str, int c): str(str), c(c){}
    };
    
    static bool cmp(node a, node b){
        if(a.c == b.c)
            return a.str < b.str;  // 频数一样时，字典序小的排前面
        else return a.c > b.c;  // 频数大的在前面
    }
    
    vector<vector<string> > topKstrings(vector<string>& strings, int k) {
        vector<vector<string>>res;
        
        for(int i=0; i<strings.size(); i++)  // 统计次数
            count[strings[i]]++;
        
        // 把map里的放到vec中准备排序
        map<string, int>::iterator it;
        vector<node>vec;
        for(it=count.begin(); it!=count.end(); it++){
            vec.push_back(node(it->first, it->second));
        }
        sort(vec.begin(), vec.end(), cmp);

        // 排完序后取前k个放到结果里
        for(int i=0; i<k; i++)
            res.push_back({vec[i].str, to_string(vec[i].c)});
        
        return res;
    }
};
```



堆解法：有点麻烦了属于是

必须用大顶堆！因为结果需要按照字典序，而且替换策略还要字典序，不能单纯的用小顶堆再reverse。

应该统计次数时用负数，然后结果再 reverse。

```
class Solution {
public:
    /**
     * return topK string
     * @param strings string字符串vector strings
     * @param k int整型 the k
     * @return string字符串vector<vector<>>
     */
    map<string, int>count;  // （str -> 次数（负数））
    // 必须用大顶堆！因为结果需要按照字典序，而且替换策略还要字典序，不能单纯的用小顶堆再reverse
    // 因此 统计次数时要用负数。
    priority_queue<pair<int, string>> pq;  // （次数（负数） -> str）
    
    vector<vector<string> > topKstrings(vector<string>& strings, int k) {
        vector<vector<string>>res;
        
        for(int i=0; i<strings.size(); i++)  // 统计次数（负数）
            count[strings[i]]--;
        
        map<string, int>::iterator it = count.begin();
        
        for(; it!=count.end(); it++){
            if(pq.size()<k){
                pq.push(make_pair(it->second, it->first));
            }
            else{  // 替换策略
                if(it->second < pq.top().first
                   || (it->second == pq.top().first && it->first < pq.top().second) ){
                    pq.pop();
                    pq.push(make_pair(it->second, it->first));
                }
            }
        }
        while(!pq.empty()){
            res.push_back({pq.top().second, to_string(-pq.top().first)});
            pq.pop();
        }
        reverse(res.begin(), res.end());
        
        return res;
        
    }
};
```





### ⚡️<font color=red>NC82 滑动窗口的最大值</font>

方法一：双端队列deque。

维护一个<font color=red>**单调递减的队列**</font>（这里为了记录每个元素的有效期，队列里放置的索引）

循环判断如果当前元素比队尾的大，那么**删除队尾**。否则当前元素放在队尾。

使用索引和size比较判断是否过期。

每次返回队头的元素，也就是最大值。注意，前几个元素还不组成窗口，不要输出。

```
class Solution {
public:
    vector<int> maxInWindows(const vector<int>& num, unsigned int size) {
        vector<int>res;
        if(num.empty() || size>num.size()) return res;
        if(size==1) return num;
        
        deque<int>dq;  // 由于需要判断元素是否过期，dq存储的是索引，不是值。
        for(int i=0; i<num.size(); i++){
            // 把比当前位置小的都从队尾踢出去，用不到了
            while(!dq.empty() && num[dq.back()]<num[i])
                dq.pop_back();
            dq.push_back(i);  // 放在队尾
            
            // 检查一下队头是否过期
            // 不过期：front + size > i，反之 front + size <=i
            while(!dq.empty() && dq.front()+size <= i )
                dq.pop_front();
            if(i>=size-1)  // 前几个元素还组不成窗口，不能输出。至少过了 size 才能组成窗口
                res.push_back(num[dq.front()]);  // 把队头的最大的放进去
        }
        
        return res;
    }
};
```



方法二：pair优先队列

```
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        vector<int> res;
        priority_queue<pair<int, int>> pq;  // 大顶堆 (value, index)

        for(int i=0; i<nums.size(); i++){
            pq.push(make_pair(nums[i], i));

            while(!pq.empty() && pq.top().second + k <=i )
                pq.pop();
            
            if(i+1 >= k)
                res.push_back(pq.top().first);
        }

        return res;
    }
};
```







### NC157 单调栈

找到**每一个** i 位置左边和右边离 i 位置最近且值比 arri 小的位置。

思路嘛... 就模拟一下就出来了。

例如，输入 \[3,4,1,5,6,2,7]，以找左边的为例

维护一个左栈 lst，遇到 lst.top() > nums\[i]的就弹出（因为栈顶比当前元素都大，后面再往右遍历时nums\[i]就够了），直到遇到比自己小的。

每次都把当前元素压入栈。

```
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param nums intvector 
     * @return intvector<vector<>>
     */
    vector<vector<int> > foundMonotoneStack(vector<int>& nums) {
        vector<vector<int>> res(nums.size(), vector<int>(2, -1));

        stack<int>lst, rst;  // 注意stack里存放的是索引！！！
        for(int i=0; i<nums.size(); i++){
            while(!lst.empty() && nums[lst.top()]>=nums[i])
                lst.pop();
            
            if(lst.empty()) res[i][0] = -1;
            else res[i][0] = lst.top();
            lst.push(i);
        }
        
        for(int i=nums.size()-1; i>=0; i--){
            while(!rst.empty() && nums[rst.top()]>=nums[i])
                rst.pop();
            if(rst.empty()) res[i][1] = -1;
            else res[i][1] = rst.top();
            rst.push(i);
        }
        return res;
    }
};
```

